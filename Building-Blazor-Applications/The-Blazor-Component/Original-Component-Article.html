<!DOCTYPE html>
<html lang="en">
<head>
    
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<!-- SEO Meta Tags -->
<meta name="description" content="Your description">
<meta name="author" content="Your name">

<!-- OG Meta Tags to improve the way the post looks when you share the page on Facebook, Twitter, LinkedIn -->
<meta property="og:site_name" content="" /> <!-- website name -->
<meta property="og:site" content="" /> <!-- website link -->
<meta property="og:title" content="" /> <!-- title shown in the actual shared post -->
<meta property="og:description" content="" /> <!-- description shown in the actual shared post -->
<meta property="og:image" content="" /> <!-- image link, make sure it's jpg -->
<meta property="og:url" content="" /> <!-- where do you want your post to link to -->
<meta name="twitter:card" content="summary_large_image"> <!-- to have large image post format in Twitter -->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


<meta name="description" content="The original piublished Component article" >
<meta name="author" content="Shaun Curtis" >



<title>Original Component Article</title>


<!-- Custom fonts for this template-->
<link href="/assets/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i"
      rel="stylesheet">

<!-- Custom styles for this template-->
<link href="/assets/css/sb-admin-2.css" rel="stylesheet" type="text/css">
<link href="/assets/css/site.css" rel="stylesheet" type="text/css">

<!-- Favicon  -->
<link rel="icon" href="/assets/images/favicon.png">


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
    <link rel="stylesheet" href="/assets/css/article.css" type="text/css">
</head>
<body id="page-top">
    <!--topbar-->
    <div id="topbar">
        
<!-- Topbar -->
<nav class="navbar navbar-expand navbar-light topbar mb-4 static-top">
    
<ul class="navbar-nav" >
<li class="nav-item" >
<a class="nav-link " href="/index.html" role="button"  >
<span class="mr-2 d-none d-lg-inline text-gray-100">Index</span>
</a>
</li>
<li class="nav-item dropdown no-arrow mx-1" >
<a class="nav-link dropdown-toggle" href="#" id="93db271b-a1b4-4853-8060-7714d34e73b7" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"  >
<span class="mr-2 d-none d-lg-inline text-gray-100">Articles</span>
</a>
<div class=" dropdown-list dropdown-menu shadow animated--grow-in" aria-labelledby="93db271b-a1b4-4853-8060-7714d34e73b7" >
<a class="dropdown-item" href="/articles/A-Flexible-App.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Creating a Dynamic Blazor App Component
</a>
<a class="dropdown-item" href="/articles/Async-Programming-in-DotNetCore.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Async Programming In Dotnetcore
</a>
<a class="dropdown-item" href="/articles/Blazor-AllinOne.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor All In One - Multi SPA Hosting
</a>
<a class="dropdown-item" href="/articles/Blazor-Async-Programming.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Async Programming
</a>
<a class="dropdown-item" href="/articles/Blazor-Brick-By-Brick.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Brick By Brick
</a>
<a class="dropdown-item" href="/articles/Blazor-Components.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Components
</a>
<a class="dropdown-item" href="/articles/Blazor-CSS.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor CSS
</a>
<a class="dropdown-item" href="/articles/Blazor-DataList-Control.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Datalist Control
</a>
<a class="dropdown-item" href="/articles/Blazor-Form-Validation.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Form Validation
</a>
<a class="dropdown-item" href="/articles/Building-Blazor-List-Components.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building Blazor List Components and the Notification Pattern
</a>
<a class="dropdown-item" href="/articles/Building-Edit-Forms.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building Edit Forms
</a>
<a class="dropdown-item" href="/articles/EditFormState.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
The Blazor EditFormState Control
</a>
<a class="dropdown-item" href="/articles/Hydra.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Hydra
</a>
<a class="dropdown-item" href="/articles/Inline-Dialog.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
The Blazor Inline Dialog Control
</a>
<a class="dropdown-item" href="/articles/Modal-Dialog.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
A Blazor Modal Dialog
</a>
<a class="dropdown-item" href="/articles/Policy-Based-Authorization.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Policy Base Authorization in Blazor
</a>
<a class="dropdown-item" href="/articles/ValidationFormState.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
A Blazor Validation Control
</a>
<a class="dropdown-item" href="/articles/XML-XSD-Serialization.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
XML XSD Serialization
</a>
</div>
</li>
<li class="nav-item dropdown no-arrow mx-1" >
<a class="nav-link dropdown-toggle" href="#" id="6ad0290a-cb87-4cbe-902d-5dd52c7a0b10" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"  >
<span class="mr-2 d-none d-lg-inline text-gray-100">Blazor Database Apps</span>
</a>
<div class=" dropdown-list dropdown-menu shadow animated--grow-in" aria-labelledby="6ad0290a-cb87-4cbe-902d-5dd52c7a0b10" >
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-1.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 1
</a>
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-2.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 2
</a>
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-3.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 3
</a>
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-4.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 4
</a>
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-5.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 5
</a>
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-6.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 6
</a>
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/index.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building a Database Application in Blazor
</a>
</div>
</li>
<li class="nav-item dropdown no-arrow mx-1" >
<a class="nav-link dropdown-toggle" href="#" id="759a212b-6176-4202-9d80-90ecaedf0537" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"  >
<span class="mr-2 d-none d-lg-inline text-gray-100">Building Blazor Applications</span>
</a>
<div class=" dropdown-list dropdown-menu shadow animated--grow-in" aria-labelledby="759a212b-6176-4202-9d80-90ecaedf0537" >
<a class="dropdown-item" href="/Building-Blazor-Applications/Blazor-Async-UI-Events.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Async UI Events
</a>
<a class="dropdown-item" href="/Building-Blazor-Applications/Blazor-Bootstrap-Toaster.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Bootstrap Toaster
</a>
<a class="dropdown-item" href="/Building-Blazor-Applications/Blazor-Services.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Services
</a>
<a class="dropdown-item" href="/Building-Blazor-Applications/Building-A-Blazor-AutoComplete-Control.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Blazor Autocomplete Control
</a>
<a class="dropdown-item" href="/Building-Blazor-Applications/Building-Wrapper-Components.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building Wrapper Components
</a>
<a class="dropdown-item" href="/Building-Blazor-Applications/DBContexts-In-Transient-Services.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Dbcontexts In Transient Services
</a>
<a class="dropdown-item" href="/Building-Blazor-Applications/DynamicCss.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Dynamic Stylesheets
</a>
<a class="dropdown-item" href="/Building-Blazor-Applications/For-ForEach-in-Blazor.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
For Foreach In Blazor
</a>
<a class="dropdown-item" href="/Building-Blazor-Applications/Leaner-Meaner-Greener-Components.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Leaner Meaner Greener Components
</a>
<a class="dropdown-item" href="/Building-Blazor-Applications/Notification-Service-Pattern.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Notification Service Pattern
</a>
<a class="dropdown-item" href="/Building-Blazor-Applications/The-Blazor-WASM-Hosted-Project.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
The Blazor WASM Hosted Project
</a>
<a class="dropdown-item" href="/Building-Blazor-Applications/Whats-Wrong-with-my-Component-Design.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Whats Wrong With My Component Design
</a>
<a class="dropdown-item" href="/Building-Blazor-Applications/The-Blazor-Component" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building Blazor Applications\The Blazor Component
</a>
</div>
</li>
<li class="nav-item dropdown no-arrow mx-1" >
<a class="nav-link dropdown-toggle" href="#" id="284d889e-7315-4525-a6e2-29d6263ad909" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"  >
<span class="mr-2 d-none d-lg-inline text-gray-100">Design</span>
</a>
<div class=" dropdown-list dropdown-menu shadow animated--grow-in" aria-labelledby="284d889e-7315-4525-a6e2-29d6263ad909" >
<a class="dropdown-item" href="/Design/Clean-Design-In-Blazor.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Clean Design Principles in Blazor Applications
</a>
<a class="dropdown-item" href="/Design/Clean-Design-Blazor-Template.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
A Blazor Clean Design Template
</a>
<a class="dropdown-item" href="/Design/Clean-Design-Blazor-Template-Solution-Structure.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Solution Structure in the Clean Design Blazor Template
</a>
<a class="dropdown-item" href="/Design/Clean-Design-Blazor-Template-DataServices.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Data Services in the Clean Design Blazor Template
</a>
<a class="dropdown-item" href="/Design/Clean-Design-Blazor-Template-UI.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
The UI in the Clean Design Blazor Template
</a>
<a class="dropdown-item" href="/Design/Clean-Design-Blazor-Template-Solution-Setup.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Solution Setup in the Clean Design Blazor Template
</a>
<a class="dropdown-item" href="/Design/Clean-Design-Blazor-Template-Testing.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Testing in the Clean Design Blazor Template
</a>
</div>
</li>
<li class="nav-item dropdown no-arrow mx-1" >
<a class="nav-link dropdown-toggle" href="#" id="e194e20f-a27b-4c7b-a56f-9d7d4abdead7" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"  >
<span class="mr-2 d-none d-lg-inline text-gray-100">Modern C#</span>
</a>
<div class=" dropdown-list dropdown-menu shadow animated--grow-in" aria-labelledby="e194e20f-a27b-4c7b-a56f-9d7d4abdead7" >
<a class="dropdown-item" href="/Modern-Coding-Patterns/Nullable-And-VS-2022.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Nullable And VS 2022
</a>
</div>
</li>
</ul>

    <div class="ms-5 me-5 ml-auto">
        <h1>Cold Elm Coders</h1>
    </div>
</nav>


    </div>
    <!--End topbar-->
    <!--Sidebar-->
    <div id="sidebar">
        
<div class="article-info p-2" Published: 04-01-2022 >
<div>Published: 04-01-2022</div>
<div>Last Updated: 04-01-2022</div>
<div>Author: Shaun Curtis</div>
</div>

        
<h4 class="p-2">Table of Contents</h4>
<ul class="TOC" >
<li class="TOC-item TOC-item-0" >
<a class="TOC-link" href="#">Top</a>
<ul class="TOC TOC-0" >
<li class="TOC-item TOC-item-1" >
<a class="TOC-link" href="#a-deep-dive-into-the-blazor-component">A Deep Dive into the Blazor Component</a>
<ul class="TOC TOC-1" >
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#what-is-a-component">What is a Component?</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-renderer-and-the-render-tree">The Renderer and the Render Tree</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-client-application">The Client Application</a>
<ul class="TOC TOC-2" >
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#blazor-server">Blazor Server</a>
</li>
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#blazor-web-assembly">Blazor Web Assembly</a>
</li>
</ul>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#razor-components">Razor Components</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-component-lifecycle">The Component Lifecycle</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#interfaces">Interfaces</a>
<ul class="TOC TOC-2" >
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#the-rendlehandle">The RendleHandle</a>
</li>
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#the-renderfragment">The RenderFragment</a>
</li>
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#the-helloworld-component">The HelloWorld Component</a>
</li>
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#building-render-fragments">Building Render Fragments</a>
</li>
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#routed-components">Routed Components</a>
</li>
</ul>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#improving-minimalbase">Improving <code>MinimalBase</code></a>
<ul class="TOC TOC-2" >
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#rendering">Rendering</a>
</li>
</ul>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#componentbase">ComponentBase</a>
<ul class="TOC TOC-2" >
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#componentbase-lifecycle-and-events">ComponentBase Lifecycle and Events</a>
</li>
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#and-then-what-no-one-covers">And then what no one covers.</a>
</li>
</ul>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-render-process">The Render Process</a>
<ul class="TOC TOC-2" >
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#component-content">Component Content</a>
</li>
</ul>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#component-events">Component Events</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#some-important-less-documented-information-and-lessons-learned">Some Important Less Documented Information and Lessons Learned</a>
<ul class="TOC TOC-2" >
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#keep-parameter-properties-simple">Keep Parameter Properties Simple</a>
</li>
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#overriding-setparametersasync">Overriding SetParametersAsync</a>
</li>
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#parameters-as-immutable">Parameters as Immutable</a>
</li>
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#iterators">Iterators</a>
</li>
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#component-numbering">Component Numbering</a>
</li>
</ul>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#building-components">Building Components</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#inheritance">Inheritance</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#some-observations">Some Observations</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
    <!--End Sidebar-->
    <!-- Page Wrapper -->
    <div id="wrapper">
        <!-- Content Wrapper -->
        <div id="content-wrapper" class="d-flex flex-column">
            <!-- Main Content -->
            <div id="content">
                <!-- Topbar -->
                <div id="article">
                    <!-- Article -->
                    
<!-- Header -->
<header class="ex-header-article">
    <div class="container">
        <div class="row pt-3 pb-3 border-bottom">
            <div class="col">
                
<h1>Original Component Article</h1>
<div>The original piublished Component article</div>

            </div> <!-- end of col -->
        </div> <!-- end of row -->
    </div> <!-- end of container -->
</header> <!-- end of ex-header -->
<!-- end of header -->


                    
<!-- Article Container -->
<div class="ex-basic-1 pt-4">
    <div class="container">
        <div class="row">
            <div class="col-12">
                

        <h1 id="a-deep-dive-into-the-blazor-component">A Deep Dive into the Blazor Component</h1>
<p><a href="index.html">Back to the Index</a></p>
<h2 id="what-is-a-component">What is a Component?</h2>
<p>Microsoft defines:</p>
<p><em>A component is a self-contained portion of user interface (UI) with processing logic to enable dynamic behavior. Components can be nested, reused, shared among projects, and used in MVC and Razor Pages apps.</em></p>
<p><em>Components are implemented using a combination of C# and HTML markup in Razor component files with the .razor file extension.</em></p>
<p>What is does rather than what it is, and not all strictly true.</p>
<p>From a programming perspective, a component is:</p>
<ol>
<li>A class.</li>
<li>Implements <code>IComponent</code>.</li>
</ol>
<p>Nothing more.  It comes to life when it's attached to a <code>RenderTree</code>, the component tree used by a <code>Renderer</code> to build and update.  The <code>IComponent</code> interface proves the <code>Renderer</code>s  interface to communicate with and receive communication from a component.
This code compiles and works, but if you add <code>Minimal</code> to a page you won't see anything because it doesn't do anything!</p>
<pre><code class="language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Minimal</span> : <span class="hljs-title">IComponent</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attach</span>(<span class="hljs-params">RenderHandle handle</span>)</span>
    { }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>
        =&gt;  Task.CompletedTask;
}
</code></pre>
<p>To get some output we need to add a one line of code:</p>
<pre><code class="language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Minimal</span> : <span class="hljs-title">IComponent</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attach</span>(<span class="hljs-params">RenderHandle handle</span>)</span>
        =&gt;  handle.Render( (builder) =&gt; builder.AddMarkupContent(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&lt;h1&gt;Hello from Minimal&lt;/h1&gt;&quot;</span>) );

    <span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>
        =&gt; Task.CompletedTask;
}
</code></pre>
<p>Before we dive further into components we need to look at the <code>Renderer</code> and <code>RenderTree</code>, and the application setting.</p>
<h2 id="the-renderer-and-the-render-tree">The Renderer and the Render Tree</h2>
<p>A detailed description of how the <code>Renderer</code> and <code>RenderTree</code> works is beyond the scope of this article, but you need a basic grasp of the concepts to understand the rendering process.</p>
<p>To quote the MS Documentation:</p>
<blockquote>
<p>The <code>Renderer</code> provides mechanisms:</p>
<ol>
<li>For rendering hierarchies of <code>IComponent</code> instances;</li>
<li>Dispatching events to them;</li>
<li>Notifying when the user interface is being updated.</li>
</ol>
</blockquote>
<p>The <code>Renderer</code> and <code>RenderTree</code> reside in the Client Application in WASM and in the SignalR Hub Session in Server, i.e. one per connected Client Application.</p>
<p>The UI - defined by html code in the DOM [Document Object Model] - is represented in the application as a <code>RenderTree</code> and managed by a <code>Renderer</code>. Think of the <code>RenderTree</code> as a tree with one or more components attached to each branch. Each component is a C# class that implements the <code>IComponent</code> interface.  The <code>Renderer</code> has a <code>RenderQueue</code>, containing <code>RenderFragments</code>, which it runs code to update the UI.  Components submit <code>RenderFragments</code> onto the queue.  The <code>Renderer</code> uses a diffing process to detect changes in the DOM caused by <code>RenderTree</code> updates.  It passes these changes to the client code to implement in the Browser DOM and update the displayed page.</p>
<p>The diagram below is a visual representation of the render tree for the out-of-the-box Blazor template.</p>
<p><img src="https://shauncurtis.github.io/articles/assets/Blazor-Components/Root-Render-Tree.png" alt="Root Render Tree"></p>
<h2 id="the-client-application">The Client Application</h2>
<h3 id="blazor-server">Blazor Server</h3>
<p>Blazor Server defines the <code>&lt;app&gt;</code> component in the initial server/html page.  This looks like this:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;typeof(App)&quot;</span> <span class="hljs-attr">render-mode</span>=<span class="hljs-string">&quot;ServerPrerendered&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">app</span>&gt;</span>
</code></pre>
<p><code>type</code> defines the route component class - in this case <code>App</code> and <code>render-mode</code> defines how the initial server-side render process runs.  You can read about that elsewhere.  The only important bit to understand is that if it pre-renders, the page is rendered twice on the initial load - once by the server to build a static version of the page, and then a second time by the browser client code to build the live version of the page.</p>
<p>The browser client code gets loaded by:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;_framework/blazor.server.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>Once <em>blazor.server.js</em> loads, the client application runs in the browser page and a SignalR connection estabished with the server.  To complete the initial load, the Client Application calls the Blazor Hub Session and requests a complete server render of the <code>App</code> component.  It then applies the resultant DOM changes to the Client Application DOM - this will principly be the event wiring.</p>
<p>The diagram below shows how a render request is passed to the displayed page.</p>
<p><img src="https://shauncurtis.github.io/articles/assets/Blazor-Components/Server-Render.png" alt="Server Rendering"></p>
<h3 id="blazor-web-assembly">Blazor Web Assembly</h3>
<p>In Blazor WebAssembly the browser receives an Html page with a defined <code>div</code> placeholder where the root component should be loaded:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
    ....
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>The Client Application gets loaded by:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;_framework/blazor.webassembly.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>Once the WASM code is loaded, it runs <code>program</code>.</p>
<pre><code class="language-csharp">builder.RootComponents.Add&lt;App&gt;(<span class="hljs-string">&quot;#app&quot;</span>);
</code></pre>
<p>The code tells the Renderer that the <code>App</code> class component is the root component for the <code>RenderTree</code> and to load it's DOM into the <code>app</code> element in the browser DOM.</p>
<p><img src="https://shauncurtis.github.io/articles/assets/Blazor-Components/Web-Assembly-Render.png" alt="Server Rendering"></p>
<p>The key point to take from this is that although the process by which the root component is defined and loaded is different, there's no difference between in a WebAssembly and Server root component or any sub-component.  You can use the same component.</p>
<h4 id="apprazor">App.razor</h4>
<p><em>App.razor</em> is the &quot;standard&quot; root component.  It can be any <code>IComponent</code> defined class.</p>
<p><code>App</code> looks like this:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span> <span class="hljs-attr">AppAssembly</span>=<span class="hljs-string">&quot;@typeof(Program).Assembly&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Found</span> <span class="hljs-attr">Context</span>=<span class="hljs-string">&quot;routeData&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">RouteView</span> <span class="hljs-attr">RouteData</span>=<span class="hljs-string">&quot;@routeData&quot;</span> <span class="hljs-attr">DefaultLayout</span>=<span class="hljs-string">&quot;@typeof(MainLayout)&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Found</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">NotFound</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">LayoutView</span> <span class="hljs-attr">Layout</span>=<span class="hljs-string">&quot;@typeof(MainLayout)&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Sorry, there&#x27;s nothing at this address.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">LayoutView</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">NotFound</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span>
</code></pre>
<p>It's a Razor component defining one child component, <code>Router</code>.  <code>Router</code> has two <code>RenderFragments</code>, <code>Found</code> and <code>NotFound</code>.  If <code>Router</code> finds a route, and therefore an <code>IComponent</code> class, it renders the <code>RouteView</code> component and passes it the route class type along with the default <code>Layout</code> class.   If no route is found it renders a <code>LayoutView</code> and renders the defined content in it's <code>Body</code>.</p>
<p><code>RouteView</code> checks if the <code>RouteData</code> component has a specific layout class defined.  If so it uses it, otherwise it uses the default layout.  It renders the layout and passes it the type of the component to add to the <code>Body</code> RenderFragment.</p>
<h2 id="razor-components">Razor Components</h2>
<p>Most components are defined in Razor.  But what's the relationship between a Razor component and <code>IComponent</code>?</p>
<p>There isn't one.  The only requirement for a Razor component is that the defined inherited class must implement:</p>
<pre><code class="language-csharp"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildRenderTree</span>(<span class="hljs-params">RenderTreeBuilder builder</span>)</span>;
</code></pre>
<p>The Razor compiler overrides <code>BuildRenderTree</code> with a method containing the <code>RenderTreeBuilder</code> code that represents the component's UI.</p>
<p>If no inheritance is defined, it sets the compiled class to inherit from <code>ComponentBase</code>.</p>
<p>Here's a simple abstract class which defines <code>BuilRenderTree</code>:</p>
<pre><code class="language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RazorClass</span>
{
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildRenderTree</span>(<span class="hljs-params">RenderTreeBuilder builder</span>)</span>;

    <span class="hljs-keyword">public</span> RenderFragment Content =&gt; (builder) =&gt; BuildRenderTree(builder);
}
</code></pre>
<p>A Razor Implementation:</p>
<pre><code class="language-csharp"><span class="hljs-comment">// Div.razor</span>
@inherits RazorClass

&lt;h3&gt;My Razor Class Div&lt;/h3&gt;
</code></pre>
<p>And it's usage in a page:</p>
<pre><code class="language-csharp">@(<span class="hljs-keyword">new</span> Div().Content)
</code></pre>
<h2 id="the-component-lifecycle">The Component Lifecycle</h2>
<p>The component liefcycle is managed by the Renderer.  You have no control over the actual lifecycle.  You can't instanciate a component and pass it to the renderer.</p>
<ol>
<li>
<p>The component is instanciated and the <code>new()</code> is run.  The ctor method is often overlooked.  At this point the parameters are in their default state and there's no <code>RenderHandle</code>.</p>
</li>
<li>
<p>The Renderer calls <code>Attach</code> and passes in a <code>RenderHandle</code>.  This is the component's communications medium with the Renderer.  Save it to an internal field.</p>
</li>
<li>
<p>The Renderer calls <code>SetParametersAsync</code> and passes in a <code>ParameterView</code> object.  This is the object the Renderer uses to manage the component's parameters.  This should be used in <code>SetParametersAsync</code> and then released.  Don't save it to an internal field.</p>
</li>
<li>
<p>The Renderer calls <code>SetParametersAsync</code> whenever it detects that the components parameters &quot;may have changed&quot;.</p>
</li>
<li>
<p>If the component implements <code>IDisposable</code> or <code>IAsyncDisposable</code>, it calls it and then de-references the component.  The GC will then destroy the redundant object.</p>
</li>
</ol>
<h2 id="interfaces">Interfaces</h2>
<p>A component must implement <code>IComponent</code> which is defined as:</p>
<pre><code class="language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IComponent</span>
{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Attach</span>(<span class="hljs-params">RenderHandle renderHandle</span>)</span>;
    <span class="hljs-function">Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>;
}
</code></pre>
<p>It can also implement <code>IHandleEvent</code></p>
<pre><code class="language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IHandleEvent</span>
{
    <span class="hljs-function">Task <span class="hljs-title">HandleEventAsync</span>(<span class="hljs-params">EventCallbackWorkItem item, <span class="hljs-built_in">object</span>? arg</span>)</span>;
}
</code></pre>
<p>Which allows you to define a custom event handler for handling all UI events.</p>
<p>And <code>IHandleAfterRender</code></p>
<pre><code class="language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IHandleAfterRender</span>
{
    <span class="hljs-function">Task <span class="hljs-title">OnAfterRenderAsync</span>()</span>;
}
</code></pre>
<p>Which is called after the component is rendered.</p>
<h3 id="the-rendlehandle">The RendleHandle</h3>
<p>To quote Microsoft:</p>
<blockquote>
<p>A RenderHandle structure allows a component to interact with its renderer.</p>
</blockquote>
<p>It has two important features:</p>
<ol>
<li>A <code>Render</code> method.</li>
<li>A property referencing the Dispatcher for the <code>SynchronisationContext</code> - i.e. the Dispatcher for the thread on which all UI based code must be run.</li>
</ol>
<h3 id="the-renderfragment">The RenderFragment</h3>
<p>A render fragment isn't a block of UI code.  You can't do this:</p>
<pre><code class="language-csharp">RenderFragment someUi = <span class="hljs-string">&quot;&lt;div&gt;Hello Blazor&lt;/div&gt;&quot;</span>;
</code></pre>
<p>To quote the official Microsoft documentation.</p>
<p><em>A RenderFragement represents a segment of UI content, implemented as a delegate that writes the content to a RenderTreeBuilder.</em></p>
<p>The <code>RenderTreeBuilder</code> is even more succinct:</p>
<p><em>Provides methods for building a collection of RenderTreeFrame entries.</em></p>
<p>A <code>RenderFragment</code> is a delegate defined as follows:</p>
<pre><code class="language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RenderFragment</span>(<span class="hljs-params">RenderTreeBuilder builder</span>)</span>;
</code></pre>
<p>If you're new to delegates think of them as a pattern definition.  Any function that conforms to the pattern defined by the <code>RenderFragment</code> delegate can passed as a <code>RenderFragment</code>.</p>
<p>The pattern dictates your method must:</p>
<ol>
<li>Have one, and only one, parameter of type <code>RenderTreeBuilder</code>.</li>
<li>Return a <code>void</code>.</li>
</ol>
<h3 id="the-helloworld-component">The HelloWorld Component</h3>
<p>To demonstrate the <code>IComponent</code> interface We'll build a simple base component and then a  <code>HelloWorld</code> component that inherits from it.</p>
<p>The MinimalBase component:</p>
<ol>
<li>It's abstract - it doesn't output anything so don't allow it to be used directly as a component.</li>
<li>Captures the RenderHandle</li>
<li>Sets the parameters and requests a render - See the inline comments for detail,</li>
</ol>
<pre><code class="language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Minimal1Base</span> : <span class="hljs-title">IComponent</span>
{
    <span class="hljs-keyword">protected</span> RenderHandle? renderHandle;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attach</span>(<span class="hljs-params">RenderHandle handle</span>)</span>
        =&gt; renderHandle = handle;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>
    {
        <span class="hljs-comment">// Sets the component parameters to the latest values</span>
        parameters.SetParameterProperties(<span class="hljs-keyword">this</span>);
        <span class="hljs-comment">// Creates a render fragment as an anonymous function that calls BuildRenderTree</span>
        RenderFragment fragment = (builder) =&gt; BuildRenderTree(builder);
        <span class="hljs-comment">// passes the fragment to the RenderTree to render</span>
        <span class="hljs-keyword">this</span>.renderHandle?.Render(fragment);
        <span class="hljs-keyword">return</span> Task.CompletedTask;
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildRenderTree</span>(<span class="hljs-params">RenderTreeBuilder builder</span>)</span>;
}
</code></pre>
<p>Our simplest Hello World Razor component looks like this:</p>
<pre><code class="language-html">@inherits RazorClass
<span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Hello Blazor<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
</code></pre>
<h3 id="building-render-fragments">Building Render Fragments</h3>
<p>There are two ways to build render fragments.</p>
<p>Firstly we can use the RenderTreeBuilder.  This is how the Razor compiler builds a class from a Razor component file.</p>
<pre><code class="language-csharp">@inherits RazorClass

@HelloWorld

@code {
    <span class="hljs-keyword">protected</span> RenderFragment HelloWorld =&gt; (RenderTreeBuilder builder) =&gt;
    {
        builder.OpenElement(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;div&quot;</span>);
        builder.AddContent(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello Razor 2&quot;</span>);
        builder.CloseElement();
    };
}
</code></pre>
<p>We're defining a <code>RenderFragment</code> property and assigning an anonymous method to it that conforms to the <code>RenderFragment</code> pattern.  It takes a  <code>RenderTreeBuilder</code> and has no return so returns a void.  It uses the provided <code>RenderTreeBuilder</code> object to build the content: a simple hello world html div.  Each call to the builder adds what is called a <code>RenderTreeFrame</code>.  Note each frame is sequentially numbered.</p>
<p>Or like this:</p>
<pre><code class="language-csharp">@inherits MinimalBase

@HelloWorld

@code {
    <span class="hljs-keyword">protected</span> RenderFragment HelloWorld =&gt; (RenderTreeBuilder builder) =&gt;
    {
        &lt;div&gt;Hello Blazor <span class="hljs-number">3</span>&lt;/div&gt;
    };
}
</code></pre>
<p>Here we're mixing C# code and markup.  The Razor compiler recognises this and compiles the code correctly.</p>
<p>It's important to understand two points:</p>
<ol>
<li>The component itself never &quot;runs&quot; the <code>RenderFragement</code>.  It is passed to the Renderer which Invokes it.</li>
<li>Even though the <code>Renderer</code> invokes the code, the code is run in the context of the component, and the state of the component when executing happens.</li>
</ol>
<p>We can take the concept above and just define a class.</p>
<pre><code class="language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DivClass</span> : <span class="hljs-title">MinimalBase</span>
{
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildRenderTree</span>(<span class="hljs-params">RenderTreeBuilder builder</span>)</span>
    {
        builder.OpenElement(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;div&quot;</span>);
        builder.AddContent(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello Razor 2&quot;</span>);
        builder.CloseElement();
    }
}
</code></pre>
<h3 id="routed-components">Routed Components</h3>
<p>Everything's a component, but not all components are equal.  <strong>Routed Components</strong> are a little special.</p>
<p>They contain <em>@page</em> routing directives and optionally a <em>@Layout</em> directive.</p>
<pre><code class="language-html">@page &quot;/WeatherForecast&quot;
@page &quot;/WeatherForecasts&quot;
@layout MainLayout
</code></pre>
<p>You can define these directly on classes like this:</p>
<pre><code class="language-csharp">[<span class="hljs-meta">LayoutAttribute(typeof(MainLayout))</span>]
[<span class="hljs-meta">RouteAttribute(<span class="hljs-string">&quot;/helloworld&quot;</span>)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RendererComponent</span> : <span class="hljs-title">IComponent</span> {}
</code></pre>
<p>The <code>RouteAttribute</code> is used by the router to find Routes in the application.</p>
<p>Don't think of routed components as pages. It may seem obvious to do so, but don't.  Lots of web page properties don't apply to routed components.  You will:</p>
<ul>
<li>get confused when routed components don't behave like a page.</li>
<li>try and code the component logic as if it is a web page.</li>
</ul>
<h2 id="improving-minimalbase">Improving <code>MinimalBase</code></h2>
<p>There are some performance improvements we can make to <code>MinimalBase</code>.</p>
<p>First is adding in a <code>Hidden</code> feature.  Many UI components implement some form of hide/show functionality.  We'll see why shortly.</p>
<p>This code isn't a very efficient way of implementing the component render fragment:</p>
<pre><code class="language-csharp">RenderFragment fragment = (builder) =&gt; BuildRenderTree(builder);
</code></pre>
<p>The runtime has to build the anonymous function every time the component renders.  We can cache this is ctor like this.</p>
<p>We'll come to <code>_renderPending</code> in a minute.  You can see how <code>Hidden</code> is implemented.</p>
<pre><code class="language-csharp"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> _renderpending;
<span class="hljs-keyword">private</span> RenderFragment _componentFragment;

[<span class="hljs-meta">Parameter</span>] <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> Hidden { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinimalBase</span>()</span>
{
    _componentFragment = (builder) =&gt;
    {
        _renderpending = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (!Hidden)
            BuildRenderTree(builder);
    };
}
</code></pre>
<p>We can also improve the render code.  The existing code places the render fragment in the queue regardless of whether there's already one queued.</p>
<pre><code class="language-csharp"><span class="hljs-keyword">this</span>.renderHandle.Render(fragment);
</code></pre>
<p>The new method uses a private <code>bool</code> <code>_renderPending</code> to track render state.  If the component render fragment is already queued, it doesn't add another one, the one already in the queue will render the component with the current changes.  <code>_renderPending</code></p>
<pre><code class="language-csharp"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RequestRender</span>()</span>
{
    <span class="hljs-keyword">if</span> (!_renderPending)
    {
        _renderPending = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">this</span>.renderHandle.Render(_componentFragment);
    }
}
</code></pre>
<p>The final base component is:</p>
<pre><code class="language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MinimalBase</span> : <span class="hljs-title">IComponent</span>
{
    <span class="hljs-keyword">protected</span> RenderHandle renderHandle;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> _renderPending;
    <span class="hljs-keyword">private</span> RenderFragment _componentFragment;

    [<span class="hljs-meta">Parameter</span>] <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> Hidden { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinimalBase</span>()</span>
    {
        _componentFragment = (builder) =&gt;
        {
            _renderPending = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (!Hidden)
                BuildRenderTree(builder);
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attach</span>(<span class="hljs-params">RenderHandle handle</span>)</span>
        =&gt; renderHandle = handle;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>
    {
        parameters.SetParameterProperties(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">this</span>.RequestRender();
        <span class="hljs-keyword">return</span> Task.CompletedTask;
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildRenderTree</span>(<span class="hljs-params">RenderTreeBuilder builder</span>)</span>;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RequestRender</span>()</span>
    {
        <span class="hljs-keyword">if</span> (!_renderPending)
        {
            _renderPending = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">this</span>.renderHandle.Render(_componentFragment);
        }
    }
}
</code></pre>
<h3 id="rendering">Rendering</h3>
<h2 id="componentbase">ComponentBase</h2>
<p><code>ComponentBase</code> is the &quot;standard&quot; out-of-the-box Blazor implementation of <code>IComponent</code>.  All <em>.razor</em> files by default inherit from it.  While you may never step outside <code>ComponentBase</code> it's important to understand that it's just one implementation of the <code>IComponent</code> interface.  It doesn't define a component.  <code>OnInitialized</code> is not a component lifecycle method, it's a <code>ComponentBase</code> lifecycle method.</p>
<h3 id="componentbase-lifecycle-and-events">ComponentBase Lifecycle and Events</h3>
<p>There are articles galore regurgitating the same old basic lifecycle information.  I'm not going to repeat it.  Instead I'm going to concentrate on certain often misunderstood aspects of the lifecycle: there's more to the lifecycle that just the initial component load covered in most of the articles.</p>
<p>We need to consider five types of event:</p>
<ol>
<li>Instantiation of the class</li>
<li>Initialization of the component</li>
<li>Component parameter changes</li>
<li>Component events</li>
<li>Component disposal</li>
</ol>
<p>There are seven exposed Events/Methods and their async equivalents:</p>
<ol>
<li><code>SetParametersAsync</code></li>
<li><code>OnInitialized</code> and <code>OnInitializedAsync</code></li>
<li><code>OnParametersSet</code> and <code>OnParametersSetAsync</code></li>
<li><code>OnAfterRender</code> and <code>OnAfterRenderAsync</code></li>
<li><code>Dispose</code> - if <code>IDisposable</code> is implemented</li>
<li><code>StateHasChanged</code></li>
<li><code>new</code> - often forgotten.</li>
</ol>
<p>The standard class instantiation method builds the <code>RenderFragment</code> that <code>StateHasChanged</code> passes to the  <code>Renderer</code> to render the component.  It sets two private class variables to false and runs <code>BuildRenderTree</code>.</p>
<pre><code class="language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ComponentBase</span>()</span>
{
    _renderFragment = builder =&gt;
    {
        _hasPendingQueuedRender = <span class="hljs-literal">false</span>;
        _hasNeverRendered = <span class="hljs-literal">false</span>;
        BuildRenderTree(builder);
    };
}
</code></pre>
<p><code>SetParametersAsync</code> sets the properties for the submitted parameters. It only runs <code>RunInitAndSetParametersAsync</code> - and thus <code>OnInitialized</code> followed by <code>OnInitializedAsync</code> - on initialization. It always calls <code>CallOnParametersSetAsync</code>.  Note:</p>
<ol>
<li><code>CallOnParametersSetAsync</code> waits on <code>OnInitializedAsync</code> to complete before calling <code>CallOnParametersSetAsync</code>.</li>
<li><code>RunInitAndSetParametersAsync</code> calls <code>StateHasChanged</code> if <code>OnInitializedAsync</code> task yields before completion.</li>
</ol>
<pre><code class="language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>
{
    parameters.SetParameterProperties(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">if</span> (!_initialized)
    {
        _initialized = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> RunInitAndSetParametersAsync();
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> CallOnParametersSetAsync();
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">RunInitAndSetParametersAsync</span>()</span>
{
    OnInitialized();
    <span class="hljs-keyword">var</span> task = OnInitializedAsync();
    <span class="hljs-keyword">if</span> (task.Status != TaskStatus.RanToCompletion &amp;&amp; task.Status != TaskStatus.Canceled)
    {
        StateHasChanged();
        <span class="hljs-keyword">try</span> { <span class="hljs-keyword">await</span> task;}
        <span class="hljs-keyword">catch</span> { <span class="hljs-keyword">if</span> (!task.IsCanceled) <span class="hljs-keyword">throw</span>; }
    }
    <span class="hljs-keyword">await</span> CallOnParametersSetAsync();

</code></pre>
<p><code>CallOnParametersSetAsync</code> calls <code>OnParametersSet</code> followed by <code>OnParametersSetAsync</code>, and finally <code>StateHasChanged</code>.  If the <code>OnParametersSetAsync()</code> task yields <code>CallStateHasChangedOnAsyncCompletion</code> awaits the task and re-runs <code>StateHasChanged</code>.</p>
<pre><code class="language-csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> Task <span class="hljs-title">CallOnParametersSetAsync</span>()</span>
{
    OnParametersSet();
    <span class="hljs-keyword">var</span> task = OnParametersSetAsync();
    <span class="hljs-keyword">var</span> shouldAwaitTask = task.Status != TaskStatus.RanToCompletion &amp;&amp;
        task.Status != TaskStatus.Canceled;

    StateHasChanged();

    <span class="hljs-keyword">return</span> shouldAwaitTask ?
        CallStateHasChangedOnAsyncCompletion(task) :
        Task.CompletedTask;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">CallStateHasChangedOnAsyncCompletion</span>(<span class="hljs-params">Task task</span>)</span>
{
    <span class="hljs-keyword">try</span> { <span class="hljs-keyword">await</span> task; }
    <span class="hljs-keyword">catch</span> 
    {
        <span class="hljs-keyword">if</span> (task.IsCanceled) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">throw</span>;
    }
    StateHasChanged();
}
</code></pre>
<p>Lets look at <code>StateHasChanged</code>.  If a render is pending i.e. the renderer hasn't got round to running the queued render request, it closes - whatever changes have been made will be captured in the queued render.  If not, it sets the  <code>_hasPendingQueuedRender</code> class flag and calls the Render method on the <code>RenderHandle</code>.  This queues <code>_renderFragement</code> onto the <code>Renderer</code> <code>RenderQueue</code>.  When the queue runs <code>_renderFragment</code> - see above - it sets the two class flags to false and runs <code>BuildRenderTree</code>.</p>
<pre><code class="language-csharp"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StateHasChanged</span>()</span>
{
    <span class="hljs-keyword">if</span> (_hasPendingQueuedRender) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (_hasNeverRendered || ShouldRender())
    {
        _hasPendingQueuedRender = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">try</span> { _renderHandle.Render(_renderFragment);}
        <span class="hljs-keyword">catch</span> {
            _hasPendingQueuedRender = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">throw</span>;
        }
    }
}
</code></pre>
<p><code>StateHasChanged</code> must be run on the UI thread.  When called internally that will always be the case.  However, when wiring up external event handlers that my not be so.  You need to implement these like this:</p>
<pre><code class="language-csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnExternalEvent</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? sender, EventArgs e</span>)</span>
    =&gt; <span class="hljs-keyword">this</span>.InvokeAsync(StateHasChanged);
</code></pre>
<p><code>InvokeAsync</code> is a <code>ComponentBase</code> method that invokes the supplied action on the <code>Dispatcher</code> provided by the <code>RenderHandle</code>.</p>
<h3 id="and-then-what-no-one-covers">And then what no one covers.</h3>
<p>Components receive UI events from the Renderer.  What happens is dictated by two interfaces that components can implement:</p>
<ul>
<li>
<p><code>IHandleEvent</code> defines a single method - <code>Task HandleEventAsync(EventCallbackWorkItem callback, object? arg)</code> When implemented, the Renderer passes all events to the handler.  When not, it calls the method directly.</p>
</li>
<li>
<p><code>IHandleAfterRender</code> defines a single method - <code>OnAfterRenderAsync()</code> which handles the after render process.  If nothing is defined then there is no process.</p>
</li>
</ul>
<p><code>ComponentBase</code> implements both both interfaces.  We'll look at them in more detail shortly.</p>
<p>Some key points to note:</p>
<ol>
<li>
<p><code>OnInitialized</code> and <code>OnInitializedAsync</code> only get called during initialization.  <code>OnInitialized</code> is run first.  If, and only if, <code>OnInitializedAsync</code> yields back to the internal calling method <code>RunInitAndSetParametersAsync</code>, then <code>StateHasChanged</code> get called, providing the opportunity to provide &quot;Loading&quot; information to the user.  <code>OnInitializedAsync</code> completes before <code>OnParametersSet</code> and <code>OnParametersSetAsync</code> are called.</p>
</li>
<li>
<p><code>OnParametersSet</code> and <code>OnParametersSetAsync</code> get called whenever the parent component makes changes to the parameter set for the component or a captured cascaded parameter changes.  Any code that needs to respond to parameter changes need to live here. <code>OnParametersSet</code> is run first.  Note that if <code>OnParametersSetAsync</code> yields, <code>StateHasChanged</code> is run after the yield, providing the opportunity to provide &quot;Loading&quot; information to the user.</p>
</li>
<li>
<p><code>StateHasChanged</code> is called after the <code>OnParametersSet{async}</code> methods complete to render the component.</p>
</li>
<li>
<p><code>OnAfterRender</code> and <code>OnAfterRenderAsync</code> occur at the end of all four events.  <code>firstRender</code> is only true on component initialization.  Note that any changes made here to parameters won't get applied to display values until the component re-renders.</p>
</li>
<li>
<p><code>StateHasChanged</code> is called during the initialization process if the conditions stated above are met, after the <code>OnParametersSet</code> processes, and any event callback.  Don't call it explicitly during the render or parameter set process unless you need to.  If you do call it you are probably doing something wrong.</p>
</li>
</ol>
<h2 id="the-render-process">The Render Process</h2>
<p>Let's look in detail at how a simple page and component get rendered.</p>
<h4 id="simplecomponentrazor">SimpleComponent.razor</h4>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;h4 bg-success text-white p-2&quot;</span>&gt;</span>Loaded<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 id="simplepagerazor">SimplePage.razor</h4>
<pre><code class="language-csharp">@page <span class="hljs-string">&quot;/simple&quot;</span>
&lt;h3&gt;SimplePage&lt;/h3&gt;
@if (loaded)
{
    &lt;SimpleComponent&gt;&lt;/SimpleComponent&gt;
}
<span class="hljs-keyword">else</span>
{
    &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;h4 bg-danger text-white p-2&quot;</span>&gt;Loading.....&lt;/div&gt;
}

@code {
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> loaded;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">OnInitializedAsync</span>()</span>
    {
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);
        loaded = <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p>The follow diagram shows a simplified <code>RenderTree</code> representing a simple &quot;/&quot; route.</p>
<p><img src="https://shauncurtis.github.io/articles/assets/Blazor-Components/Root-Render-Tree.png" alt="Root Render Tree"></p>
<p>Note the three nodes in <code>NavMenu</code> for the three <code>NavLink</code> controls.</p>
<p>On our page, the render tree looks like the diagram below on first render - we have a yielding <code>OnInitializedAsync</code> method, so <code>StateHasChanged</code> gets run in the initialization process.</p>
<p><img src="https://shauncurtis.github.io/articles/assets/Blazor-Components/Simple-Page-Loading.png" alt="Simple Page Loading"></p>
<p>Once initialization completes, <code>StateHasChanged</code> is run a second time.  <code>Loaded</code> is now <code>true</code> and <code>SimpleComponent</code> is added to the component <code>RenderFragment</code>.  When the <code>Renderer</code> runs the <code>RenderFragment</code>, <code>SimpleComponent</code> is added to the render tree, instantiated and initialized.</p>
<p><img src="https://shauncurtis.github.io/articles/assets/Blazor-Components/Simple-Page-Loaded.png" alt="Simple Page Loaded"></p>
<h3 id="component-content">Component Content</h3>
<p>Change <code>SimpleComponent</code> and <code>SimplePage</code> to:</p>
<h4 id="simplecomponentrazor">SimpleComponent.razor</h4>
<pre><code class="language-csharp">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;h4 bg-success text-white p-2&quot;</span>&gt;@ChildContent&lt;/div&gt;

@code {
    [<span class="hljs-meta">Parameter</span>] <span class="hljs-keyword">public</span> RenderFragment ChildContent { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h4 id="simplepagerazor">SimplePage.razor</h4>
<pre><code class="language-csharp">@page <span class="hljs-string">&quot;/simple&quot;</span>
&lt;h3&gt;SimplePage&lt;/h3&gt;
@if (loaded)
{
    &lt;SimpleComponent&gt;
        &lt;button <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> @onclick=<span class="hljs-string">&quot;ButtonClick&quot;</span>&gt;Click Me&lt;/button&gt;
    &lt;/SimpleComponent&gt;
}
<span class="hljs-keyword">else</span>
{
    &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;h4 bg-danger text-white p-2&quot;</span>&gt;Loading.....&lt;/div&gt;
}

@code {
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> loaded;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">OnInitializedAsync</span>()</span>
    {
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);
        loaded = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ButtonClick</span>(<span class="hljs-params">MouseEventArgs e</span>)</span>
    {
        <span class="hljs-keyword">var</span> x = <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p>There is now content in <code>SimpleComponent</code>. When the application is run that content gets executed in the context of the parent component.  How?</p>
<p>The answer is in <code>SimpleComponent</code>.   Remove the <code>[Parameter]</code> attribute from <code>SimpleComponent</code> and run the page.  It errors:</p>
<pre><code class="language-Text">InvalidOperationException: Object of type &#x27;xxx.SimpleComponent&#x27; has a property matching the name &#x27;ChildContent&#x27;, but it does not have [ParameterAttribute] or [CascadingParameterAttribute] applied.
</code></pre>
<p>If a component has &quot;content&quot; i.e. markup between the opening and closing tags, Blazor expects to find a <code>Parameter</code> named <code>ChildContent</code> in the component.  The content between the tags is pre-compiled into a <code>RenderFragment</code> and then added to the component.  The content of the <code>RenderFragment</code> is run in the context of the object that owns it - <code>SimplePage</code>.</p>
<p>The content can also be defined like this:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">SimpleComponent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ChildContent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> @<span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;ButtonClick&quot;</span>&gt;</span>
            Click Me
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ChildContent</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">SimpleComponent</span>&gt;</span>
</code></pre>
<p>The page can also be re-written as below, where it now becomes more obvious who owns the <code>RenderFragment</code>.</p>
<pre><code class="language-csharp">@page <span class="hljs-string">&quot;/simple&quot;</span>
&lt;h3&gt;SimplePage&lt;/h3&gt;
@if (loaded)
{
    &lt;SimpleComponent&gt;
        @_childContent
    &lt;/SimpleComponent&gt;
}
<span class="hljs-keyword">else</span>
{
    &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;h4 bg-danger text-white p-2&quot;</span>&gt;Loading.....&lt;/div&gt;
}

@code {

    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> loaded;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">OnInitializedAsync</span>()</span>
    {
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);
        loaded = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ButtonClick</span>(<span class="hljs-params">MouseEventArgs e</span>)</span>
    {
        <span class="hljs-keyword">var</span> x = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">private</span> RenderFragment _childContent =&gt; (builder) =&gt;
    {
        builder.OpenElement(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;button&quot;</span>);
        builder.AddAttribute(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;class&quot;</span>, <span class="hljs-string">&quot;btn btn-primary&quot;</span>);
        builder.AddAttribute(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;onclick&quot;</span>, EventCallback.Factory.Create&lt;MouseEventArgs&gt;(<span class="hljs-keyword">this</span>, ButtonClick));
        builder.AddContent(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Click Me&quot;</span>);
        builder.CloseElement();
    };
}
</code></pre>
<p>A component is not limited to a single <code>RenderFragment</code>.  A table component could look like this:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">TableComponent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Header</span>&gt;</span>
        ...
    <span class="hljs-tag">&lt;/<span class="hljs-name">Header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Rows</span>&gt;</span>
        ...
    <span class="hljs-tag">&lt;/<span class="hljs-name">Rows</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Footer</span>&gt;</span>
        ...
    <span class="hljs-tag">&lt;/<span class="hljs-name">Footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">TableComponent</span>&gt;</span>
</code></pre>
<h2 id="component-events">Component Events</h2>
<p>Hidden away are two important interfaces that dictate how components react to UI events.</p>
<ul>
<li><code>IHandleEvent</code></li>
<li><code>IHandleAfterRender</code></li>
</ul>
<h4 id="ihandleevent">IHandleEvent</h4>
<p>When the Renderer receives a UI event it checks the compoment to see if it implements <code>IHandleEvent</code>.  If so then it passes the call to the handler.</p>
<p><code>IHandleEvent</code> defines the following single method.</p>
<pre><code class="language-csharp">Task IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, <span class="hljs-built_in">object</span>? arg);
</code></pre>
<p><code>ComponentBase</code> implements the interface, with the two step call to <code>StateHasChanged</code>.</p>
<pre><code class="language-csharp">Task IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, <span class="hljs-built_in">object</span>? arg)
{
    <span class="hljs-keyword">var</span> task = callback.InvokeAsync(arg);
    <span class="hljs-keyword">var</span> shouldAwaitTask = task.Status != TaskStatus.RanToCompletion &amp;&amp;
        task.Status != TaskStatus.Canceled;

    <span class="hljs-comment">// After each event, we synchronously re-render (unless !ShouldRender())</span>
    <span class="hljs-comment">// This just saves the developer the trouble of putting &quot;StateHasChanged();&quot;</span>
    <span class="hljs-comment">// at the end of every event callback.</span>
    StateHasChanged();

    <span class="hljs-keyword">return</span> shouldAwaitTask ?
        CallStateHasChangedOnAsyncCompletion(task) :
        Task.CompletedTask;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">CallStateHasChangedOnAsyncCompletion</span>(<span class="hljs-params">Task task</span>)</span>
{
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-keyword">await</span> task;
    }
    <span class="hljs-keyword">catch</span> <span class="hljs-comment">// avoiding exception filters for AOT runtime support</span>
    {
        <span class="hljs-comment">// Ignore exceptions from task cancellations, but don&#x27;t bother issuing a state change.</span>
        <span class="hljs-keyword">if</span> (task.IsCanceled)
            <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">throw</span>;
    }
    StateHasChanged();
}
</code></pre>
<p>If <code>IHandleEvent</code> is not implemented it simply calls the handler directly.</p>
<pre><code class="language-csharp">Task <span class="hljs-keyword">async</span> IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, <span class="hljs-built_in">object</span>? arg)
   =&gt; <span class="hljs-keyword">await</span> callback.InvokeAsync(arg);
</code></pre>
<h4 id="ihandleafterrender">IHandleAfterRender</h4>
<p>When the component completes rendering the Renderer checks the compoment to see if it implements <code>IHandleAfterRender</code>.  If so then it passes the call to the handler.</p>
<p><code>ComponentBase</code> implements the interface.</p>
<pre><code class="language-csharp">Task IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, <span class="hljs-built_in">object</span>? arg)
{
    <span class="hljs-keyword">var</span> task = callback.InvokeAsync(arg);
    <span class="hljs-keyword">var</span> shouldAwaitTask = task.Status != TaskStatus.RanToCompletion &amp;&amp;
        task.Status != TaskStatus.Canceled;

    <span class="hljs-comment">// After each event, we synchronously re-render (unless !ShouldRender())</span>
    <span class="hljs-comment">// This just saves the developer the trouble of putting &quot;StateHasChanged();&quot;</span>
    <span class="hljs-comment">// at the end of every event callback.</span>
    StateHasChanged();

    <span class="hljs-keyword">return</span> shouldAwaitTask ?
        CallStateHasChangedOnAsyncCompletion(task) :
        Task.CompletedTask;
}
</code></pre>
<p>If <code>IHandleAfterRender</code> is not implemented then nothing happens.</p>
<pre><code class="language-csharp">Task IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, <span class="hljs-built_in">object</span>? arg)
   =&gt; <span class="hljs-keyword">return</span> Task.CompletedTask;
</code></pre>
<h4 id="void-ui-events">Void UI Events</h4>
<p>The following code won't execute as expected in <code>ComponentBase</code>:</p>
<pre><code class="language-csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">async</span> <span class="hljs-title">ButtonClick</span>(<span class="hljs-params">MouseEventArgs e</span>)</span> 
{
  <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);
  UpdateADisplayProperty();
}
</code></pre>
<p>The DisplayProperty doesn't display the current value until another <code>StateHasChanged</code> events occurs.  Why? ButtonClick doesn't return anything, so there's no <code>Task</code> for the event handler to wait on.  On the <code>await</code> yield, it runs to completion running the final <code>StateHasChanged</code> before <code>UpdateADisplayProperty</code> completes.</p>
<p>This is a band-aid fix - it's bad pactice, <strong>DON'T DO IT</strong>.</p>
<pre><code class="language-csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">async</span> <span class="hljs-title">ButtonClick</span>(<span class="hljs-params">MouseEventArgs e</span>)</span> 
{
  <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);
  UpdateADisplayProperty();
  StateHasChanged();
}
</code></pre>
<p>The correct solution is:</p>
<pre><code class="language-csharp"><span class="hljs-function">Task <span class="hljs-keyword">async</span> <span class="hljs-title">ButtonClick</span>(<span class="hljs-params">MouseEventArgs e</span>)</span> 
{
  <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);
  UpdateADisplayProperty();
}
</code></pre>
<p>Now the event handler has a <code>Task</code> to await and doesn't execute <code>StateHasChanged</code> until <code>ButtonClick</code> completes.</p>
<h2 id="some-important-less-documented-information-and-lessons-learned">Some Important Less Documented Information and Lessons Learned</h2>
<h3 id="keep-parameter-properties-simple">Keep Parameter Properties Simple</h3>
<p>Your parameter declarations should look like this:</p>
<pre><code class="language-csharp">[<span class="hljs-meta">Parameter</span>] MyClass myClass {<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;}
</code></pre>
<p><strong>DON'T</strong> add code to the getter or setter.  Why?  Any setter must be run as part of the render process and can have a significant impact on render speed and component state.</p>
<h3 id="overriding-setparametersasync">Overriding SetParametersAsync</h3>
<p>If you override <code>SetParametersAsync</code> your method should look like this:</p>
<pre><code class="language-csharp">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>
    {
        <span class="hljs-comment">// always call first</span>
        parameters.SetParameterProperties(<span class="hljs-keyword">this</span>);
        <span class="hljs-comment">// Your Code</span>
        .....
        <span class="hljs-comment">// pass an empty ParameterView, not parameters</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">base</span>.SetParametersAsync(ParameterView.Empty);
    }
</code></pre>
<p>Set the parameters in the first line and call the base method passing <code>ParameterView.Empty</code>.  Don't try to pass <code>parameters</code> - you will get an error.</p>
<h3 id="parameters-as-immutable">Parameters as Immutable</h3>
<p>Never set Parameters in your code.  If you want to make or track changes do this:</p>
<pre><code class="language-csharp">    [<span class="hljs-meta">Parameter</span>] <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyParameter { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _MyParameter;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler MyParameterChanged;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>
    {
        parameters.SetParameterProperties(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">if</span> (!_MyParameter.Equals(MyParameter))
        {
            _MyParameter = MyParameter;
            MyParameterChanged?.Invoke(_MyParameter, EventArgs.Empty);
        }
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">base</span>.SetParametersAsync(ParameterView.Empty);
    }
</code></pre>
<h3 id="iterators">Iterators</h3>
<p>A common problem occurs when a <code>For</code> iterator is used to loop through a collection to build a <code>select</code> or a data table.  A typical example is shown below:</p>
<pre><code class="language-csharp">@for (<span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>; counter &lt; <span class="hljs-keyword">this</span>.myList.Count; counter++)
{
    &lt;button <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;btn btn-dark m-3&quot;</span> @onclick=<span class="hljs-string">&quot;() =&gt; ButtonClick(this.myList[counter])&quot;</span>&gt;@this.myList[counter]&lt;/button&gt;
}
@for (<span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>; counter &lt; <span class="hljs-keyword">this</span>.myList.Count; counter++)
{
    &lt;button <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;btn btn-dark m-3&quot;</span> @onclick=<span class="hljs-string">&quot;() =&gt; ButtonClick(counter)&quot;</span>&gt;@this.myList[counter]&lt;/button&gt;
}
&lt;div&gt;Value = @this.<span class="hljs-keyword">value</span> &lt;/div&gt;

@code {
    <span class="hljs-keyword">private</span> List&lt;<span class="hljs-built_in">int</span>&gt; myList =&gt; <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> };
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> Task <span class="hljs-title">ButtonClick</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;
        <span class="hljs-keyword">return</span> Task.CompletedTask;
    }
}
</code></pre>
<p>If you click on a button in the first row, you will get a <em>Index was out of range</em> error.  Click on a button in the second row and value is always 10.  The reason is that the interator has completed before you click a button, at which time <code>counter</code> is 10.</p>
<p>To fix the problem, set a local variable within the loop as shown below.</p>
<pre><code class="language-csharp">@for (<span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>; counter &lt; <span class="hljs-keyword">this</span>.myList.Count; counter++)
{
    <span class="hljs-keyword">var</span> item = <span class="hljs-keyword">this</span>.myList[counter];
    &lt;button <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;btn btn-dark m-3&quot;</span> @onclick=<span class="hljs-string">&quot;() =&gt; ButtonClick(item)&quot;</span>&gt;@item&lt;/button&gt;
}
@for (<span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>; counter &lt; <span class="hljs-keyword">this</span>.myList.Count; counter++)
{
    <span class="hljs-keyword">var</span> item = <span class="hljs-keyword">this</span>.myList[counter];
    <span class="hljs-keyword">var</span> thiscount = counter;
    &lt;button <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;btn btn-info m-3&quot;</span> @onclick=<span class="hljs-string">&quot;() =&gt; ButtonClick(thiscount)&quot;</span>&gt;@item&lt;/button&gt;
}
</code></pre>
<p>The best solution is to use <code>ForEach</code>.</p>
<pre><code class="language-csharp">@foreach  (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.myList)
{
    &lt;button <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;btn btn-primary m-3&quot;</span> @onclick=<span class="hljs-string">&quot;() =&gt; ButtonClick(item)&quot;</span>&gt;@item&lt;/button&gt;
}
</code></pre>
<h3 id="component-numbering">Component Numbering</h3>
<p>It's seems logical to use iterators to automate the numbering of component elements.  DON'T.  The numbering system is used by the diffing engine to decide which bits of the DOM need updating and which bits don't.  Numbering must be consistent within a <code>RenderFragment</code>.  You can use <code>OpenRegion</code> and <code>CloseRegion</code> to define a region with it's own number space.  <a href="https://gist.github.com/SteveSandersonMS/ec232992c2446ab9a0059dd0fbc5d0c3">See this gist for a more detailed explanation</a>.</p>
<h2 id="building-components">Building Components</h2>
<p>Components can be defined in three ways:</p>
<ol>
<li>As a <em>.razor</em> file with an code inside an <em>@code</em> block.</li>
<li>As a <em>.razor</em> file and a code behind <em>.razor.cs</em> file.</li>
<li>As a pure <em>.cs</em> class file inheriting from <em>ComponentBase</em> or a <em>ComponentBase</em> inherited class, or implementing <em>IComponent</em>.</li>
</ol>
<h5 id="all-in-one-razor-file">All in One Razor File</h5>
<p>HelloWorld.razor</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
@HelloWorld
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

@code {
[Parameter]
public string HelloWorld {get; set;} = &quot;Hello?&quot;;
}
</code></pre>
<h5 id="code-behind">Code Behind</h5>
<p>HelloWorld.razor</p>
<pre><code class="language-html">@inherits ComponentBase
@namespace CEC.Blazor.Server.Pages

<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
@HelloWorld
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>HelloWorld.razor.cs</p>
<pre><code class="language-csharp"><span class="hljs-keyword">namespace</span> <span class="hljs-title">CEC.Blazor.Server.Pages</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> : <span class="hljs-title">ComponentBase</span>
    {
        [<span class="hljs-meta">Parameter</span>]
        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> HelloWorld {<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;} = <span class="hljs-string">&quot;Hello?&quot;</span>;
    }
}
</code></pre>
<h5 id="c-class">C# Class</h5>
<p>HelloWorld.cs</p>
<pre><code class="language-csharp"><span class="hljs-keyword">namespace</span> <span class="hljs-title">CEC.Blazor.Server.Pages</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> : <span class="hljs-title">ComponentBase</span>
    {
        [<span class="hljs-meta">Parameter</span>]
        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> HelloWorld {<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;} = <span class="hljs-string">&quot;Hello?&quot;</span>;

        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildRenderTree</span>(<span class="hljs-params">RenderTreeBuilder builder</span>)</span>
        {
            builder.OpenElement(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;div&quot;</span>);
            builder.AddContent(<span class="hljs-number">1</span>, (MarkupString)<span class="hljs-keyword">this</span>._Content);
            builder.CloseElement();
        }
    }
}
</code></pre>
<h2 id="inheritance">Inheritance</h2>
<p>If you are creating abstract components from <code>ComponentBase</code> don't override <code>OnInitialized{Async}</code> and <code>OnParametersSet{Async}</code> in the abstract classes with your custom code.  This presents a timing problem: do you run <code>base.OnInitializedAsync</code> at the start or end of <code>this.OnInitializedAsync</code>.</p>
<p>Lets look an example.  We have a <code>ViewRecordComponent&lt;TRecord&gt;</code> that loads a record as part of the initilization.  The best way to implement this is to override <code>SetParametersAsync</code> and add a <code>LoadRecordAsync</code> method to the core lifecycle sequence.  Here's what the code could look like:</p>
<pre><code class="language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>
{
    parameters.SetParameterProperties(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.LoadRecordAsync();
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">base</span>.SetParametersAsync(ParameterView.Empty);
}

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> Task <span class="hljs-title">LoadRecordAsync</span>()</span>
{
    <span class="hljs-comment">// load code</span>
}
</code></pre>
<p>You've coded exactly when <code>LoadRecordAsync</code> is run.</p>
<h2 id="some-observations">Some Observations</h2>
<ol>
<li>
<p>There's a tendency to pile too much code into <code>OnInitialized</code> and <code>OnInitializedAsync</code> and then use events to drive <code>StateHasChanged</code> updates in the component tree.  Get the relevant code into the right places in the lifecycle and you won't need the events.</p>
</li>
<li>
<p>There's a temptation to start with the non-async versions (because they're easier to implement) and only use the async versions when you have to, when the opposite should be true.  Most web based activities are inherently async in nature.  I never use the non-async versions - I work on the principle that at some point I'm going to need to add async behaviour.</p>
</li>
<li>
<p><code>StateHasChanged</code> is called far to often, normally because code is in the wrong place in the component lifecycle, or the events have been coded incorrectly.  Ask yourself a challenging &quot;Why?&quot; when you type <code>StateHasChanged</code>.</p>
</li>
<li>
<p>Components are underused in the UI.  The same code/markup blocks are used repeatedly.  The same rules apply to code/markup blocks as to C# code.</p>
</li>
<li>
<p>Once you really, REALLY understand components, writing Blazor code becomes a totally &quot;different&quot; experience.</p>
</li>
</ol>

        
        
    

            </div>
        </div>
    </div>
</div>
<!-- end of Article Container -->


                </div>
                <!-- End of Main Content -->
            </div>
            <!-- Footer -->
            
<!-- Copyright -->
<footer class="sticky-footer bg-white">
    <div class="container my-auto">
        <div class="copyright text-center my-auto">
            
<span>Copyright &copy; Cold Elm Coders - 2022</span>

        </div>
    </div>
</footer>
<!-- end of copyright -->


            <!-- End of Footer -->
        </div>
        <!-- End of Content Wrapper -->
        
<a class="scroll-to-top rounded" href="#page-top">
    <i class="fas fa-angle-up"></i>
</a>


    </div>
    <!-- End of Page Wrapper -->
    <!-- Scripts -->
    
<!-- Scripts -->
<!-- Bootstrap core JavaScript-->
<script src="/assets/vendor/jquery/jquery.min.js"></script>
<script src="/assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

<!-- Core plugin JavaScript-->
<script src="/assets/vendor/jquery-easing/jquery.easing.min.js"></script>

<!-- Custom scripts for all pages-->
<script src="/assets/js/sb-admin-2.min.js"></script>


</body>
</html>
