<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<base href="/">

	

	

	
	<link href="/resources/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
	<link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">

	
	<link href="/resources/css/sb-admin-2.css" rel="stylesheet" type="text/css">
	<link href="/resources/css/site.css" rel="stylesheet" type="text/css">

	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
	<link rel="stylesheet" href="/resources/css/article.css" type="text/css">

	
	<link rel="icon" href="/assets/favicon.png">

	<title>Leaner, Meaner, Greener Components</title>
        <meta property="author" content="Shaun Curtis" />
        <meta property="description" content="Building Leaner, Meaner, Greener Blazor Components - AKA Rethinking the Blazor Component." />
    <meta property="og:site_name" content="Cold Elm Coders" />
        <meta property="og:site" content="https://shauncurtis.github.io/" />
        <meta property="og:title" content="Leaner, Meaner, Greener Components" />
        <meta property="og:description" content="Building Leaner, Meaner, Greener Blazor Components - AKA Rethinking the Blazor Component." /></head>
<body><header class="navbar bg-dark p-2 text-large text-light"><section class="navbar-section  text-light"><a href="/" class="navbar-brand mr-2 text-large text-light p-2">Cold Elm Coders</a>
			<a href="/Posts/index.html" class="btn btn-link text-light">Posts</a>
			<a href="/Rants/index.html" class="btn btn-link text-light">Rants</a>
			<a href="/Articles/index.html" class="btn btn-link text-light">Articles</a>
			<a href="/Stories/index.html" class="btn btn-link text-light">Stories</a>
			<a href="/about.html" class="btn btn-link text-light">About</a></section></header>

	<div class="container-fluid"><div class="row"><div class="col-12 col-sm-3 col-lg-2 bg-light pt-2"><div class="article-info p-2"><div class="mb-2">Published: 04-Nov-2022</div>
                <div class="mb-2">Updated: 04-Nov-2022</div>
                <div class="mb-2">Author: Shaun Curtis</div></div>
    <h4 class="p-2">Table of Contents</h4>
<ul class="TOC" >
<li class="TOC-item TOC-item-0" >
<a class="TOC-link" href="#">Top</a>
<ul class="TOC TOC-0" >
<li class="TOC-item TOC-item-1" >
<ul class="TOC TOC-1" >
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#why">Why?</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#so-why-does-everyone-use-componentbase">So why does everyone use ComponentBase?</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#lean-mean-green-strategies">Lean, Mean, Green Strategies</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#our-lean.mean.green-components">Our Lean. Mean. Green Components</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#render-cascades">Render Cascades</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#some-demonstration-implementations">Some Demonstration Implementations</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#conclusions">Conclusions</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#appendix">Appendix</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
			
			<div class="col-12 col-sm-9 col-lg-10 p-2"><div class="pt-2 pb-2 border-bottom mb-4 text-primary"><h1>Leaner, Meaner, Greener Components</h1>
            <div><small>Building Leaner, Meaner, Greener Blazor Components - AKA Rethinking the Blazor Component.</small></div></div>
    <p>Blazor ships with a single developer &quot;Component&quot;.  If you add a Razor file it inherits from it by default.</p>
<p><code>ComponentBase</code> rules the Blazor UI world.  You don't have to use it, but probably 99.x% of all developer built components either inherit directly or indirectly from it.</p>
<p>In a world of diversity, we have a one size fits all, swiss army knife solution.  A jack of all trades and master of none.</p>
<p>Most articles treat <code>ComponentBase</code> and &quot;Blazor Component&quot; as synonymous.</p>
<p><code>ComponentBase</code> should be just one tool in your toolbox, not the toolbox.  I may be in a minority of one. but I rarely use it.</p>
<h2 id="why">Why?</h2>
<p>Valid question.  My application runs perfectly well with <code>ComponentBase</code>.  Most of mine do to, but that's no reason to use it.</p>
<p>Consider this:</p>
<ul>
<li>Most code in the component's memory footprint is never run.  It's just bloatware: memory occupied doing nothing.</li>
<li>Most render events the component generates result in no UI changes.  CPU cycles used achieving nothing.</li>
<li>There are some key inheritance issues that it doesn't address.</li>
</ul>
<p>To summarise why not: it occupies memory space that it isn't using and consumes CPU cycles for no purpose.  That's money and energy going down the drain.</p>
<p>Do you really write lean, mean, green code?</p>
<p>Let me illustrate my point.</p>
<p>Here's a &quot;simple&quot; component.  It's a Bootstrap container.</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
&lt;div <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;container&quot;</span>&gt;
    @ChildContent
&lt;/div&gt;
@code {
    [Parameter] <span style="color:#569CD6;">public</span> RenderFragment? ChildContent { <span style="color:#569CD6;">get</span>; <span style="color:#569CD6;">set</span>; }
}
</pre></div>
<p>Looks very simple and would probably pass code review.</p>
<p>Now take a look at this?  I haven't shown you the 150+ lines - I don't want TLDR!</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
<span style="color:#569CD6;">public</span> <span style="color:#569CD6;">abstract</span> <span style="color:#569CD6;">class</span> ComponentBase : IComponent, IHandleEvent, IHandleAfterRender
{
    <span style="color:#57A64A;">// 150+ lines</span>
    <span style="color:#57A64A;">// See Appendix for the 150+ lines</span>
}
</pre></div>
<p>This is what the above component really looks like.  Do you think this would pass code review?</p>
<h2 id="so-why-does-everyone-use-componentbase">So why does everyone use ComponentBase?</h2>
<p>Never thought about it, asked the right questions, lazy, don't know any better.  Component library suppliers - no idea, there are plenty of clever people around in those organisations.  They may display green credentials, but every time one of their components gets rendered it burning more energy that it should.</p>
<p>If every component you've written derives from <code>ComponentBase</code>, you need to seriously consider why.</p>
<p>To quote from the source code for <code>ComponentBase</code>:</p>
<blockquote>
<p>Most of the developer-facing component lifecycle concepts are encapsulated in this base class. The core components rendering system doesn't know about them (it only knows about IComponent). This gives us flexibility to change the lifecycle concepts easily, or for developers to design their own lifecycles as different base classes.</p>
</blockquote>
<p>I don't think the author of that comment ever expected <code>ComponentBase</code> to dominate the Blazor UI.  Look across the component landscape and see if you can spot any different base classes.</p>
<p>Here are the base classes for two of the popular Blazor libraries available on the market:</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
<span style="color:#569CD6;">public</span> <span style="color:#569CD6;">class</span> RadzenComponent : ComponentBase, IDisposable
</pre></div><div style="color:#DADADA;background-color:#1E1E1E;"><pre>
<span style="color:#569CD6;">public</span> <span style="color:#569CD6;">abstract</span> <span style="color:#569CD6;">class</span> MudComponentBase : ComponentBase
</pre></div>
<p>Good developers who understand <code>ComponentBase</code> are questioning component usage. They believe simple components are too <strong>expensive</strong>.  They have too much overhead and carry too much baggage.  They write repetitive code to avoid building too many components into a page.</p>
<p>My answer: Don't throw away the component: write base components that are fit for purpose.</p>
<p>I have two principle base components.  They are based on what I call the <strong>Lean Mean Green Component</strong> - LMGC from now on - that I'll cover in detail below.</p>
<h2 id="lean-mean-green-strategies">Lean, Mean, Green Strategies</h2>
<h3 id="simplify-the-lifecycle-process">Simplify the Lifecycle Process</h3>
<p>How many of your components use the full gamat of lifecycle methods?  1%, if that.  Simplify and remove a lot of code and expensive Task construction for no purpose.</p>
<h3 id="manage-parameter-changes">Manage Parameter Changes</h3>
<p>When a component is rendered, the renderer must decide whether any child components need re-rendering.  It manages a component's parameter state though a <code>ParametersView</code> object.  It checks if any child component parameters have changed, and if so, calls <code>SetParametersAsync</code> passing in the <code>ParametersView</code> object.</p>
<p>The first line of <code>SetParametersAsync</code> uses the <code>ParametersView</code> to set the component's parameters.</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
        parameters.SetParameterProperties(<span style="color:#569CD6;">this</span>);
</pre></div>
<p>There are two issues with this process.  Neither are simple to address:</p>
<ol>
<li><p>Setting the parameters is expensive exercise because <code>ParameterView</code> uses reflection to find and assign the parameter values.</p>
</li>
<li><p>The method by which <code>ParameterView</code> detects state change is optimized, but relatively crude.</p>
</li>
</ol>
<p>Here's the code:</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
<span style="color:#569CD6;">public</span> <span style="color:#569CD6;">static</span> <span style="color:#569CD6;">bool</span> MayHaveChanged&lt;T1, T2&gt;(T1 oldValue, T2 newValue)
{
    <span style="color:#569CD6;">var</span> oldIsNotNull = oldValue != <span style="color:#569CD6;">null</span>;
    <span style="color:#569CD6;">var</span> newIsNotNull = newValue != <span style="color:#569CD6;">null</span>;

    <span style="color:#57A64A;">// Only one is null so different</span>
    <span style="color:#569CD6;">if</span> (oldIsNotNull != newIsNotNull)
        <span style="color:#569CD6;">return</span> <span style="color:#569CD6;">true</span>;

    <span style="color:#569CD6;">var</span> oldValueType = oldValue!.GetType();
    <span style="color:#569CD6;">var</span> newValueType = newValue!.GetType();

    <span style="color:#569CD6;">if</span> (oldValueType != newValueType)
        <span style="color:#569CD6;">return</span> <span style="color:#569CD6;">true</span>;

    <span style="color:#569CD6;">if</span> (!IsKnownImmutableType(oldValueType))
        <span style="color:#569CD6;">return</span> <span style="color:#569CD6;">true</span>;

    <span style="color:#569CD6;">return</span> !oldValue.Equals(newValue);
}

<span style="color:#569CD6;">private</span> <span style="color:#569CD6;">static</span> <span style="color:#569CD6;">bool</span> IsKnownImmutableType(Type type)
    =&gt; type.IsPrimitive
        || type == <span style="color:#569CD6;">typeof</span>(<span style="color:#569CD6;">string</span>)
        || type == <span style="color:#569CD6;">typeof</span>(DateTime)
        || type == <span style="color:#569CD6;">typeof</span>(Type)
        || type == <span style="color:#569CD6;">typeof</span>(<span style="color:#569CD6;">decimal</span>)
        || type == <span style="color:#569CD6;">typeof</span>(Guid);
</pre></div>
<p>Callbacks and RenderFragments are objects and always fail the <code>IsKnownImmutableType</code> test.</p>
<p>My strategies are:</p>
<ol>
<li>Stick to Immutable types where possible.</li>
<li>Live with it.</li>
<li>If a component is being used a lot and performance is an issue, do the assignment and change checking manually.  You can often code Callbacks and RenderFragments that won't change once initially assigned.</li>
<li>Stop unnecessary top down component tree render cascades. See the next strategy.</li>
</ol>
<h3 id="dont-render-when-you-dont-need-to">Don't Render when you don't need to</h3>
<p>Yes, a double negative - you should only render a component when you need to.  Don't do it by default, which is what <code>ComponentBase</code> does.</p>
<p>Here's the <code>ComponentBase</code> handler for UI events:</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
Task IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, <span style="color:#569CD6;">object</span>? arg)
{
    <span style="color:#569CD6;">var</span> task = callback.InvokeAsync(arg);
    <span style="color:#569CD6;">var</span> shouldAwaitTask = task.Status != TaskStatus.RanToCompletion &amp;&amp;
        task.Status != TaskStatus.Canceled;

    StateHasChanged();

    <span style="color:#569CD6;">return</span> shouldAwaitTask ?
        CallStateHasChangedOnAsyncCompletion(task) :
        Task.CompletedTask;
}
</pre></div>
<p>If you don't implement <code>IHandleEvent</code> then you are repsonsible for calling <code>StateHasChanged</code> when you need to.</p>
<h3 id="do-you-need-afterrender">Do You need AfterRender?</h3>
<p><code>ComponentBase</code> implements a set of after render events.</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
    Task IHandleAfterRender.OnAfterRenderAsync()
    {
        <span style="color:#569CD6;">var</span> firstRender = !_hasCalledOnAfterRender;
        _hasCalledOnAfterRender |= <span style="color:#569CD6;">true</span>;

        OnAfterRender(firstRender);

        <span style="color:#569CD6;">return</span> OnAfterRenderAsync(firstRender);
    }
</pre></div>
<p>Probably 99% of components don't need them.  So manually implement <code>IHandleAfterRender</code> on the rare occasions you need it.</p>
<h2 id="our-lean.mean.green-components">Our Lean. Mean. Green Components</h2>
<p>Based on what we've discussed above we can build a set of new base components.</p>
<h3 id="uibase">UIBase</h3>
<p>This is the minimum functionality core component.</p>
<p>What's in it:</p>
<ol>
<li>It inherits from <code>IComponent</code>.</li>
<li>All the internal class fields are <code>protected</code> so can be accessed and set in child components.</li>
<li>It has no UI event handler to drive an automatic render request.  Call <code>StateHasChanged</code> when you want to make a render request.</li>
<li>There's no AfterRender infrastructure.  Implement it if you need it.</li>
<li>There are two <code>StateHasChanged</code> methods.
<ol>
<li><code>StateHasChanged</code> is the same as the familiar <code>StateHasChanged</code>.</li>
<li><code>InvokeStateHasChanged</code> ensures <code>StateHasChanged</code> is called on the UI thread.</li>
</ol>
</li>
<li>There's no lifecycle events.</li>
<li>A <code>BuildRenderTree</code> method for compatibility with Razor components.</li>
<li>It caches <code>renderFragment</code> for efficiency.</li>
<li>A <code>Hidden</code> Parameter to mimic the hidden html attribute that can be set externally.</li>
<li>A class <code>hide</code> field that can be set internally in child classes.</li>
<li>A <code>ChildContent</code> Parameter for component content.</li>
</ol>
<p><code>Hidden</code>/<code>hide</code> is built is at this level so it can be implemented efficiently in the component <code>renderFragment</code>.</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
<span style="color:#569CD6;">public</span> <span style="color:#569CD6;">abstract</span> <span style="color:#569CD6;">class</span> UIBase : IComponent
{
    <span style="color:#569CD6;">protected</span> RenderFragment renderFragment;
    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">internal</span> RenderHandle renderHandle;
    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">bool</span> hasPendingQueuedRender = <span style="color:#569CD6;">false</span>;
    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">internal</span> <span style="color:#569CD6;">bool</span> hasNeverRendered = <span style="color:#569CD6;">true</span>;
    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">bool</span> hide;

    [Parameter] <span style="color:#569CD6;">public</span> RenderFragment? ChildContent { <span style="color:#569CD6;">get</span>; <span style="color:#569CD6;">set</span>; }

    [Parameter] <span style="color:#569CD6;">public</span> <span style="color:#569CD6;">bool</span> Hidden { <span style="color:#569CD6;">get</span>; <span style="color:#569CD6;">set</span>; } = <span style="color:#569CD6;">false</span>;

    <span style="color:#569CD6;">public</span> UIBase()
    {
        renderFragment = builder =&gt;
        {
            hasPendingQueuedRender = <span style="color:#569CD6;">false</span>;
            hasNeverRendered = <span style="color:#569CD6;">false</span>;
            <span style="color:#569CD6;">if</span> (!(Hidden | hide))
                BuildRenderTree(builder);
        };
    }

    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">virtual</span> <span style="color:#569CD6;">void</span> BuildRenderTree(RenderTreeBuilder builder) { }

    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">void</span> StateHasChanged()
    {
        <span style="color:#569CD6;">if</span> (hasPendingQueuedRender)
            <span style="color:#569CD6;">return</span>;

        hasPendingQueuedRender = <span style="color:#569CD6;">true</span>;
        renderHandle.Render(renderFragment);
    }

    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">void</span> InvokeStateHasChanged()
        =&gt; renderHandle.Dispatcher.InvokeAsync(StateHasChanged);

    <span style="color:#569CD6;">public</span> <span style="color:#569CD6;">void</span> Attach(RenderHandle renderHandle)
        =&gt; <span style="color:#569CD6;">this</span>.renderHandle = renderHandle;

    <span style="color:#569CD6;">public</span> <span style="color:#569CD6;">virtual</span> Task SetParametersAsync(ParameterView parameters)
    {
        parameters.SetParameterProperties(<span style="color:#569CD6;">this</span>);
        StateHasChanged();
        <span style="color:#569CD6;">return</span> Task.CompletedTask;
    }
}
</pre></div><h3 id="uicomponentbase">UIComponentBase</h3>
<p><code>UIComponentBase</code> adds a single lifefcycle event <code>OnParametersChangedAsync</code>.  It:</p>
<ol>
<li>Passes in a <code>bool</code> to indicate first render.</li>
<li>Expects a return <code>bool</code> used to control component render.  It will always render once.</li>
<li>Is a <code>ValueTask</code> to save overhead.</li>
</ol>
<p><code>OnParametersChangedAsync</code> can be used to:</p>
<ol>
<li>Do everything you did in <code>OnInitialized{Async}</code> and <code>OnParametersSet{Async}</code>.</li>
<li>Check what parameters have been set and decide if a render is necessary.</li>
</ol>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
<span style="color:#569CD6;">public</span> <span style="color:#569CD6;">abstract</span> <span style="color:#569CD6;">class</span> UIComponentBase : UIBase
{
    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">bool</span> initialized;

    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">virtual</span> ValueTask&lt;<span style="color:#569CD6;">bool</span>&gt; OnParametersChangedAsync(<span style="color:#569CD6;">bool</span> firstRender)
        =&gt; ValueTask.FromResult(<span style="color:#569CD6;">true</span>);

    <span style="color:#569CD6;">public</span> <span style="color:#569CD6;">override</span> <span style="color:#569CD6;">async</span> Task SetParametersAsync(ParameterView parameters)
    {
        parameters.SetParameterProperties(<span style="color:#569CD6;">this</span>);

        <span style="color:#569CD6;">var</span> dorender = <span style="color:#569CD6;">await</span> <span style="color:#569CD6;">this</span>.OnParametersChangedAsync(!initialized)
            || hasNeverRendered
            || !hasPendingQueuedRender;

        <span style="color:#569CD6;">if</span> (dorender)
            <span style="color:#569CD6;">this</span>.StateHasChanged();

        <span style="color:#569CD6;">this</span>.initialized = <span style="color:#569CD6;">true</span>;
    }
}
</pre></div><h3 id="adding-automated-ui-rendering">Adding Automated UI Rendering</h3>
<p>If you need automated UI rendering, implement <code>IHandleEvent</code>.</p>
<p>For a single render:</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
@implements IHandleEvent

<span style="color:#57A64A;">//...</span>
@code {
    <span style="color:#569CD6;">public</span> <span style="color:#569CD6;">async</span> Task HandleEventAsync(EventCallbackWorkItem callback, <span style="color:#569CD6;">object</span>? arg)
    {
        <span style="color:#569CD6;">await</span> callback.InvokeAsync(arg);
        StateHasChanged();
    }
}
</pre></div>
<p>For a double event:</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
@implements IHandleEvent

<span style="color:#57A64A;">//...</span>
@code {
    <span style="color:#569CD6;">public</span> <span style="color:#569CD6;">async</span> Task HandleEventAsync(EventCallbackWorkItem callback, <span style="color:#569CD6;">object</span>? arg)
    {
        <span style="color:#569CD6;">var</span> task = callback.InvokeAsync(arg);
        <span style="color:#569CD6;">if</span> (task.Status != TaskStatus.RanToCompletion &amp;&amp; task.Status != TaskStatus.Canceled)
        {
            StateHasChanged();
            <span style="color:#569CD6;">await</span> task;
        }
        StateHasChanged();
    }
}
</pre></div><h3 id="adding-onafterrender">Adding OnAfterRender</h3>
<p>If you need to implement the <code>OnAfterRender</code> event, implement <code>IHandleAfterRender</code>.</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
@implements IHandleAfterRender

<span style="color:#57A64A;">//...</span>

@code {
    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">bool</span> _hasCalledOnAfterRender;

    <span style="color:#569CD6;">public</span> Task OnAfterRenderAsync()
    {
        <span style="color:#569CD6;">var</span> firstRender = !_hasCalledOnAfterRender;
        _hasCalledOnAfterRender |= <span style="color:#569CD6;">true</span>;

        <span style="color:#57A64A;">// your code here</span>

        <span style="color:#569CD6;">return</span> Task.CompletedTask;
    }
}
</pre></div><h2 id="render-cascades">Render Cascades</h2>
<p>One of the most important strategies to implement is avoiding render cascades.</p>
<p>If you render a component with sub-components that have object parameters, the Renderer will call <code>SetParametersAsync</code> on the sub-components regardless of an real state change.  Unless you've implemented stop strategies in those components rendering will cascade down through the tree.</p>
<p>The principle way to minimize this is:</p>
<ol>
<li>Use state objects with events to drive updates.</li>
<li>Call <code>StateHasChanged</code> in the correct point in the render tree.</li>
<li>Use base components at the top of the tree that don't automatically trigger render events.</li>
</ol>
<h2 id="some-demonstration-implementations">Some Demonstration Implementations</h2>
<h3 id="the-counter-page">The Counter Page</h3>
<p>This demonstration shows how to rebuild the Counter page.</p>
<h4 id="counterstate">CounterState</h4>
<p>We need a state object to track the counter state.</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
<span style="color:#569CD6;">public</span> <span style="color:#569CD6;">class</span> CounterState
{
    <span style="color:#569CD6;">public</span> <span style="color:#569CD6;">int</span> Counter { <span style="color:#569CD6;">get</span>; <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">set</span>; }

    <span style="color:#569CD6;">public</span> Action&lt;<span style="color:#569CD6;">int</span>&gt;? CounterUpdated;

    <span style="color:#569CD6;">public</span> <span style="color:#569CD6;">void</span> IncrementCounter()
    {
        <span style="color:#569CD6;">this</span>.Counter++;
        <span style="color:#569CD6;">this</span>.CounterUpdated?.Invoke(<span style="color:#569CD6;">this</span>.Counter);
    }
}
</pre></div><h4 id="countercomponent.razor">CounterComponent.razor</h4>
<p><code>CounterComponent</code> displays the Counter.  It inherits from <code>UIComponentBase</code> and implements <code>IDisposable</code>.</p>
<p>It's a little more intricate than a standard component but is pretty self explanatory.</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
@<span style="color:#569CD6;">namespace</span> Blazr.Components
@implements IDisposable
@inherits UIComponentBase

&lt;div <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;alert alert-info&quot;</span>&gt;
    @<span style="color:#569CD6;">this</span>.Counter
&lt;/div&gt;

@code {
    [CascadingParameter] <span style="color:#569CD6;">private</span> CounterState State { <span style="color:#569CD6;">get</span>; <span style="color:#569CD6;">set</span>; } = <span style="color:#569CD6;">default</span>!;
    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">int</span> Counter;

    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">override</span> ValueTask&lt;<span style="color:#569CD6;">bool</span>&gt; OnParametersChangedAsync(<span style="color:#569CD6;">bool</span> firstRender)
    {
        <span style="color:#569CD6;">if</span> (firstRender)
        {
            <span style="color:#569CD6;">if</span> (<span style="color:#569CD6;">this</span>.State <span style="color:#569CD6;">is</span> <span style="color:#569CD6;">null</span>)
                <span style="color:#569CD6;">throw</span> <span style="color:#569CD6;">new</span> NullReferenceException($<span style="color:#D69D85;">&quot;State cannot be null in Component {this.GetType().Name}&quot;</span>);

            <span style="color:#569CD6;">this</span>.State.CounterUpdated += <span style="color:#569CD6;">this</span>.OnCounterUpdated;
        }
        <span style="color:#569CD6;">return</span> ValueTask.FromResult(<span style="color:#569CD6;">true</span>);
    }

    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">void</span> OnCounterUpdated(<span style="color:#569CD6;">int</span> counter)
    {
        <span style="color:#569CD6;">this</span>.Counter = counter;
        <span style="color:#569CD6;">this</span>.StateHasChanged();
    }

    <span style="color:#569CD6;">public</span> <span style="color:#569CD6;">void</span> Dispose()
        =&gt; <span style="color:#569CD6;">this</span>.State.CounterUpdated -= <span style="color:#569CD6;">this</span>.OnCounterUpdated;
}
</pre></div><h4 id="counter.razor">Counter.Razor</h4>
<p><code>Counter</code> implements <code>UIBase</code>: it doesn't need the lifecycle event.  it creates an instance of <code>CounterState</code>, cascades it and updates it on the button click.  There are three instances of <code>CounterComponent</code> to demonstrate the multi-cast functionality of the event.</p>
<p>I've left the old counter code in place so you can see that it no longer updates.  <code>IncrementCounter</code> no longer triggers a render of the route component, and therfore no longer triggers a render cascade.</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
@page <span style="color:#D69D85;">&quot;/counter&quot;</span>
@inherits UIBase
&lt;PageTitle&gt;Counter&lt;/PageTitle&gt;

&lt;h1&gt;Counter&lt;/h1&gt;

&lt;p role=<span style="color:#D69D85;">&quot;status&quot;</span>&gt;Current count: @currentCount&lt;/p&gt;
&lt;CascadingValue Value=<span style="color:#D69D85;">&quot;this.counterState&quot;</span>&gt;
    &lt;CounterComponent /&gt;
    &lt;CounterComponent /&gt;
    &lt;CounterComponent /&gt;
&lt;/CascadingValue&gt;

&lt;button <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;btn btn-primary&quot;</span> @onclick=<span style="color:#D69D85;">&quot;IncrementCount&quot;</span>&gt;Click me&lt;/button&gt;

@code {
    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">int</span> currentCount = <span style="color:#B5CEA8;">0</span>;
    <span style="color:#569CD6;">private</span> CounterState counterState = <span style="color:#569CD6;">new</span> CounterState();

    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">void</span> IncrementCount()
    {
        currentCount++;
        <span style="color:#569CD6;">this</span>.counterState.IncrementCounter();
    }
}
</pre></div><h3 id="a-weather-record-viewer">A Weather Record Viewer</h3>
<p>This demonstrates selective rendering in <code>SetParametersAsync</code>.  The forward and back buttons move up and down the record set and reload the route.  The component tracks the current record with <code>_id</code> and in <code>OnParametersChangedAsync</code> checks the updated parameter <code>Id</code>.  It only renders (returns true) when Id has changed.</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
@page <span style="color:#D69D85;">&quot;/WeatherView/{Id:int}&quot;</span>
@inherits UIComponentBase
@inject NavigationManager NavManager

&lt;h3&gt;WeatherViewer&lt;/h3&gt;

&lt;div <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;row mb-2&quot;</span>&gt;
    &lt;div <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;col-3&quot;</span>&gt;
        Date
    &lt;/div&gt;
    &lt;div <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;col-3&quot;</span>&gt;
        @<span style="color:#569CD6;">this</span>.record.Date
    &lt;/div&gt;
&lt;/div&gt;
&lt;div <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;row mb-2&quot;</span>&gt;
    &lt;div <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;col-3&quot;</span>&gt;
        Temperature &amp;deg;C
    &lt;/div&gt;
    &lt;div <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;col-3&quot;</span>&gt;
        @<span style="color:#569CD6;">this</span>.record.TemperatureC
    &lt;/div&gt;
&lt;/div&gt;
&lt;div <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;row mb-2&quot;</span>&gt;
    &lt;div <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;col-3&quot;</span>&gt;
        Summary
    &lt;/div&gt;
    &lt;div <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;col-6&quot;</span>&gt;
        @<span style="color:#569CD6;">this</span>.record.Summary
    &lt;/div&gt;
&lt;/div&gt;
&lt;div <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;m-2&quot;</span>&gt;
    &lt;button <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;btn btn-dark&quot;</span> @onclick=<span style="color:#D69D85;">&quot;() =&gt; this.Move(-1)&quot;</span>&gt;Previous&lt;/button&gt; 
    &lt;button <span style="color:#569CD6;">class</span>=<span style="color:#D69D85;">&quot;btn btn-primary&quot;</span> @onclick=<span style="color:#D69D85;">&quot;() =&gt; this.Move(1)&quot;</span>&gt;Next&lt;/button&gt;
&lt;/div&gt;

@code {
    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">int</span> _id;
    <span style="color:#569CD6;">private</span> WeatherForecast record = <span style="color:#569CD6;">new</span>();

    [Parameter] <span style="color:#569CD6;">public</span> <span style="color:#569CD6;">int</span> Id { <span style="color:#569CD6;">get</span>; <span style="color:#569CD6;">set</span>; } = <span style="color:#B5CEA8;">0</span>;

    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">override</span> <span style="color:#569CD6;">async</span> ValueTask&lt;<span style="color:#569CD6;">bool</span>&gt; OnParametersChangedAsync(<span style="color:#569CD6;">bool</span> firstRender)
    {
        <span style="color:#569CD6;">var</span> recordChanged = !<span style="color:#569CD6;">this</span>.Id.Equals(_id);

        <span style="color:#569CD6;">if</span> (recordChanged)
        {
            _id = <span style="color:#569CD6;">this</span>.Id;
            <span style="color:#569CD6;">this</span>.record = <span style="color:#569CD6;">await</span> GetForecast(<span style="color:#569CD6;">this</span>.Id);
        }

        <span style="color:#569CD6;">return</span> recordChanged;
    }

    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">static</span> <span style="color:#569CD6;">async</span> ValueTask&lt;WeatherForecast&gt; GetForecast(<span style="color:#569CD6;">int</span> id)
    {
        <span style="color:#569CD6;">await</span> Task.Delay(<span style="color:#B5CEA8;">100</span>);
        <span style="color:#569CD6;">return</span> <span style="color:#569CD6;">new</span> WeatherForecast
            {
                Date = DateOnly.FromDateTime(DateTime.Now.AddDays(id)),
                TemperatureC = id,
                Summary = <span style="color:#D69D85;">&quot;Testing&quot;</span>
            };
    }

    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">void</span> Move(<span style="color:#569CD6;">int</span> value)
        =&gt; <span style="color:#569CD6;">this</span>.NavManager.NavigateTo($<span style="color:#D69D85;">&quot;/WeatherView/{_id + value}&quot;</span>);
}
</pre></div><h2 id="conclusions">Conclusions</h2>
<p>If this article isn't a wake up call to serious Blazor developers to rethink the component, I've failed!</p>
<p>What will it take to get out of the <code>ComponentBase</code> comfort zone.  Your building the whole UI on a jack-of-all-trades master-of-none base class.  It has just about everything thrown in to cover almost every eventuality.</p>
<p>It's great to get you started.  Learn the ropes, look under the hood. Buth then move on.</p>
<h2 id="appendix">Appendix</h2>
<h3 id="componentbase">ComponentBase</h3>
<p>This is the code that gets loaded with every component you build that inherits from <code>ComponentBase</code>.</p>
<div style="color:#DADADA;background-color:#1E1E1E;"><pre>
<span style="color:#569CD6;">public</span> <span style="color:#569CD6;">abstract</span> <span style="color:#569CD6;">class</span> ComponentBase : IComponent, IHandleEvent, IHandleAfterRender
{
    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">readonly</span> RenderFragment _renderFragment;
    <span style="color:#569CD6;">private</span> RenderHandle _renderHandle;
    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">bool</span> _initialized;
    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">bool</span> _hasNeverRendered = <span style="color:#569CD6;">true</span>;
    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">bool</span> _hasPendingQueuedRender;
    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">bool</span> _hasCalledOnAfterRender;

    <span style="color:#569CD6;">public</span> ComponentBase()
    {
        _renderFragment = builder =&gt;
        {
            _hasPendingQueuedRender = <span style="color:#569CD6;">false</span>;
            _hasNeverRendered = <span style="color:#569CD6;">false</span>;
            BuildRenderTree(builder);
        };
    }

    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">virtual</span> <span style="color:#569CD6;">void</span> BuildRenderTree(RenderTreeBuilder builder) { }
    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">virtual</span> <span style="color:#569CD6;">void</span> OnInitialized() { }
    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">virtual</span> Task OnInitializedAsync() =&gt; Task.CompletedTask;
    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">virtual</span> <span style="color:#569CD6;">void</span> OnParametersSet() { }
    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">virtual</span> Task OnParametersSetAsync() =&gt; Task.CompletedTask;
    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">virtual</span> <span style="color:#569CD6;">bool</span> ShouldRender() =&gt; <span style="color:#569CD6;">true</span>;
    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">virtual</span> <span style="color:#569CD6;">void</span> OnAfterRender(<span style="color:#569CD6;">bool</span> firstRender) { }
    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">virtual</span> Task OnAfterRenderAsync(<span style="color:#569CD6;">bool</span> firstRender) =&gt; Task.CompletedTask;
    <span style="color:#569CD6;">protected</span> Task InvokeAsync(Action workItem) =&gt; _renderHandle.Dispatcher.InvokeAsync(workItem);
    <span style="color:#569CD6;">protected</span> Task InvokeAsync(Func&lt;Task&gt; workItem) =&gt; _renderHandle.Dispatcher.InvokeAsync(workItem);

    <span style="color:#569CD6;">protected</span> <span style="color:#569CD6;">void</span> StateHasChanged()
    {
        <span style="color:#569CD6;">if</span> (_hasPendingQueuedRender)
            <span style="color:#569CD6;">return</span>;

        <span style="color:#569CD6;">if</span> (_hasNeverRendered || ShouldRender() || _renderHandle.IsRenderingOnMetadataUpdate)
        {
            _hasPendingQueuedRender = <span style="color:#569CD6;">true</span>;

            <span style="color:#569CD6;">try</span>
            {
                _renderHandle.Render(_renderFragment);
            }
            <span style="color:#569CD6;">catch</span>
            {
                _hasPendingQueuedRender = <span style="color:#569CD6;">false</span>;
                <span style="color:#569CD6;">throw</span>;
            }
        }
    }

    <span style="color:#569CD6;">void</span> IComponent.Attach(RenderHandle renderHandle)
    {
        <span style="color:#569CD6;">if</span> (_renderHandle.IsInitialized)
            <span style="color:#569CD6;">throw</span> <span style="color:#569CD6;">new</span> InvalidOperationException($<span style="color:#D69D85;">&quot;The render handle is already set. Cannot initialize a {nameof(ComponentBase)} more than once.&quot;</span>);

        _renderHandle = renderHandle;
    }

    <span style="color:#569CD6;">public</span> <span style="color:#569CD6;">virtual</span> Task SetParametersAsync(ParameterView parameters)
    {
        parameters.SetParameterProperties(<span style="color:#569CD6;">this</span>);
        <span style="color:#569CD6;">if</span> (!_initialized)
        {
            _initialized = <span style="color:#569CD6;">true</span>;

            <span style="color:#569CD6;">return</span> RunInitAndSetParametersAsync();
        }
        <span style="color:#569CD6;">else</span>
            <span style="color:#569CD6;">return</span> CallOnParametersSetAsync();
    }

    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">async</span> Task RunInitAndSetParametersAsync()
    {
        OnInitialized();
        <span style="color:#569CD6;">var</span> task = OnInitializedAsync();

        <span style="color:#569CD6;">if</span> (task.Status != TaskStatus.RanToCompletion &amp;&amp; task.Status != TaskStatus.Canceled)
        {
            StateHasChanged();

            <span style="color:#569CD6;">try</span>
            {
                <span style="color:#569CD6;">await</span> task;
            }
            <span style="color:#569CD6;">catch</span>
            {
                <span style="color:#569CD6;">if</span> (!task.IsCanceled)
                    <span style="color:#569CD6;">throw</span>;
            }
        }

        <span style="color:#569CD6;">await</span> CallOnParametersSetAsync();
    }

    <span style="color:#569CD6;">private</span> Task CallOnParametersSetAsync()
    {
        OnParametersSet();
        <span style="color:#569CD6;">var</span> task = OnParametersSetAsync();

        <span style="color:#569CD6;">var</span> shouldAwaitTask = task.Status != TaskStatus.RanToCompletion &amp;&amp;
            task.Status != TaskStatus.Canceled;

        StateHasChanged();

        <span style="color:#569CD6;">return</span> shouldAwaitTask ?
            CallStateHasChangedOnAsyncCompletion(task) :
            Task.CompletedTask;
    }

    <span style="color:#569CD6;">private</span> <span style="color:#569CD6;">async</span> Task CallStateHasChangedOnAsyncCompletion(Task task)
    {
        <span style="color:#569CD6;">try</span>
        {
            <span style="color:#569CD6;">await</span> task;
        }
        <span style="color:#569CD6;">catch</span> 
        {
            <span style="color:#569CD6;">if</span> (task.IsCanceled)
                <span style="color:#569CD6;">return</span>;

            <span style="color:#569CD6;">throw</span>;
        }

        StateHasChanged();
    }

    Task IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, <span style="color:#569CD6;">object</span>? arg)
    {
        <span style="color:#569CD6;">var</span> task = callback.InvokeAsync(arg);
        <span style="color:#569CD6;">var</span> shouldAwaitTask = task.Status != TaskStatus.RanToCompletion &amp;&amp;
            task.Status != TaskStatus.Canceled;

        StateHasChanged();

        <span style="color:#569CD6;">return</span> shouldAwaitTask ?
            CallStateHasChangedOnAsyncCompletion(task) :
            Task.CompletedTask;
    }

    Task IHandleAfterRender.OnAfterRenderAsync()
    {
        <span style="color:#569CD6;">var</span> firstRender = !_hasCalledOnAfterRender;
        _hasCalledOnAfterRender |= <span style="color:#569CD6;">true</span>;

        OnAfterRender(firstRender);

        <span style="color:#569CD6;">return</span> OnAfterRenderAsync(firstRender);
    }
}
</pre></div></div></div></div></body></html>





