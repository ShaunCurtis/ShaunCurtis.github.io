<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<base href="/">

	

	

	
	<link href="/resources/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
	<link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">

	
	<link href="/resources/css/sb-admin-2.css" rel="stylesheet" type="text/css">
	<link href="/resources/css/site.css" rel="stylesheet" type="text/css">

	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
	<link rel="stylesheet" href="/resources/css/article.css" type="text/css">

	
	<link rel="icon" href="/images/favicon.png">

	<title>Rethinking The Repository Pattern</title>
        <meta property="author" content="Shaun Curtis" />
        <meta property="description" content="An article taking a fresh look at how to implement the Repository Pattern." />
    <meta property="og:site_name" content="Cold Elm Coders" />
        <meta property="og:site" content="https://shauncurtis.github.io/" />
        <meta property="og:title" content="Rethinking The Repository Pattern" />
        <meta property="og:description" content="An article taking a fresh look at how to implement the Repository Pattern." /></head>
<body><header class="navbar bg-dark p-2 text-large text-light"><section class="navbar-section  text-light"><a href="/" class="navbar-brand mr-2 text-large text-light p-2">Cold Elm Coders</a>
			<a href="/Posts" class="btn btn-link text-light">Posts</a>
			<a href="/Rants" class="btn btn-link text-light">Rants</a>
			<a href="/Articles" class="btn btn-link text-light">Articles</a>
			<a href="/Stories" class="btn btn-link text-light">Stories</a>
			<a href="/about.html" class="btn btn-link text-light">About</a></section></header>

	<div class="container-fluid"><div class="row"><div class="col-12 col-sm-3 col-lg-2 bg-light pt-2"><div class="article-info p-2"><div class="mb-2">Published: 07-Dec-2022</div>
                <div class="mb-2">Updated: 07-Dec-2022</div>
                <div class="mb-2">Author: Shaun Curtis</div></div>
    <h4 class="p-2">Table of Contents</h4>
<ul class="TOC" >
<li class="TOC-item TOC-item-0" >
<a class="TOC-link" href="#">Top</a>
<ul class="TOC TOC-0" >
<li class="TOC-item TOC-item-1" >
<ul class="TOC TOC-1" >
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#introduction">Introduction</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#nomenclature-terminology-and-practices">Nomenclature, Terminology and Practices</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#repo">Repo</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-data-store">The Data Store</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-classic-repository-pattern-implementation">The Classic Repository Pattern Implementation</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-implementation">The Implementation</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#testing-the-data-broker">Testing the Data Broker</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#wrapping-up">Wrapping Up</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#appendix">Appendix</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
			
			<div class="col-12 col-sm-9 col-lg-10 p-2"><div class="pt-2 pb-2 border-bottom mb-4 text-primary"><h1>Rethinking The Repository Pattern</h1>
            <div><small>An article taking a fresh look at how to implement the Repository Pattern.</small></div></div>
    <h2 id="introduction">Introduction</h2>
<p>The classic repository pattern is a fairly simple way to implement database access in any application.  It meets many of the normal design goals for a small application.  On the other side, CQS and CQRS provide a more complex but well structured design pattern for larger more complex applications.</p>
<p>In this article I'll develop the basic repository pattern applying some of the fundimentally good practices used in CQS and implement a fully generic provider.</p>
<p>This is not a regurgitated <code>IRepository</code> implementation in DotNetCore with a few frills.</p>
<ol>
<li>There's no implementation per entity class.  You won't see this:</li>
</ol>
<pre><code class="language-csharp">    public class WeatherForecastRepository : GenericRepository&lt;WeatherForecast&gt;, IWeatherForcastRepository
    {
        public WeatherForecastRepository(DbContextClass dbContext) : base(dbContext) {}
    }

    public interface IProductRepository : IGenericRepository&lt;WeatherForecast&gt; { }
</code></pre>
<ol start="2">
<li><p>There's no separate <code>UnitOfWork</code> classes: it's built in.</p>
</li>
<li><p>All standard Data I/O uses a single Data Broker.</p>
</li>
<li><p>CQS Requests, Results and Handler patterns are used in the design.</p>
</li>
</ol>
<h2 id="nomenclature-terminology-and-practices">Nomenclature, Terminology and Practices</h2>
<ul>
<li><strong>DI</strong>: Dependancy Injection</li>
<li><strong>CQS</strong>: Command/Query Separation</li>
</ul>
<p>The code is:</p>
<ul>
<li><em>Net7.0</em></li>
<li>C# 10</li>
<li><em>Nullable</em> enabled</li>
</ul>
<h2 id="repo">Repo</h2>
<p>The Repo and latest version of this article are here: <a href="https://github.com/ShaunCurtis/Blazr.IRepository">Blazr.IRepository</a>.</p>
<h2 id="the-data-store">The Data Store</h2>
<p>The solution needs a real data store for testing: it implements an Entity Framework In-Memory database.</p>
<p>I'm a Blazor developer so my test data class is <code>WeatherForecast</code>. The code for the data provider is in the Appendix.</p>
<p>This is the <code>DbContext</code> used by the DBContext factory.</p>
<pre><code class="language-csharp">public sealed class InMemoryWeatherDbContext : DbContext
{
    public DbSet&lt;WeatherForecast&gt; WeatherForecast { get; set; } = default!;
    public InMemoryWeatherDbContext(DbContextOptions&lt;InMemoryWeatherDbContext&gt; options) : base(options) { }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
        =&gt; modelBuilder.Entity&lt;WeatherForecast&gt;().ToTable(&quot;WeatherForecast&quot;);
}
</code></pre>
<h3 id="testing-the-factory-and-context">Testing the Factory and Context</h3>
<p>The following XUnit test demonstrates the basic datastore setup in DI. It:</p>
<ol>
<li>Sets up a DI container</li>
<li>Loads the data from the Test Provider</li>
<li>Tests the record count is correct</li>
<li>Tests one arbitary record is correct.</li>
</ol>
<pre><code class="language-csharp">[Fact]
public async Task DBContextTest()
{
    // Gets the control test data
    var testProvider = WeatherTestDataProvider.Instance();

    // Build our services container
    var services = new ServiceCollection();

    // Define the DbSet and Server Type for the DbContext Factory
    services.AddDbContextFactory&lt;InMemoryWeatherDbContext&gt;(options
        =&gt; options.UseInMemoryDatabase($&quot;WeatherDatabase-{Guid.NewGuid().ToString()}&quot;));

    var rootProvider = services.BuildServiceProvider();

    //define a scoped container
    var providerScope = rootProvider.CreateScope();
    var provider = providerScope.ServiceProvider;

    // get the DbContext factory and add the test data
    var factory = provider.GetService&lt;IDbContextFactory&lt;InMemoryWeatherDbContext&gt;&gt;();
    if (factory is not null)
        WeatherTestDataProvider.Instance().LoadDbContext&lt;InMemoryWeatherDbContext&gt;(factory);

    // Check the data has been loaded
    var dbContext = factory!.CreateDbContext();
    Assert.NotNull(dbContext);

    var count = dbContext.Set&lt;WeatherForecast&gt;().Count();
    Assert.Equal(testProvider.WeatherForecasts.Count(), count);

    // Test an arbitary record
    var testRecord = testProvider.GetRandomRecord()!;
    var record = await dbContext.Set&lt;WeatherForecast&gt;().SingleOrDefaultAsync(item =&gt; item.Uid.Equals(testRecord.Uid));
    Assert.Equal(testRecord, record);

    // Dispose of the resources correctly
    providerScope.Dispose();
    rootProvider.Dispose();
}
</code></pre>
<h2 id="the-classic-repository-pattern-implementation">The Classic Repository Pattern Implementation</h2>
<p>Here's a nice succinct implementation that I found on the Internet.</p>
<pre><code class="language-csharp">    public abstract class Repository&lt;T&gt; : IRepository&lt;T&gt; where T : class
    {
        protected readonly DbContextClass _dbContext;

        protected GenericRepository(DbContextClass context)
            =&gt; _dbContext = context;

        public async Task&lt;T&gt; GetById(int id)
            =&gt; await _dbContext.Set&lt;T&gt;().FindAsync(id);

        public async Task&lt;IEnumerable&lt;T&gt;&gt; GetAll()
            =&gt; await _dbContext.Set&lt;T&gt;().ToListAsync();

        public async Task Add(T entity)
             =&gt; await _dbContext.Set&lt;T&gt;().AddAsync(entity);

        public void Delete(T entity)
            =&gt; _dbContext.Set&lt;T&gt;().Remove(entity);

        public void Update(T entity)
           =&gt;  _dbContext.Set&lt;T&gt;().Update(entity);
    }
}
</code></pre>
<p>Picking it apart:</p>
<ol>
<li>What happens when a <code>null</code> is returned, what does it mean?</li>
<li>Did that add/update/delete really succeed?  How do I know?</li>
<li>How do you handle cancellation tokens?  Most async methods now accept a cancellation token.</li>
<li>What happens when your <code>DBSet</code> contains a million records (maybe the DBA got something wrong last night)?</li>
<li>There's one of me for every data store entity in the application.</li>
</ol>
<h2 id="the-implementation">The Implementation</h2>
<h3 id="requests-and-results">Requests and Results</h3>
<p>Request objects encapulate what we request and result objects the data and status information we expect back.  They are <code>records</code>: defined once and then consumed.</p>
<h4 id="commands">Commands</h4>
<p>A <em>Command</em> is a request to make a change to the data store: Create/Update/Delete operations.  We can define one like this:</p>
<pre><code class="language-csharp">public record CommandRequest&lt;TRecord&gt;
{
    public required TRecord Item { get; init; }
    public CancellationToken Cancellation { get; set; } = new ();
}
</code></pre>
<p>Commands only return status information: no data.  We can define a result like this:</p>
<pre><code class="language-csharp">public record CommandResult
{
    public bool Successful { get; init; }
    public string Message { get; init; } = string.Empty;

    private CommandResult() { }

    public static CommandResult Success(string? message = null)
        =&gt; new CommandResult { Successful = true, Message= message ?? string.Empty };

    public static CommandResult Failure(string message)
        =&gt; new CommandResult { Message = message};
}
</code></pre>
<p>At this point it's worth noting one small exception to the return rule: the Id for an inserted record.  If you aren't using Guids to give your records unique identifiers, then the database generated Id is status information.</p>
<h4 id="item-requests">Item Requests</h4>
<p>A <em>Query</em> is a request to get data from the data store: no mutation.  We can define an item query like this:</p>
<pre><code class="language-csharp">public sealed record ItemQueryRequest
{
    public required Guid Uid { get; init; }
    public CancellationToken Cancellation { get; set; } = new();
}
</code></pre>
<p>And the return result: the requested data and status.</p>
<pre><code class="language-csharp">public sealed record ItemQueryResult&lt;TRecord&gt;
{
    public TRecord? Item { get; init;} 
    public bool Successful { get; init; }
    public string Message { get; init; } = string.Empty;

    private ItemQueryResult() { }

    public static ItemQueryResult&lt;TRecord&gt; Success(TRecord Item, string? message = null)
        =&gt; new ItemQueryResult&lt;TRecord&gt; { Successful=true, Item= Item, Message= message ?? string.Empty };

    public static ItemQueryResult&lt;TRecord&gt; Failure(string message)
        =&gt; new ItemQueryResult&lt;TRecord&gt; { Message = message};
}
</code></pre>
<h4 id="list-queries">List Queries</h4>
<p>List queries present a few extra challenges.</p>
<ol>
<li>They should never request everything.  In edge conditions there may be 1,000,000+ rows in a table.  Every request should be constrained.  The request defines <code>StartIndex</code> and <code>PageSize</code> to both constrain the data and provide paging.  If you set the page size to 1,000,000, will your data pipeline and front end handle it gracefully?</li>
<li>They need to handle sorting and filtering.  The request defines these as Linq Expressions.</li>
</ol>
<pre><code class="language-csharp">public sealed record ListQueryRequest&lt;TRecord&gt;
{
    public int StartIndex { get; init; } = 0;
    public int PageSize { get; init; } = 1000;
    public CancellationToken Cancellation { get; set; } = new ();
    public bool SortDescending { get; } = false;
    public Expression&lt;Func&lt;TRecord, bool&gt;&gt;? FilterExpression { get; init; }
    public Expression&lt;Func&lt;TRecord, object&gt;&gt;? SortExpression { get; init; }
}
</code></pre>
<p>The result returns the items, the total item count (for paging) and status information.  <code>Items</code> are always returned as <code>IEnumerable</code>.</p>
<pre><code class="language-csharp">public sealed record ListQueryResult&lt;TRecord&gt;
{
    public IEnumerable&lt;TRecord&gt; Items { get; init;} = Enumerable.Empty&lt;TRecord&gt;();  
    public bool Successful { get; init; }
    public string Message { get; init; } = string.Empty;
    public long TotalCount { get; init; }

    private ListQueryResult() { }

    public static ListQueryResult&lt;TRecord&gt; Success(IEnumerable&lt;TRecord&gt; Items, long totalCount, string? message = null)
        =&gt; new ListQueryResult&lt;TRecord&gt; {Successful=true,  Items= Items, TotalCount = totalCount, Message= message ?? string.Empty };

    public static ListQueryResult&lt;TRecord&gt; Failure(string message)
        =&gt; new ListQueryResult&lt;TRecord&gt; { Message = message};
}
</code></pre>
<h3 id="handlers">Handlers</h3>
<p>Handlers are small single purpose classes that handle requests and return results.  They abstract the nitty-gritty execution from the higher level Data Broker.</p>
<h4 id="command-handlers">Command Handlers</h4>
<p>The interface provides the abstraction.</p>
<pre><code class="language-csharp">public interface ICreateRequestHandler
{
    public ValueTask&lt;CommandResult&gt; ExecuteAsync&lt;TRecord&gt;(CommandRequest&lt;TRecord&gt; request)
        where TRecord : class, new();
}
</code></pre>
<p>And the implementation does the real work.</p>
<ol>
<li>Injects the DBContext Factory.</li>
<li>Implements <em>Unit of Work</em> Db contexts through the DbContext factory.</li>
<li>Uses the Add method on the context to add the record to EF.</li>
<li>Calls <code>SaveChangesAsync</code>, passing in the Cancellation token, and expects a single change to be reported.</li>
<li>Provides status information if things go wrong.</li>
</ol>
<pre><code class="language-csharp">public sealed class CreateRequestHandler&lt;TDbContext&gt;
    : ICreateRequestHandler
    where TDbContext : DbContext
{
    private readonly IDbContextFactory&lt;TDbContext&gt; _factory;

    public CreateRequestHandler(IDbContextFactory&lt;TDbContext&gt; factory)
        =&gt; _factory = factory;

    public async ValueTask&lt;CommandResult&gt; ExecuteAsync&lt;TRecord&gt;(CommandRequest&lt;TRecord&gt; request)
        where TRecord : class, new()
    {
        if (request == null)
            throw new DataPipelineException($&quot;No CommandRequest defined in {this.GetType().FullName}&quot;);

        using var dbContext = _factory.CreateDbContext();

        dbContext.Add&lt;TRecord&gt;(request.Item);
        return await dbContext.SaveChangesAsync(request.Cancellation) == 1
            ? CommandResult.Success(&quot;Record Updated&quot;)
            : CommandResult.Failure(&quot;Error updating Record&quot;);
    }
}
</code></pre>
<p>The Update and Delete handlers are the same but use different <code>dbContext</code> methods: Update and Remove.</p>
<h4 id="item-request-handler">Item Request Handler</h4>
<p>The interface.</p>
<pre><code class="language-csharp">public interface IItemRequestHandler
{
    public ValueTask&lt;ItemQueryResult&lt;TRecord&gt;&gt; ExecuteAsync&lt;TRecord&gt;(ItemQueryRequest request)
        where TRecord : class, new();
}
</code></pre>
<p>And the server implementation. Note:</p>
<ol>
<li>Injects the DBContext Factory.</li>
<li>Implements <em>Unit of Work</em> Db contexts through the DbContext factory.</li>
<li>Turns off tracking.  There's no mutation involved in this transaction.</li>
<li>Checks to see if it can use an Id to get the item - the record implements <code>IGuidIdentity</code>.</li>
<li>If not, tries <code>FindAsync</code> which uses the inbuilt <code>Key</code> methodology to get the record.</li>
<li>Provides status information if things go wrong.</li>
</ol>
<pre><code class="language-csharp">public sealed class ItemRequestHandler&lt;TDbContext&gt;
    : IItemRequestHandler
    where TDbContext : DbContext
{
    private readonly IDbContextFactory&lt;TDbContext&gt; _factory;

    public ItemRequestHandler(IDbContextFactory&lt;TDbContext&gt; factory)
        =&gt; _factory = factory;

    public async ValueTask&lt;ItemQueryResult&lt;TRecord&gt;&gt; ExecuteAsync&lt;TRecord&gt;(ItemQueryRequest request)
        where TRecord : class, new()
    {
        if (request == null)
            throw new DataPipelineException($&quot;No ListQueryRequest defined in {this.GetType().FullName}&quot;);

        using var dbContext = _factory.CreateDbContext();
        dbContext.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;

        TRecord? record = null;

        // first check if the record implements IGuidIdentity.  If so we can do a cast and then do the query via the Uid property directly 
        if ((new TRecord()) is IGuidIdentity)
            record = await dbContext.Set&lt;TRecord&gt;().SingleOrDefaultAsync(item =&gt; ((IGuidIdentity)item).Uid == request.Uid, request.Cancellation);

        // Try and use the EF FindAsync implementation
        if (record is null)
            record = await dbContext.FindAsync&lt;TRecord&gt;(request.Uid);

        if (record is null)
            return ItemQueryResult&lt;TRecord&gt;.Failure(&quot;No record retrieved&quot;);

        return ItemQueryResult&lt;TRecord&gt;.Success(record);
    }
}
</code></pre>
<h4 id="list-request-handler">List Request Handler</h4>
<p>The interface.</p>
<pre><code class="language-csharp">public interface IListRequestHandler
{
    public ValueTask&lt;ListQueryResult&lt;TRecord&gt;&gt; ExecuteAsync&lt;TRecord&gt;(ListQueryRequest&lt;TRecord&gt; request)
        where TRecord : class, new();
}
</code></pre>
<p>And implementation.</p>
<p>Note there are two internal methods:</p>
<ol>
<li><code>_getItemsAsync</code> Gets the items.  This builds an <code>IQueryable</code> object and returns a materialized <code>IEnumerable</code>.  You must execute the query before the factory disposes the DbContext.</li>
<li><code>_getCountAsync</code> Gets the count of all the records based on the filter.</li>
</ol>
<pre><code class="language-csharp">    private async ValueTask&lt;IEnumerable&lt;TRecord&gt;&gt; _getItemsAsync&lt;TRecord&gt;(ListQueryRequest&lt;TRecord&gt; request)
        where TRecord : class, new()
    {
        if (request == null)
            throw new DataPipelineException($&quot;No ListQueryRequest defined in {this.GetType().FullName}&quot;);

        using var dbContext = _factory.CreateDbContext();
        dbContext.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;

        IQueryable&lt;TRecord&gt; query = dbContext.Set&lt;TRecord&gt;();
        if (request.FilterExpression is not null)
            query = query
                .Where(request.FilterExpression)
                .AsQueryable();

        if (request.SortExpression is not null)

            query = request.SortDescending
                ? query.OrderByDescending(request.SortExpression)
                : query.OrderBy(request.SortExpression);

        if (request.PageSize &gt; 0)
            query = query
                .Skip(request.StartIndex)
                .Take(request.PageSize);

        return query is IAsyncEnumerable&lt;TRecord&gt;
            ? await query.ToListAsync()
            : query.ToList();
    }
</code></pre>
<h3 id="the-repository-class-replacement">The Repository Class Replacement</h3>
<p>First the interface.</p>
<p>The very important bit is the generic <code>TRecord</code> definition on each method, not on the interface.  This removes the need for entity specific implementations.</p>
<pre><code class="language-csharp">public interface IDataBroker
{
    public ValueTask&lt;ListQueryResult&lt;TRecord&gt;&gt; GetItemsAsync&lt;TRecord&gt;(ListQueryRequest&lt;TRecord&gt; request) where TRecord : class, new();
    public ValueTask&lt;ItemQueryResult&lt;TRecord&gt;&gt; GetItemAsync&lt;TRecord&gt;(ItemQueryRequest request) where TRecord : class, new();
    public ValueTask&lt;CommandResult&gt; UpdateItemAsync&lt;TRecord&gt;(CommandRequest&lt;TRecord&gt; request) where TRecord : class, new();
    public ValueTask&lt;CommandResult&gt; CreateItemAsync&lt;TRecord&gt;(CommandRequest&lt;TRecord&gt; request) where TRecord : class, new();
    public ValueTask&lt;CommandResult&gt; DeleteItemAsync&lt;TRecord&gt;(CommandRequest&lt;TRecord&gt; request) where TRecord : class, new();
}
</code></pre>
<p>And the implementation.  Each handler is registered in DI and injected into the broker.</p>
<pre><code class="language-csharp">public sealed class RepositoryDataBroker : IDataBroker
{
    private readonly IListRequestHandler _listRequestHandler;
    private readonly IItemRequestHandler _itemRequestHandler;
    private readonly IUpdateRequestHandler _updateRequestHandler;
    private readonly ICreateRequestHandler _createRequestHandler;
    private readonly IDeleteRequestHandler _deleteRequestHandler;

    public RepositoryDataBroker(
        IListRequestHandler listRequestHandler,
        IItemRequestHandler itemRequestHandler,
        ICreateRequestHandler createRequestHandler,
        IUpdateRequestHandler updateRequestHandler,
        IDeleteRequestHandler deleteRequestHandler)
    {
        _listRequestHandler = listRequestHandler;
        _itemRequestHandler = itemRequestHandler;
        _createRequestHandler = createRequestHandler;
        _updateRequestHandler = updateRequestHandler;
        _deleteRequestHandler = deleteRequestHandler;
    }

    public ValueTask&lt;ItemQueryResult&lt;TRecord&gt;&gt; GetItemAsync&lt;TRecord&gt;(ItemQueryRequest request) where TRecord : class, new()
        =&gt; _itemRequestHandler.ExecuteAsync&lt;TRecord&gt;(request);

    public ValueTask&lt;ListQueryResult&lt;TRecord&gt;&gt; GetItemsAsync&lt;TRecord&gt;(ListQueryRequest&lt;TRecord&gt; request) where TRecord : class, new()
        =&gt; _listRequestHandler.ExecuteAsync&lt;TRecord&gt;(request);

    public ValueTask&lt;CommandResult&gt; CreateItemAsync&lt;TRecord&gt;(CommandRequest&lt;TRecord&gt; request) where TRecord : class, new()
        =&gt; _createRequestHandler.ExecuteAsync&lt;TRecord&gt;(request);

    public ValueTask&lt;CommandResult&gt; UpdateItemAsync&lt;TRecord&gt;(CommandRequest&lt;TRecord&gt; request) where TRecord : class, new()
        =&gt; _updateRequestHandler.ExecuteAsync&lt;TRecord&gt;(request);

    public ValueTask&lt;CommandResult&gt; DeleteItemAsync&lt;TRecord&gt;(CommandRequest&lt;TRecord&gt; request) where TRecord : class, new()
        =&gt; _deleteRequestHandler.ExecuteAsync&lt;TRecord&gt;(request);
}
</code></pre>
<h2 id="testing-the-data-broker">Testing the Data Broker</h2>
<p>We can now define a set of tests for the data broker.  I've included two here.  The rest are in the Repo.</p>
<p>First two methods to create our root DI container and populate the database.</p>
<pre><code class="language-csharp">private ServiceProvider BuildRootContainer()
{
    var services = new ServiceCollection();

    // Define the DbSet and Server Type for the DbContext Factory
    services.AddDbContextFactory&lt;InMemoryWeatherDbContext&gt;(options
        =&gt; options.UseInMemoryDatabase($&quot;WeatherDatabase-{Guid.NewGuid().ToString()}&quot;));
    // Define the Broker and Handlers
    services.AddScoped&lt;IDataBroker, RepositoryDataBroker&gt;();
    services.AddScoped&lt;IListRequestHandler, ListRequestHandler&lt;InMemoryWeatherDbContext&gt;&gt;();
    services.AddScoped&lt;IItemRequestHandler, ItemRequestHandler&lt;InMemoryWeatherDbContext&gt;&gt;();
    services.AddScoped&lt;IUpdateRequestHandler, UpdateRequestHandler&lt;InMemoryWeatherDbContext&gt;&gt;();
    services.AddScoped&lt;ICreateRequestHandler, CreateRequestHandler&lt;InMemoryWeatherDbContext&gt;&gt;();
    services.AddScoped&lt;IDeleteRequestHandler, DeleteRequestHandler&lt;InMemoryWeatherDbContext&gt;&gt;();

    // Create the container
    return services.BuildServiceProvider();
}

private IDbContextFactory&lt;InMemoryWeatherDbContext&gt; GetPopulatedFactory(IServiceProvider provider)
{
    // get the DbContext factory and add the test data
    var factory = provider.GetService&lt;IDbContextFactory&lt;InMemoryWeatherDbContext&gt;&gt;();
    if (factory is not null)
        WeatherTestDataProvider.Instance().LoadDbContext&lt;InMemoryWeatherDbContext&gt;(factory);

    return factory!;
}
</code></pre>
<p>The GetItems test:</p>
<pre><code class="language-csharp">[Fact]
public async Task GetItemsTest()
{
    // Get our test provider to use as our control
    var testProvider = WeatherTestDataProvider.Instance();

    // Build the root DI Container
    var rootProvider = this.BuildRootContainer();

    //define a scoped container
    var providerScope = rootProvider.CreateScope();
    var provider = providerScope.ServiceProvider;

    // get the DbContext factory and add the test data
    var factory = this.GetPopulatedFactory(provider);

    // Check we can retrieve thw first 1000 records
    var dbContext = factory!.CreateDbContext();
    Assert.NotNull(dbContext);

    var databroker = provider.GetRequiredService&lt;IDataBroker&gt;();

    var request = new ListQueryRequest&lt;WeatherForecast&gt;();
    var result = await databroker.GetItemsAsync&lt;WeatherForecast&gt;(request);

    Assert.NotNull(result);
    Assert.Equal(testProvider.WeatherForecasts.Count(), result.TotalCount);

    providerScope.Dispose();
    rootProvider.Dispose();
}
</code></pre>
<p>The Add Item test:</p>
<pre><code class="language-csharp">[Fact]
public async Task AddItemTest()
{
    // Get our test provider to use as our control
    var testProvider = WeatherTestDataProvider.Instance();

    // Build the root DI Container
    var rootProvider = this.BuildRootContainer();

    //define a scoped container
    var providerScope = rootProvider.CreateScope();
    var provider = providerScope.ServiceProvider;

    // get the DbContext factory and add the test data
    var factory = this.GetPopulatedFactory(provider);

    // Check we can retrieve thw first 1000 records
    var dbContext = factory!.CreateDbContext();
    Assert.NotNull(dbContext);

    var databroker = provider.GetRequiredService&lt;IDataBroker&gt;();

    // Create a Test record
    var newRecord = new WeatherForecast { Uid = Guid.NewGuid(), Date = DateOnly.FromDateTime(DateTime.Now), TemperatureC = 50, Summary = &quot;Add Testing&quot; };

    // Add the Record
    {
        var request = new CommandRequest&lt;WeatherForecast&gt;() { Item = newRecord };
        var result = await databroker.CreateItemAsync&lt;WeatherForecast&gt;(request);

        Assert.NotNull(result);
        Assert.True(result.Successful);
    }

    // Get the new record
    {
        var request = new ItemQueryRequest() { Uid = newRecord.Uid };
        var result = await databroker.GetItemAsync&lt;WeatherForecast&gt;(request);

        Assert.Equal(newRecord, result.Item);
    }

    // Check the record count has incremented
    {
        var request = new ListQueryRequest&lt;WeatherForecast&gt;();
        var result = await databroker.GetItemsAsync&lt;WeatherForecast&gt;(request);

        Assert.NotNull(result);
        Assert.Equal(testProvider.WeatherForecasts.Count() + 1, result.TotalCount);
    }

    providerScope.Dispose();
    rootProvider.Dispose();
}
</code></pre>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>What I've presented here is a hybrid Repository Pattern.  It maintains the Repository Pattern's simplicity, and adds some of the best CQS Pattern features.</p>
<p>Abstracting the nitty-gritty EF and Linq code to individual handlers keeps the classes small, succinct and single purpose.</p>
<p>The single Data Broker simplifies data pipeline configuration for the Core and Presentation domains.</p>
<p>To those who believe that implementing any database pipeline over EF is an anti-pattern, my answer is: I use EF as just another Object Request Broker [ORB].  You can plug this pipeline into Dapper, LinqToDb, ... .  I never build core business logic code (data relationships) into my Data/Infrastructure Domain: [personal view] crazy idea.</p>
<h2 id="appendix">Appendix</h2>
<h3 id="the-data-store-1">The Data Store</h3>
<p>The test system implements an Entity Framework In-Memory database.</p>
<p>I'm a Blazor developer so naturally my demo data class is <code>WeatherForecast</code>.  Here's my data class.  Note it is a record for immutability and I've set some arbitary default values for testing purposes.</p>
<pre><code class="language-csharp">public sealed record WeatherForecast : IGuidIdentity
{
    [Key] public Guid Uid { get; init; } = Guid.Empty;
    public DateOnly Date { get; init; } = DateOnly.FromDateTime(DateTime.Now);
    public int TemperatureC { get; init; } = 60;
    public string? Summary { get; init; } = &quot;Testing&quot;;
}
</code></pre>
<p>First a class to generate a data set.  This is a <em>Singleton</em> pattern class (not a DI singleton).  Methods such as <code>GetRandomRecord</code> are for testing.</p>
<pre><code class="language-csharp">public sealed class WeatherTestDataProvider
{
    private int RecordsToGenerate;

    public IEnumerable&lt;WeatherForecast&gt; WeatherForecasts { get; private set; } = Enumerable.Empty&lt;WeatherForecast&gt;();

    private WeatherTestDataProvider()
        =&gt; this.Load();

    public void LoadDbContext&lt;TDbContext&gt;(IDbContextFactory&lt;TDbContext&gt; factory) where TDbContext : DbContext
    {
        using var dbContext = factory.CreateDbContext();

        var weatherForcasts = dbContext.Set&lt;WeatherForecast&gt;();

        // Check if we already have a full data set
        // If not clear down any existing data and start again
        if (weatherForcasts.Count() == 0)
        {
            dbContext.AddRange(this.WeatherForecasts);
            dbContext.SaveChanges();
        }
    }

    public void Load(int records = 100)
    {
        RecordsToGenerate = records;

        if (WeatherForecasts.Count() == 0)
            this.LoadForecasts();
    }

    private void LoadForecasts()
    {
        var forecasts = new List&lt;WeatherForecast&gt;();

        for (var index = 0; index &lt; RecordsToGenerate; index++)
        {
            var rec = new WeatherForecast
            {
                Uid = Guid.NewGuid(),
                Summary = Summaries[Random.Shared.Next(Summaries.Length)],
                Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
                TemperatureC = Random.Shared.Next(-20, 55),
            };
            forecasts.Add(rec);
        }

        this.WeatherForecasts = forecasts;
    }

    public WeatherForecast GetForecast()
    {
        return new WeatherForecast
        {
            Uid = Guid.NewGuid(),
            Summary = Summaries[Random.Shared.Next(Summaries.Length)],
            Date = DateOnly.FromDateTime(DateTime.Now.AddDays(-1)),
            TemperatureC = Random.Shared.Next(-20, 55),
        };
    }

    public WeatherForecast? GetRandomRecord()
    {
        var record = new WeatherForecast();
        if (this.WeatherForecasts.Count() &gt; 0)
        {
            var ran = new Random().Next(0, WeatherForecasts.Count());
            return this.WeatherForecasts.Skip(ran).FirstOrDefault();
        }
        return null;
    }

    private static WeatherTestDataProvider? _weatherTestData;

    public static WeatherTestDataProvider Instance()
    {
        if (_weatherTestData is null)
            _weatherTestData = new WeatherTestDataProvider();

        return _weatherTestData;
    }

    public static readonly string[] Summaries = new[]
    {
        &quot;Freezing&quot;, &quot;Bracing&quot;, &quot;Chilly&quot;, &quot;Cool&quot;, &quot;Mild&quot;, &quot;Warm&quot;, &quot;Balmy&quot;, &quot;Hot&quot;, &quot;Sweltering&quot;, &quot;Scorching&quot;
    };

}
</code></pre>
<p>The <code>DbContext</code>.</p>
<pre><code class="language-csharp">public sealed class InMemoryWeatherDbContext
    : DbContext
{
    public DbSet&lt;WeatherForecast&gt; WeatherForecast { get; set; } = default!;
    public InMemoryWeatherDbContext(DbContextOptions&lt;InMemoryWeatherDbContext&gt; options) : base(options) { }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
        =&gt; modelBuilder.Entity&lt;WeatherForecast&gt;().ToTable(&quot;WeatherForecast&quot;);
}
</code></pre>
</div></div></div></body></html>





