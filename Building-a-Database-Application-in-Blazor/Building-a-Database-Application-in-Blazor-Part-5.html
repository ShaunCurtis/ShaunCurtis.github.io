<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<base href="/">

	

	

	
	<link href="/resources/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
	<link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">

	
	<link href="/resources/css/sb-admin-2.css" rel="stylesheet" type="text/css">
	<link href="/resources/css/site.css" rel="stylesheet" type="text/css">

	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
	<link rel="stylesheet" href="/resources/css/article.css" type="text/css">

	
	<link rel="icon" href="/images/favicon.png">

	<title>View Components - CRUD List Operations in the UI</title>
        <meta property="author" content="Shaun Curtis" />
        <meta property="description" content="This article looks in detail at building reusable List Presentation Layer components and deploying them in both Server and WASM projects." />
    <meta property="og:site_name" content="Cold Elm Coders" />
        <meta property="og:site" content="https://shauncurtis.github.io/" />
        <meta property="og:title" content="View Components - CRUD List Operations in the UI" />
        <meta property="og:description" content="This article looks in detail at building reusable List Presentation Layer components and deploying them in both Server and WASM projects." /></head>
<body><header class="navbar bg-dark p-2 text-large text-light"><section class="navbar-section  text-light"><a href="/" class="navbar-brand mr-2 text-large text-light p-2">Cold Elm Coders</a>
			<a href="/Posts" class="btn btn-link text-light">Posts</a>
			<a href="/Rants" class="btn btn-link text-light">Rants</a>
			<a href="/Articles" class="btn btn-link text-light">Articles</a>
			<a href="/Stories" class="btn btn-link text-light">Stories</a>
			<a href="/about.html" class="btn btn-link text-light">About</a></section></header>

	<div class="container-fluid"><div class="row"><div class="col-12 col-sm-3 col-lg-2 bg-light pt-2"><div class="article-info p-2"><div class="mb-2">Published: 07-Jul-2021</div>
                <div class="mb-2">Updated: 07-Jul-2021</div>
                <div class="mb-2">Author: Shaun Curtis</div></div>
    <h4 class="p-2">Table of Contents</h4>
<ul class="TOC" >
<li class="TOC-item TOC-item-0" >
<a class="TOC-link" href="#">Top</a>
<ul class="TOC TOC-0" >
<li class="TOC-item TOC-item-1" >
<ul class="TOC TOC-1" >
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#repository-and-database">Repository and Database</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#list-functionality">List Functionality</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-base-forms">The Base Forms</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#wrap-up">Wrap Up</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#history">History</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
			
			<div class="col-12 col-sm-9 col-lg-10 p-2"><div class="pt-2 pb-2 border-bottom mb-4 text-primary"><h1>View Components - CRUD List Operations in the UI</h1>
            <div><small>This article looks in detail at building reusable List Presentation Layer components and deploying them in both Server and WASM projects.</small></div></div>
    <div class="mb-2"><h3>Document List</h3>
        <ul><li><a href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-1.html">Project Structure and Framework</a></li><li><a href="/Stories/Building-a-Database-Application-in-Blazor/Index.html">Building a Database Application in Blazor</a></li><li><a href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-2.html">Building the Services</a></li><li><a href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-3.html">Building Edit and View UI Components</a></li><li><a href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-4.html">Building thw UI Components</a></li><li><a href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-5.html">View Components - CRUD List Operations in the UI</a></li></ul></div>
    <div class="md-danger">
        This set of articles and code base is out of date. They don't reflect my current framework. Use them at your risk.
    </div>
    <p>This article is the fifth in a series on Building Blazor Database Applications. The articles so far are:</p>
<ol>
<li>Project Structure and Framework.</li>
<li>Services - Building the CRUD Data Layers.</li>
<li>View Components - CRUD Edit and View Operations in the UI.</li>
<li>UI Components - Building HTML/CSS Controls.</li>
<li>View Components - CRUD List Operations in the UI.</li>
</ol>
<p>This article looks in detail at building reusable List UI components and deploying them in both Server and WASM projects.</p>
<h2 id="repository-and-database">Repository and Database</h2>
<p>The repository for the articles has moved to <a href="https://github.com/ShaunCurtis/Blazor.Database">Blazor.Database Repository</a>.  All previous repos are obselete and will be removed shortly.</p>
<p>There's a SQL script in /SQL in the repository for building the database.</p>
<p>The demo site has changed now the Server and WASM have been combined.  The site starts in Server mode - <a href="https://cec-blazor-database.azurewebsites.net/">https://cec-blazor-database.azurewebsites.net/</a>.</p>
<h2 id="list-functionality">List Functionality</h2>
<p>List components present more challenges than other CRUD components.  Functionality expected in a production level list control includes:</p>
<ul>
<li>Paging -  to handle large data sets</li>
<li>Column formatting - to control column width and data overflow</li>
<li>Sorting - on columns</li>
<li>Filtering - not covered here.</li>
</ul>
<h2 id="the-base-forms">The Base Forms</h2>
<p><code>ListFormBase</code> is the base abstract form for all lists. It inherits from <code>ComponentBase</code>, and contains all the boilerplate code.  <code>TRecord</code> is the dataclass it operates on.  The form uses the</p>
<p>The code is shown below</p>
<pre><code class="language-csharp">public abstract class ListFormBase&lt;TRecord&gt; : ComponentBase, IDisposable
    where TRecord : class, IDbRecord&lt;TRecord&gt;, new()
{
    [Parameter] public EventCallback&lt;Guid&gt; EditRecord { get; set; }
    [Parameter] public EventCallback&lt;Guid&gt; ViewRecord { get; set; }
    [Parameter] public EventCallback&lt;Guid&gt; NewRecord { get; set; }
    [Parameter] public EventCallback ExitAction { get; set; }

    [Inject] protected NavigationManager NavManager { get; set; }
    [Inject] protected EditStateService EditStateService { get; set; }

    protected IModelViewService&lt;TRecord&gt; Service { get; set; }
    protected bool IsLoaded =&gt; this.Service?.HasRecords ?? false;
    protected ComponentState LoadState =&gt; IsLoaded ? ComponentState.Loaded : ComponentState.Loading;
    protected bool HasService =&gt; this.Service != null;
    protected override async Task OnInitializedAsync()
    {
        if (HasService)
        {
            await this.Service.GetRecordsAsync();
            this.Service.ListHasChanged += OnListChanged;
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (this.EditStateService.IsDirty)
            this.Edit((Guid)this.EditStateService.RecordID);
    }

    protected void OnListChanged(object sender, EventArgs e)
        =&gt; this.InvokeAsync(this.StateHasChanged);

    protected virtual void Edit(Guid id)
        =&gt; this.EditRecord.InvokeAsync(id);

    protected virtual void View(Guid id)
        =&gt; this.ViewRecord.InvokeAsync(id);

    protected virtual void New()
        =&gt; this.NewRecord.InvokeAsync();

    protected virtual void Exit()
    {
        if (ExitAction.HasDelegate)
            ExitAction.InvokeAsync();
        else
            this.NavManager.NavigateTo(&quot;/&quot;);
    }

    public void Dispose()
        =&gt; this.Service.ListHasChanged -= OnListChanged;

}
</code></pre>
<h3 id="paging-and-sorting">Paging and Sorting</h3>
<p>Paging and sorting is implemented by a <code>RecordPager</code> class that is part of the ViewService.  <code>DataPagingControl</code> and <code>SortControl</code> are UI components that interact with the <code>RecordPager</code>.</p>
<p>You can see <code>DataPagingControl</code> in use in a list form - here in the left side of a button row at the bottom of the form</p>
<pre><code class="language-csharp">&lt;UIContainer&gt;
    &lt;UIFormRow&gt;
        &lt;UIColumn Cols=&quot;8&quot;&gt;
            &lt;DataPagingControl RecordPager=&quot;this.ViewService.RecordPager&quot;&gt;&lt;/DataPagingControl&gt;
        &lt;/UIColumn&gt;
        &lt;UIButtonColumn Cols=&quot;4&quot;&gt;
            &lt;UIButton type=&quot;button&quot; Show=&quot;true&quot; class=&quot;btn-success&quot; ClickEvent=&quot;() =&gt; this.New()&quot;&gt;New Record&lt;/UIButton&gt;
            &lt;UIButton type=&quot;button&quot; class=&quot;btn-secondary&quot; ClickEvent=&quot;this.Exit&quot;&gt;Exit&lt;/UIButton&gt;
        &lt;/UIButtonColumn&gt;
    &lt;/UIFormRow&gt;
&lt;/UIContainer&gt;
</code></pre>
<p>And <code>SortControl</code> in action in the header row of a list form.</p>
<pre><code class="language-csharp">&lt;head&gt;
    &lt;SortControl RecordPager=&quot;this.Service.RecordPager&quot;&gt;
        &lt;UIDataTableHeaderColumn SortField=&quot;ID&quot;&gt;ID&lt;/UIDataTableHeaderColumn&gt;
        &lt;UIDataTableHeaderColumn SortField=&quot;Date&quot;&gt;Date&lt;/UIDataTableHeaderColumn&gt;
        ...
    &lt;/SortControl&gt;
&lt;/head&gt;
</code></pre>
<h4 id="recordpager">RecordPager</h4>
<p>The code is self explanatory, providing the functionality for paging operations.  The imnportant concept to understand is that internally page and block positions are tracked on zero based indexes, while what gets displayed is one based.  Page 0 internally is displayed as 1 to the user.</p>
<pre><code class="language-csharp">    public class RecordPager
    {
        public int DisplayPage =&gt; this.Page + 1;
        public int DisplayLastPage =&gt; this.LastPage + 1;
        public int DisplayLastBlock =&gt; this.LastBlock + 1;
        public int DisplayStartBlockPage =&gt; this.StartBlockPage + 1;
        public int DisplayEndBlockPage =&gt; this.EndBlockPage + 1;

        public bool Enabled { get; set; }
        public int Page { get; private set; } = 0;
        public int RecordCount { get; set; } = 0;
        public int PageSize { get; set; } = 10;
        public int BlockSize { get; set; } = 5;

        public string DefaultSortColumn { get; set; } = &quot;ID&quot;;
        public bool Sort { get; set; }
        public bool SortDescending { get; set; }

        public int Block
        {
            get
            {
                var block = (int)Math.Floor((Decimal)(this.Page / this.BlockSize));
                return block &lt; this.LastBlock ? block : LastBlock;
            }
        }

        public int LastPage =&gt; ((int)Math.Floor((Decimal)((RecordCount - 1) / PageSize))) - 1;
        public int LastBlock =&gt; (int)Math.Floor((Decimal)(this.LastPage / this.BlockSize));
        public int StartBlockPage =&gt; (Block * BlockSize);
        public int EndBlockPage =&gt; (StartBlockPage + (BlockSize - 1)) &gt; LastPage ? LastPage : StartBlockPage + (BlockSize - 1);
        public bool HasBlocks =&gt; this.LastPage &gt; BlockSize;
        public bool HasPagination =&gt; this.RecordCount &gt; PageSize;

        public string SortColumn
        {
            get =&gt; (!string.IsNullOrWhiteSpace(_sortColumn)) ? _sortColumn : DefaultSortColumn;
            set =&gt; _sortColumn = value;
        }

        private string _sortColumn = string.Empty;

        public RecordPagingData PagingData =&gt; new RecordPagingData()
        {
            Page = this.Page,
            PageSize = this.PageSize,
            Sort = this.Sort,
            SortColumn = this.SortColumn,
            SortDescending = this.SortDescending
        };

        public event EventHandler PageChanged;

        public bool ToPage(int page, bool forceUpdate = false)
        {
            var move = (forceUpdate | !this.Page.Equals(page)) &amp;&amp; page &gt;= 0;
            if (move)
            {
                this.Page = page;
                this.PageChanged?.Invoke(this, EventArgs.Empty);
            }
            return move;
        }

        public bool PageMove(int pages)
        {
            var move = this.Page + pages &lt;= this.LastPage &amp;&amp; this.Page + pages &gt;= 0;
            if (move)
                this.ToPage(this.Page + pages);
            return move;
        }

        public bool BlockMove(int blocks)
        {
            var move = this.Block + blocks &lt;= this.LastBlock &amp;&amp; this.Block + blocks &gt;= 0;
            if (move)
                this.ToPage((this.Block + blocks) * BlockSize);
            return move;
        }

        public void NotifySortingChanged()
           =&gt; this.ToPage(1, true);
    }
</code></pre>
<h4 id="recordpagingdata">RecordPagingData</h4>
<p>This is the class used to pass data into the dats services.  This has to be passed via json though the api so &quot;keep it simple&quot;. Again it's zero based indexing.</p>
<pre><code class="language-csharp">    public class RecordPagingData
    {
        public int Page { get; set; } = 0;
        public int PageSize { get; set; } = 25;
        public string SortColumn { get; set; } = string.Empty;
        public bool Sort { get; set; } = false;
        public bool SortDescending { get; set; } = false;
        public int StartRecord =&gt; this.Page * this.PageSize;
    }
</code></pre>
<h4 id="datapagingcontrol">DataPagingControl</h4>
<p>The code again is self-explanatory, building out a Bootstrap ButtonGroup.  I've kept away from using icons, you can if you wish.</p>
<pre><code class="language-html">@namespace Blazr.SPA.Components

@if (this.hasPagination)
{
    &lt;nav aria-label=&quot;...&quot;&gt;
        &lt;ul class=&quot;pagination&quot;&gt;
            &lt;li class=&quot;page-item&quot;&gt;
                &lt;a class=&quot;page-link cursor-hand&quot; @onclick=&quot;() =&gt; this.RecordPager.ToPage(0)&quot;&gt;&amp;vert;&amp;lt;&lt;/a&gt;
            &lt;/li&gt;
            @if (this.RecordPager.HasBlocks)
            {
                &lt;li class=&quot;page-item&quot;&gt;
                    &lt;a class=&quot;page-link cursor-hand&quot; @onclick=&quot;() =&gt; this.RecordPager.BlockMove(-1)&quot;&gt;&amp;lt;&amp;lt;&lt;/a&gt;
                &lt;/li&gt;
            }
            @for (var i = this.RecordPager.DisplayStartBlockPage; i &lt;= this.RecordPager.DisplayEndBlockPage; i++)
            {
                var displayPageNo = i;
                var pageNo = i - 1;
                @if (displayPageNo &gt; this.RecordPager.DisplayLastPage) break;
                @if (displayPageNo == this.RecordPager.DisplayPage)
                {
                    &lt;li class=&quot;page-item active&quot;&gt;
                        &lt;span class=&quot;page-link cursor-hand&quot;&gt;
                            @displayPageNo
                            &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;
                        &lt;/span&gt;
                    &lt;/li&gt;
                }
                else
                {
                    &lt;li class=&quot;page-item&quot;&gt;
                        &lt;a class=&quot;page-link cursor-hand&quot; @onclick=&quot;() =&gt; this.RecordPager.ToPage(pageNo)&quot;&gt;@displayPageNo&lt;/a&gt;
                    &lt;/li&gt;
                }

            }
            @if (this.RecordPager.HasBlocks)
            {
                &lt;li class=&quot;page-item&quot;&gt;
                    &lt;a class=&quot;page-link cursor-hand&quot; @onclick=&quot;() =&gt; this.RecordPager.BlockMove(1)&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;
                &lt;/li&gt;
            }
            &lt;li class=&quot;page-item&quot;&gt;
                &lt;a class=&quot;page-link cursor-hand&quot; @onclick=&quot;() =&gt; this.RecordPager.ToPage(this.RecordPager.LastPage)&quot;&gt;&amp;gt;&amp;vert;&lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/nav&gt;
}

@code {
    [Parameter] public RecordPager RecordPager { get; set; }

    private bool hasPagination =&gt; this.RecordPager != null &amp;&amp; this.RecordPager.HasPagination;
}
</code></pre>
<h4 id="sortcontrol">SortControl</h4>
<p>The <code>SortControl</code> is used in a list header. It cascades itself and provides the interface into the Paginator for the header columns through a set of public helper methods.</p>
<pre><code class="language-csharp">@namespace Blazor.SPA.Components

&lt;CascadingValue Value=&quot;this&quot;&gt;
    @ChildContent
&lt;/CascadingValue&gt;

@code {

    [Parameter] public RenderFragment ChildContent { get; set; }
    [Parameter] public string NotSortedClass { get; set; } = &quot;sort-column oi oi-resize-height&quot;;
    [Parameter] public string AscendingClass { get; set; } = &quot;sort-column oi oi-sort-ascending&quot;;
    [Parameter] public string DescendingClass { get; set; } = &quot;sort-column oi oi-sort-descending&quot;;
    [Parameter] public EventCallback&lt;SortingEventArgs&gt; Sort { get; set; }
    [Parameter] public RecordPager RecordPager { get; set; }
    public string SortColumm { get; private set; } = string.Empty;
    public bool Descending { get; private set; } = false;

    public string GetIcon(string columnName)
        =&gt; !this.SortColumm.Equals(columnName)
        ? this.NotSortedClass
        : this.Descending
            ? this.AscendingClass
            : this.DescendingClass;

    public void NotifySortingChanged(string sortColumn, bool descending = false)
    {
        this.SortColumm = sortColumn;
        this.Descending = descending;
        this.Notify();
    }

    public void NotifySortingDirectionChanged()
    {
        this.Descending = !this.Descending;
        this.Notify();
    }

    private void Notify()
    {
        if (RecordPager != null)
            {
            RecordPager.SortDescending = this.Descending;
            RecordPager.SortColumn = this.SortColumm;
            RecordPager.NotifySortingChanged();
            }
        var args = SortingEventArgs.Get(this.SortColumm, this.Descending);
        if (Sort.HasDelegate) this.Sort.InvokeAsync(args);
    }
}
</code></pre>
<h4 id="uilistcolumn">UIListColumn</h4>
<p>This is the UI control that builds out either the header or data rows.</p>
<pre><code class="language-html">@namespace Blazr.UIComponents
@inherits UIComponentBase

@if (this.IsHeader)
{
    &lt;th class=&quot;@this.HeaderCSS&quot;&gt;
        @((MarkupString)this.HeaderTitle)
    &lt;/th&gt;
}
else if (this.isMaxRowColumn)
{
    &lt;td class=&quot;max-column&quot; @attributes=&quot;this.SplatterAttributes&quot;&gt;
        &lt;div class=&quot;grid-overflow&quot;&gt;
            &lt;div class=&quot;grid-overflowinner&quot;&gt;
                @ChildContent
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/td&gt;
}
else
{
    &lt;td class=&quot;data-column&quot; @attributes=&quot;this.SplatterAttributes&quot;&gt;
        @this.ChildContent
    &lt;/td&gt;
}
</code></pre>
<p><em>UIListColumn.razor.cs</em>:</p>
<pre><code class="language-csharp">using Blazr.SPA.Components;
using Microsoft.AspNetCore.Components;
using System.Collections.Generic;

namespace Blazr.UIComponents
{
    public partial class UIListColumn : UIComponentBase
    {
        [CascadingParameter(Name = &quot;IsHeader&quot;)] public bool IsHeader { get; set; }
        [Parameter] public bool IsMaxColumn { get; set; }
        [Parameter] public string HeaderTitle { get; set; }
        [Parameter] public bool IsHeaderNoWrap { get; set; }

        private bool isMaxRowColumn =&gt; IsMaxColumn &amp;&amp; !this.IsHeader;
        private bool isNormalRowColumn =&gt; !IsMaxColumn &amp;&amp; !this.IsHeader;
        protected override List&lt;string&gt; UnwantedAttributes { get; set; } = new List&lt;string&gt;() { &quot;class&quot; };

        private string HeaderCSS
            =&gt; CSSBuilder.Class()
                .AddClass(&quot;header-column-nowrap&quot;, &quot;header-column&quot;, IsHeaderNoWrap)
                .AddClass(&quot;align-baseline&quot;)
                .Build();
    }
}
</code></pre>
<p><em>UIListColumn.razor.css</em>:</p>
<pre><code class="language-css">.data-column {
    max-width: 30%;
}

.max-column {
    width: 50%;
}

.grid-overflow {
    display: flex;
}

.grid-overflowinner {
    flex: 1;
    width: 1px;
    overflow-x: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}

.header-column-nowrap {
    white-space: nowrap;
}
</code></pre>
<h4 id="uilistcontrol">UIListControl</h4>
<p>This control builds out the list</p>
<pre><code class="language-html">@namespace Blazr.UIComponents
@inherits UIComponentBase
@typeparam TRecord

@if (this.LoadState == ComponentState.Loaded &amp;&amp; this.HasRecords)
{
    &lt;table @attributes=&quot;this.SplatterAttributes&quot;&gt;
        &lt;thead&gt;
            &lt;CascadingValue Name=&quot;IsHeader&quot; Value=&quot;true&quot;&gt;
                &lt;tr&gt;
                    @RowTemplate(default(TRecord))
                &lt;/tr&gt;
            &lt;/CascadingValue&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            @foreach (var item in this.Records)
            {
                &lt;tr&gt;
                    @RowTemplate(item)
                &lt;/tr&gt;
            }
        &lt;/tbody&gt;
    &lt;/table&gt;
}
else if (this.LoadState == ComponentState.Loaded)
{
    &lt;div class=&quot;alert alert-warning&quot;&gt;
        No Records to Display
    &lt;/div&gt;
}
else if (this.LoadState == ComponentState.Loading)
{
    &lt;div class=&quot;m-2 p-2&quot;&gt;Loading...&lt;/div&gt;
}
else
{
    &lt;div class=&quot;alert alert-danger&quot;&gt;
        Error Loading the List
    &lt;/div&gt;
}
</code></pre>
<pre><code class="language-csharp">@code {
    [Parameter] public ComponentState LoadState { get; set; }
    [Parameter] public RenderFragment&lt;TRecord&gt; RowTemplate { get; set; }
    [Parameter] public IEnumerable&lt;TRecord&gt; Records { get; set; }
    private bool HasRecords =&gt; Records.Count() &gt; 0;

}
</code></pre>
<h3 id="weather-forecast-list-forms">Weather Forecast List Forms</h3>
<p>There are three list forms in the solution.  They demonstrate different UI approaches.</p>
<ol>
<li>The classic web page approach using different RouteViews (Pages) for the record viewer and editor.</li>
<li>The modal dialog approach - opening and closing modal dialogs within the list RouteView.</li>
<li>The inline dialog approach - opening and closing a section within the RouteView to display/edit the record.</li>
</ol>
<p>The standard <code>WeatherForecastListForm</code> looks like this.  It inherits from <code>ListFormBase</code> with <code>WeatherForecast</code> as <code>TRecord</code>.  It assigns the <code>WeatherForecastViewService</code> to the base <code>IModelViewService</code> property <code>Service</code>.  Note it has a component Css file defining the custom Css used in the component.</p>
<pre><code class="language-csharp">// Blazor.Database/Forms/WeatherForecast/WeatherForecastListForm.razor.cs
public partial class WeatherForecastListForm : ListFormBase&lt;WeatherForecast&gt;
{
    [Inject] private WeatherForecastViewService ViewService { get; set; }
    [Parameter] public bool IsModal { get; set; }

    private BaseModalDialog Modal { get; set; }

    protected override async Task OnInitializedAsync()
    {
        this.Service = this.ViewService;
        await base.OnInitializedAsync();
    }
    protected override async void Edit(Guid id)
    {
        if (this.IsModal)
        {
            var options = new ModalOptions();
            options.Set(&quot;Id&quot;, id);
            await this.Modal.ShowAsync&lt;WeatherForecastEditorForm&gt;(options);
        }
        else
            base.Edit(id);
    }
    protected override async void View(Guid id)
    {
        if (this.IsModal)
        {
            var options = new ModalOptions();
            options.Set(&quot;Id&quot;, id);
            await this.Modal.ShowAsync&lt;WeatherForecastViewerForm&gt;(options);
        }
        else
            base.View(id);
    }

    protected override async void New()
    {
        if (this.IsModal)
        {
            var options = new ModalOptions();
            options.Set(&quot;Id&quot;, -1);
            await this.Modal.ShowAsync&lt;WeatherForecastEditorForm&gt;(options);
        }
        else
            base.New();
    }
}
</code></pre>
<p>The razor markup.  Note:</p>
<ol>
<li>The <code>SortControl</code> in the header and the <code>UIListColumn</code> components building the header with the sortable columns.</li>
<li>The <code>DataPagingControl</code> in the botton button row linked to the <code>Service.RecordPager</code>.  Paging is event driven.  <code>DataPagingControl</code> paging requests are handled directly by <code>RecordPager</code> in the controller service.  Updates trigger a <code>ListChanged</code> event in the service which triggers a UI update in the List Form.</li>
<li>The <code>BaseModalDialog</code> added if the Form is using Modal Dialogs.</li>
</ol>
<pre><code class="language-html">@namespace Blazor.Database.Forms
@inherits ListFormBase&lt;WeatherForecast&gt;

&lt;h1&gt;Weather Forecasts&lt;/h1&gt;

&lt;UIListControl TRecord=&quot;WeatherForecast&quot; Records=&quot;this.ViewService.Records&quot; LoadState=&quot;this.LoadState&quot; class=&quot;table&quot;&gt;
    &lt;RowTemplate&gt;
        &lt;UIListColumn HeaderTitle=&quot;Date&quot;&gt;@context.Date.LocalDateTime.ToShortDateString()&lt;/UIListColumn&gt;
        &lt;UIListColumn HeaderTitle=&quot;Temp &amp;deg; C&quot;&gt;@context.TemperatureC&lt;/UIListColumn&gt;
        &lt;UIListColumn HeaderTitle=&quot;Temp &amp;deg; F&quot;&gt;@context.TemperatureF&lt;/UIListColumn&gt;
        &lt;UIListColumn HeaderTitle=&quot;Summary&quot;&gt;@context.Summary&lt;/UIListColumn&gt;
        &lt;UIListColumn HeaderTitle=&quot;Detail&quot; IsMaxColumn=&quot;true&quot;&gt;@context.Description&lt;/UIListColumn&gt;
        &lt;UIListColumn HeaderTitle=&quot;Edit/View&quot;&gt;
            &lt;UIButton type=&quot;button&quot; class=&quot;btn-sm btn-secondary&quot; ClickEvent=&quot;() =&gt; this.View(context.ID)&quot;&gt;View&lt;/UIButton&gt;
            &lt;UIButton type=&quot;button&quot; class=&quot;btn-sm btn-primary&quot; ClickEvent=&quot;() =&gt; this.Edit(context.ID)&quot;&gt;Edit&lt;/UIButton&gt;
        &lt;/UIListColumn&gt;
    &lt;/RowTemplate&gt;
&lt;/UIListControl&gt;
&lt;UIContainer&gt;
    &lt;UIFormRow&gt;
        &lt;UIColumn Cols=&quot;8&quot;&gt;
            &lt;DataPagingControl RecordPager=&quot;this.ViewService.RecordPager&quot;&gt;&lt;/DataPagingControl&gt;
        &lt;/UIColumn&gt;
        &lt;UIButtonColumn Cols=&quot;4&quot;&gt;
            &lt;UIButton type=&quot;button&quot; Show=&quot;true&quot; class=&quot;btn-success&quot; ClickEvent=&quot;() =&gt; this.New()&quot;&gt;New Record&lt;/UIButton&gt;
            &lt;UIButton type=&quot;button&quot; class=&quot;btn-secondary&quot; ClickEvent=&quot;this.Exit&quot;&gt;Exit&lt;/UIButton&gt;
        &lt;/UIButtonColumn&gt;
    &lt;/UIFormRow&gt;
&lt;/UIContainer&gt;
@if (this.IsModal)
{
    &lt;BaseModalDialog @ref=&quot;this.Modal&quot;&gt;&lt;/BaseModalDialog&gt;
}
</code></pre>
<h3 id="the-views">The Views</h3>
<p>The application declares a set of intermediate Views for the list forms.  These are common to both the WASM and Server SPAs</p>
<h4 id="fetchdata">FetchData</h4>
<p>This is the multi RouteView implementation.  Event handlers are hooked up <code>WeatherForecastListForm</code> to route to the different RouteViews through the <code>NavigationManager</code>.</p>
<pre><code class="language-html">@page &quot;/fetchdata&quot;
@namespace Blazor.Database.RouteViews

&lt;WeatherForecastListForm EditRecord=&quot;this.GoToEditor&quot; ViewRecord=&quot;this.GoToViewer&quot; NewRecord=&quot;this.GoToNew&quot; ExitAction=&quot;Exit&quot;&gt;&lt;/WeatherForecastListForm&gt;

@code {

    [Inject] NavigationManager NavManager { get; set; }

    private bool _isWasm =&gt; NavManager?.Uri.Contains(&quot;wasm&quot;, StringComparison.CurrentCultureIgnoreCase) ?? false;

    public void GoToEditor(Guid id)
    =&gt; this.NavManager.NavigateTo($&quot;weather/edit/{id}&quot;);

    public void GoToNew()
    =&gt; this.NavManager.NavigateTo($&quot;weather/edit/{Guid.Empty}&quot;);

    public void GoToViewer(Guid id)
    =&gt; this.NavManager.NavigateTo($&quot;weather/view/{id}&quot;);

    public void Exit()
    {
        if (_isWasm)
            this.NavManager.NavigateTo($&quot;/wasm&quot;);
        else
            this.NavManager.NavigateTo($&quot;/&quot;);
    }

}
</code></pre>
<h4 id="fetchdatamodal">FetchDataModal</h4>
<p>The modal implementation is simple.  It already handles editor/viewer state by enabling <code>IsModal</code>.  You don't really need it as you could declare <code>WeatherForecastListForm</code> directly in the RouteView.</p>
<pre><code class="language-html">@page &quot;/fetchdataModal&quot;
@namespace Blazor.Database.RouteViews

&lt;WeatherForecastListForm IsModal=&quot;true&quot;&gt;&lt;/WeatherForecastListForm&gt;
</code></pre>
<p>The inline dialog is the most complex.  It uses Ids to show/hide the Editor/Viewer through <code>UIComponent</code>.</p>
<pre><code class="language-html">@page &quot;/fetchdataInline&quot;

@namespace Blazor.Database.RouteViews

&lt;UIComponent Show=&quot;this.ShowEditor&quot;&gt;
    &lt;WeatherForecastEditorForm ID=&quot;this.editorId&quot; ExitAction=&quot;this.CloseDialog&quot;&gt;&lt;/WeatherForecastEditorForm&gt;
&lt;/UIComponent&gt;
&lt;UIComponent Show=&quot;this.ShowViewer&quot;&gt;
    &lt;WeatherForecastViewerForm ID=&quot;this.viewerId&quot; ExitAction=&quot;this.CloseDialog&quot;&gt;&lt;/WeatherForecastViewerForm&gt;
&lt;/UIComponent&gt;

&lt;WeatherForecastListForm EditRecord=&quot;this.GoToEditor&quot; ViewRecord=&quot;this.GoToViewer&quot; NewRecord=&quot;this.GoToNew&quot; ExitAction=&quot;Exit&quot;&gt;&lt;/WeatherForecastListForm&gt;
</code></pre>
<pre><code class="language-csharp">@code {

    [Inject] NavigationManager NavManager { get; set; }

    private Guid editorId = Guid.Empty;
    private Guid viewerId = Guid.Empty;

    private bool ShowViewer =&gt; this.viewerId != Guid.Empty;
    private bool ShowEditor =&gt; this.editorId != Guid.Empty;

    public void GoToEditor(Guid id)
        =&gt; SetIds(id, Guid.Empty);

    public void GoToNew()
        =&gt; SetIds(Guid.Empty, Guid.Empty);

    public void GoToViewer(Guid id)
        =&gt; SetIds(Guid.Empty, id);

    public void CloseDialog()
        =&gt; SetIds(Guid.Empty, Guid.Empty);

    public void Exit()
        =&gt; this.NavManager.NavigateTo(&quot;index&quot;);

    private void SetIds(Guid editorId, Guid viewerId)
    {
        this.editorId = editorId;
        this.viewerId = viewerId;
    }
}
</code></pre>
<h2 id="wrap-up">Wrap Up</h2>
<p>That wraps up this article.  Some key points to note:</p>
<ol>
<li>There's no differences between the Blazor Server and Blazor WASM code base.</li>
<li>90% plus functionality is implemented in the library components as boilerplate generic code.  Most of the application code is Razor markup for the individual record forms.</li>
<li>Async functionality is used throughout.</li>
</ol>
<p>Check the readme in the repository for the latest version of the article set.</p>
<h2 id="history">History</h2>
<ul>
<li>25-Sep-2020: Initial version.</li>
<li>17-Nov-2020: Major Blazor.CEC library changes.  Change to ViewManager from Router and new Component base implementation.</li>
<li>31-Mar-2021: Major updates to Services, project structure and data editing.</li>
<li>24-June-2021: revisions to data layers.</li>
</ul>
</div></div></div></body></html>





