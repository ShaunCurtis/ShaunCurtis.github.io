<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<base href="/">

	

	

	
	<link href="/resources/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
	<link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">

	
	<link href="/resources/css/sb-admin-2.css" rel="stylesheet" type="text/css">
	<link href="/resources/css/site.css" rel="stylesheet" type="text/css">

	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
	<link rel="stylesheet" href="/resources/css/article.css" type="text/css">

	
	<link rel="icon" href="/images/favicon.png">

	<title>Nullable in Visual Studio 2022</title>
        <meta property="author" content="Shaun Curtis" />
        <meta property="description" content="Notes about Nullable and breaking changes in Visual Studio 2022." />
    <meta property="og:site_name" content="Cold Elm Coders" />
        <meta property="og:site" content="https://shauncurtis.github.io/" />
        <meta property="og:title" content="Nullable in Visual Studio 2022" />
        <meta property="og:description" content="Notes about Nullable and breaking changes in Visual Studio 2022." /></head>
<body><header class="navbar bg-dark p-2 text-large text-light"><section class="navbar-section  text-light"><a href="/" class="navbar-brand mr-2 text-large text-light p-2">Cold Elm Coders</a>
			<a href="/Posts" class="btn btn-link text-light">Posts</a>
			<a href="/Rants" class="btn btn-link text-light">Rants</a>
			<a href="/Articles" class="btn btn-link text-light">Articles</a>
			<a href="/Stories" class="btn btn-link text-light">Stories</a>
			<a href="/about.html" class="btn btn-link text-light">About</a></section></header>

	<div class="container-fluid"><div class="row"><div class="col-12 col-sm-3 col-lg-2 bg-light pt-2"><div class="article-info p-2"><div class="mb-2">Published: 27-Nov-2021</div>
                <div class="mb-2">Updated: 27-Nov-2021</div>
                <div class="mb-2">Author: Shaun Curtis</div></div>
    <h4 class="p-2">Table of Contents</h4>
<ul class="TOC" >
<li class="TOC-item TOC-item-0" >
<a class="TOC-link" href="#">Top</a>
<ul class="TOC TOC-0" >
<li class="TOC-item TOC-item-1" >
<ul class="TOC TOC-1" >
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#visual-studio-2022">Visual Studio 2022</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#simple-nullable">Simple Nullable</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#nullable-detection">Nullable Detection</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#edge-case">Edge Case</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#real-world-edge-case">Real World Edge Case</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#breaking-the-rules">Breaking The Rules</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#null-coalescing">Null Coalescing</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#some-observations-and-suggestions">Some Observations and Suggestions</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
			
			<div class="col-12 col-sm-9 col-lg-10 p-2"><div class="pt-2 pb-2 border-bottom mb-4 text-primary"><h1>Nullable in Visual Studio 2022</h1>
            <div><small>Notes about Nullable and breaking changes in Visual Studio 2022.</small></div></div>
    <p>Nulls have always presented programming challenges.</p>
<p>To define a null, I'll quote MS-Docs:</p>
<blockquote>
<p>The null keyword is a literal that represents a null reference, one that does not refer to any object. null is the default value of reference-type variables. Ordinary value types cannot be null, except for nullable value types.</p>
</blockquote>
<p>C# 8 introduced nullable reference types.  A system where reference types could no longer be null unless explicitly declared with the <code>?</code> operator.</p>
<pre><code class="language-csharp">// not nullable fields/properties must be assigned a value
string notNullableValue = string.Empty;

string? NullableValue; 

// nullable is controlled by the return value from the method 
var value = SomeMethod();
</code></pre>
<p>For many programmers this had no consequences because the project templates by default did not enable <em>Nullable</em>.  We sailed on serenely in ignorance.</p>
<p>With <em>Nullable</em> enabled the compiler throws warnings whenever it considers you've broken the rules.  It's pretty good, but there are certain circumstances where you want to break the rules, and edge cases where it gets things wrong.  We'll look at both of those later.</p>
<h2 id="visual-studio-2022">Visual Studio 2022</h2>
<p>Visual Studio 2022 moved the goalposts: <code>Nullable</code> is now enabled by default.  Here's the project file for a console app:</p>
<pre><code class="language-xml">  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
  &lt;/PropertyGroup&gt;
</code></pre>
<p>You now have to explicitly disable it.  Write code the old way, or import existing code and unless you were a miracle coder,  you will see a lot of null code warnings and errors.  It has certainly impacted my coding style and practices.</p>
<p>Let's look at some code to see what I mean.</p>
<h2 id="simple-nullable">Simple Nullable</h2>
<p>Here's some simple old style code.</p>
<pre><code class="language-csharp">string value;

value = getHello(0);

Console.WriteLine(value);

string getHello(int test)
    =&gt;  test == 1
        ? &quot;Hello World&quot;
        : null;
</code></pre>
<p>Disable Nullable and this code flies: no exceptions or warnings.  So what's the problem?</p>
<p>String can be a null, so we can pass null strings around.  Unless we explicitly check, we don't know if <code>Console.WriteLine</code> handles nulls correctly.  If it doesn't we will get an exception when we pass it a null.  Everything flies because <code>Console.WriteLine</code> knows how to handle nulls.  It's definition looks like this:</p>
<pre><code class="language-csharp">Console.WriteLine(string? value) 
</code></pre>
<p>Enable Nullable and we see a warning - <em>Possible Null Reference Return</em> on <code>getHello</code>.  Why?</p>
<ol>
<li><code>getHello</code> declares it's return value as <code>string</code>.  No <code>?</code> and therefore not nullable, yet in the body we can return <code>null</code>.</li>
<li><code>string value</code> also declares <code>value</code> as not nullable.</li>
</ol>
<p>To fix this:</p>
<pre><code class="language-csharp">string? value;

value = getHello(0);

Console.WriteLine(value);

string? getHello(int test)
    =&gt;  test == 1
        ? &quot;Hello World&quot;
        : null;
</code></pre>
<p>We've added the nullable <code>?</code> operator to <code>value</code> and the return declaration of <code>getHello</code>.</p>
<p>We're now declaring and handling nullables correctly and the compiler is happy,</p>
<h2 id="nullable-detection">Nullable Detection</h2>
<p>Our new block of code</p>
<pre><code class="language-csharp">string? value;

var sometest = true;

value = sometest
        ? &quot;Hello World&quot;
        : &quot;Bye World&quot;;

WriteLine(value);

value = sometest
        ? &quot;Hello World&quot;
        : null;

// Get a possible null warning
WriteLine(value);

void WriteLine(string value)
    =&gt; Console.WriteLine(value);
</code></pre>
<p>We have our own <code>WriteLine</code> method with a <em>not nullable</em> string argument.  note that we only get a compiler warning after yhe second assignment to value where we try and assign a <code>null</code>.  The compiler is analysing the code, seeing a possble null and throwing a warning.</p>
<p>We fix this by changing <code>WriteLne</code> to accept a nullable string.  The compiler knows <code>Console.WriteLine</code> accepts nullable strings so everything is good.</p>
<pre><code class="language-csharp">void WriteLine(string? value)
    =&gt; Console.WriteLine(value);
</code></pre>
<h2 id="edge-case">Edge Case</h2>
<p>The contrived code below illustrates one common problem.  We know once we've called <code>GetAsync</code> and assigned <code>value</code> it can't be null because we throw an error if it is.  However, the analyser isn't that clever so still throws the warning.</p>
<pre><code class="language-csharp">string? value = null;

var myClass = new MyClass();

await myClass.GetAsync();

value = myClass.Value;

// We know it's safe to pass Value because it can't be null
// but the code doesn't so still throws a warning
WriteLine(value);

void WriteLine(string value)
    =&gt; Console.WriteLine(value);

class MyClass
{
    public string? Value { get; set; }

    public async Task GetAsync()
    {
        await Task.Yield();
        // Get the value from a service
        this.Value = &quot;Hello World&quot;;
        if (this.Value is null)
            throw new ArgumentNullException(&quot;Value is null and shouldn't be!&quot;);
    }
}
</code></pre>
<p>We can suppress these messages using the ! null forgiving operator.  In the code above, the correct place to apply it is where the assignment takes place.</p>
<pre><code class="language-csharp">value = myClass.Value!;
</code></pre>
<p>Don't apply it to where it's being used.</p>
<pre><code class="language-csharp">WriteLine(value!);
</code></pre>
<p>Two notes:</p>
<blockquote>
<p>Don't use it unless you have to.  Use null coalesing - covered below - wherever you can.</p>
</blockquote>
<blockquote>
<p>The null forgiving operator has no effect in compilation.  It's just a succinct message from the programmer to the compiler/interpreter saying &quot;No worries mate, bin the warnings, I've got it covered!&quot;.</p>
</blockquote>
<h2 id="real-world-edge-case">Real World Edge Case</h2>
<p>The example above may be contrived, but consider the following code from a Blazor page.</p>
<pre><code class="language-csharp">[Inject] MyService? myService { get; set; }

void DoSomething()
{
    // nullable warning on myService
    var value = myService.Value;
}
</code></pre>
<p>Blazor ensures <code>MyService</code> is registered: it throws an exception if it isn't.  We could code:</p>
<pre><code class="language-csharp">[Inject] MyService myService { get; set; } = new MyService();
</code></pre>
<p>Which works, but is just <em>wrong</em>.  We're creating an object for a contrived reason, and it's absolutely useless created outside the DI container context.</p>
<p>We could use null forgiving when we use the object, which is ok when you use ut once, but say you use the service ten times in you code block, it doesn't seem right.</p>
<p>My current best solution is to use a local variable in a code block like this:</p>
<pre><code class="language-csharp">    void DoSomething()
    {
        MyService service = myService!;
        var value = service.Value;
        ....
    }
</code></pre>
<h2 id="breaking-the-rules">Breaking The Rules</h2>
<p>Not often, but testing is one area where you may break the rules to test null handling and boundary conditions.</p>
<h2 id="null-coalescing">Null Coalescing</h2>
<p>The normal approach to the &quot;boxing&quot; problem of switching from nullable to non nullable is to use null coalescing <code>??</code>.</p>
<p>We can use it on  <code>Writeline</code> like this.  <code>Writeline</code> now receives <code>value</code> if it isn't <code>null</code>, or <code>string,Empty</code> if it is.</p>
<pre><code class="language-csharp">WriteLine(value ?? string.Empty);
</code></pre>
<p>We can also use the very useful null coalescing assignment operator <code>??=</code> like this whenever we need to make sure a value isn't null:</p>
<pre><code class="language-csharp">value ??= string.Empty;
WriteLine(value);
</code></pre>
<p>More succinct than:</p>
<pre><code class="language-csharp">if (value is null)
{
    value = string.Empty;
}
</code></pre>
<h2 id="some-observations-and-suggestions">Some Observations and Suggestions</h2>
<ol>
<li>Don't chicken out, leave <strong>Nullable</strong> enabled.</li>
<li>A lot of null checking code becomes obselete by ensuring you pass not nullable objects into methods.</li>
<li>Get familiar with <em>Null Coalescing</em>.</li>
<li>Don't splatter <em>null forgiving !</em> marks across your code.  Ask yourself Why?  Is this a boundary condition or just lazy coding?</li>
</ol>
</div></div></div></body></html>





