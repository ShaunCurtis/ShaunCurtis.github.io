<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<base href="/">

	

	

	
	<link href="/resources/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
	<link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">

	
	<link href="/resources/css/sb-admin-2.css" rel="stylesheet" type="text/css">
	<link href="/resources/css/site.css" rel="stylesheet" type="text/css">

	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
	<link rel="stylesheet" href="/resources/css/article.css" type="text/css">

	
	<link rel="icon" href="/images/favicon.png">

	<title>Building Blazor List Components and the Notification Pattern</title>
        <meta property="author" content="Shaun Curtis" />
        <meta property="description" content="This article looks at how to handle large lists in Blazor, decouple the data from the UI, and use the Notification Pattern to trigger updates in components." />
    <meta property="og:site_name" content="Cold Elm Coders" />
        <meta property="og:site" content="https://shauncurtis.github.io/" />
        <meta property="og:title" content="Building Blazor List Components and the Notification Pattern" />
        <meta property="og:description" content="This article looks at how to handle large lists in Blazor, decouple the data from the UI, and use the Notification Pattern to trigger updates in components." /></head>
<body><header class="navbar bg-dark p-2 text-large text-light"><section class="navbar-section  text-light"><a href="/" class="navbar-brand mr-2 text-large text-light p-2">Cold Elm Coders</a>
			<a href="/Posts" class="btn btn-link text-light">Posts</a>
			<a href="/Rants" class="btn btn-link text-light">Rants</a>
			<a href="/Articles" class="btn btn-link text-light">Articles</a>
			<a href="/Stories" class="btn btn-link text-light">Stories</a>
			<a href="/about.html" class="btn btn-link text-light">About</a></section></header>

	<div class="container-fluid"><div class="row"><div class="col-12 col-sm-3 col-lg-2 bg-light pt-2"><div class="article-info p-2"><div class="mb-2">Published: 28-Feb-2022</div>
                <div class="mb-2">Updated: 28-Feb-2022</div>
                <div class="mb-2">Author: Shaun Curtis</div></div>
    <h4 class="p-2">Table of Contents</h4>
<ul class="TOC" >
<li class="TOC-item TOC-item-0" >
<a class="TOC-link" href="#">Top</a>
<ul class="TOC TOC-0" >
<li class="TOC-item TOC-item-1" >
<ul class="TOC TOC-1" >
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#overview">Overview</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#repo">Repo</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#refactoring-the-project">Refactoring the Project</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-ui">The UI</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#paging">Paging</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#fetchpageddata">FetchPagedData</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#wrap-up">Wrap up</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
			
			<div class="col-12 col-sm-9 col-lg-10 p-2"><div class="pt-2 pb-2 border-bottom mb-4 text-primary"><h1>Building Blazor List Components and the Notification Pattern</h1>
            <div><small>This article looks at how to handle large lists in Blazor, decouple the data from the UI, and use the Notification Pattern to trigger updates in components.</small></div></div>
    <h2 id="overview">Overview</h2>
<p>This article looks at how to handle large lists in Blazor, decouple the data from the UI, and use the <em>Notification Pattern</em> to trigger updates in components.</p>
<p>The starting solution for this article is the out-of-the-box Blazor Server template.</p>
<h2 id="repo">Repo</h2>
<p>The Github Repository for this project is <a href="https://github.com/ShaunCurtis/Blazr.Articles/tree/main/Blazr.Articles.Lists">Blazr.Articles.Lists</a></p>
<h2 id="refactoring-the-project">Refactoring the Project</h2>
<p>Our first step is to separate the code into three principle directory structures: Data, Core and UI.  Normally I would use three projects, but I'm keeping things simple in this article.  These represent the three primary domains in the simple Clean Design model.  We'll re-distribute the code as we progress.  Code in each domain resides in the domain namespace:  for example all <em>Core</em> code resides in <code>Blazr.Articles.Core</code>.</p>
<h3 id="weatherforecast">WeatherForecast</h3>
<p>Move to <em>Core</em> and:</p>
<ol>
<li>Change it to a <code>record</code> value object.</li>
<li>Add a <code>WeatherForecastId</code> property as a <code>Guid</code>.</li>
<li>Change all the properties to <code>{get; init;}</code>.</li>
</ol>
<pre><code class="language-csharp">namespace Blazr.Articles.Core;

public record WeatherForecast
{
    public Guid WeatherForecastId {get; init;} = Guid.Empty;
    public DateTime Date { get; init; }
    public int TemperatureC { get; init; }
    public int TemperatureF =&gt; 32 + (int)(TemperatureC / 0.5556);
    public string? Summary { get; init; }
}
</code></pre>
<h3 id="listoptions">ListOptions</h3>
<p>Add a <code>ListOptions</code> class to <em>Core</em>.  This class contains paging data: it's passed in any data pipeline request to define the dataset &quot;page&quot; to retrieve.  Code should never retrieve unconstrained lists from data sources - you never know how big the data set may grow.  Set the defaults to sensible maximum values.  The class has various constructors and setters we'll use later.</p>
<pre><code class="language-csharp">using Microsoft.AspNetCore.Components.Web.Virtualization;
namespace Blazr.Articles.Core;

public class ListOptions
{
    public int StartRecord { get; set; } = 0;
    public int PageSize { get; set; } = 1000;
    public int ListCount { get; set; }
    public int Page =&gt; this.StartRecord / this.PageSize;

    public ListOptions() { }

    public ListOptions(int startRecord, int pageSize)
    {
        this.StartRecord = startRecord;
        this.PageSize = pageSize;
    }

    public void Set(ListOptions options)
    {
        this.PageSize = options.PageSize;
        this.StartRecord = options.StartRecord;
    }

    public void Set(ItemsProviderRequest options)
    {
        this.PageSize = options.Count;
        this.StartRecord = options.StartIndex;
    }

    public void SetPage(int pageno)
        =&gt;  this.StartRecord = pageno * this.PageSize;

    public ListOptions Copy =&gt; new ListOptions { 
        StartRecord = this.StartRecord, 
        PageSize = this.PageSize, 
        ListCount = this.ListCount
    };
}
</code></pre>
<h3 id="weatherforecastdatastore">WeatherForecastDataStore</h3>
<p>Rename the <code>WeatherForcastService</code> to <code>WeatherForecastDataStore</code> and restructure it as follows.</p>
<p>We:</p>
<ol>
<li>Generate a large data set on instantiation and assign it to an internal field.</li>
<li>Add various public methods for List and CRUD operations.</li>
<li>Maintain an internally consistent data set: data requests are passed copies, not references to internal objects.</li>
<li>The data pipeline methods are all <code>ValueTask</code> based because they emulate real world asynchronous database operations.</li>
</ol>
<pre><code class="language-csharp">namespace Blazr.Articles.Data;
using Blazr.Articles.Core;

public class WeatherForecastDataStore
{
    // Internal list to hold the data set.
    private List&lt;WeatherForecast&gt; _records;

    public WeatherForecastDataStore()
    {
        _records = GetForecasts();
    }

    private static readonly string[] Summaries = new[]
    {
        &quot;Freezing&quot;, &quot;Bracing&quot;, &quot;Chilly&quot;, &quot;Cool&quot;, &quot;Mild&quot;, &quot;Warm&quot;, &quot;Balmy&quot;, &quot;Hot&quot;, &quot;Sweltering&quot;, &quot;Scorching&quot;
    };

    public ValueTask&lt;bool&gt; DeleteForecastAsync(Guid Id) {
        var record = _records.FirstOrDefault(item =&gt; item.WeatherForecastId == Id);
        if (record is not null)
            _records.Remove(record);
        return ValueTask.FromResult(record is not null);
    }

    public ValueTask&lt;bool&gt; SaveForecastAsync(WeatherForecast record)
    {
        var isrecord = _records.Any(item =&gt; item.WeatherForecastId == record.WeatherForecastId);
        if (isrecord)
            _records.Remove(record);
        _records.Add(record with { });
        return ValueTask.FromResult(isrecord);
    }

    public ValueTask&lt;List&lt;WeatherForecast&gt;&gt; GetForecastsAsync(ListOptions options)
    {
        var list = _records
            .OrderBy(item =&gt; item.Date)
            .Skip(options.StartRecord)
            .Take(options.PageSize)
            .ToList();

            var newList = new  List&lt;WeatherForecast&gt;();
            list.ForEach(item =&gt; newList.Add(item with {}));

            return ValueTask.FromResult(newList);
    }

    public ValueTask&lt;int&gt; GetForecastCountAsync()
        =&gt; ValueTask.FromResult(_records.Count);

    private List&lt;WeatherForecast&gt; GetForecasts()
    {
        return Enumerable.Range(1, 200).Select(index =&gt; new WeatherForecast
        {
            WeatherForecastId = Guid.NewGuid(),
            Date = DateTime.Now.AddDays(index),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = Summaries[Random.Shared.Next(Summaries.Length)]
        }).ToList();
    }
}
</code></pre>
<h3 id="iweatherforecastdatabroker">IWeatherForecastDataBroker</h3>
<p><code>IWeatherForecastDataBroker</code> defines the interface for the data pipeline connection between Core and Data domain code.  Add <code>IWeatherForecastDataBroker</code> to <em>Core</em>.  It defines the basic List and CRUD operations we implement for this article:</p>
<ol>
<li>Delete a record.</li>
<li>Save a record.</li>
<li>Get a record list.</li>
<li>Get the total number of records.</li>
</ol>
<p>Note the simularity with the classic Repository pattern.</p>
<pre><code class="language-csharp">namespace Blazr.Articles.Core;

public interface IWeatherForecastDataBroker
{
    public ValueTask&lt;List&lt;WeatherForecast&gt;&gt; GetForecastsAsync(ListOptions options);
    public ValueTask&lt;int&gt; GetForecastCountAsync();
    public ValueTask&lt;bool&gt; SaveForecastAsync(WeatherForecast record);
    public ValueTask&lt;bool&gt; DeleteForecastAsync(Guid Id);
}
</code></pre>
<h3 id="weatherforecastserverdatabroker">WeatherForecastServerDataBroker</h3>
<p><code>WeatherForecastServerDataBroker</code> is the concrete server based implementation of <code>IWeatherForecastDataBroker</code>.  It's commonly known as a &quot;shim&quot;: a thin call through layer into the data store.  Add <code>WeatherForecastServerDataBroker</code> to <em>Data</em>.</p>
<pre><code class="language-csharp">using Blazr.Articles.Core;

namespace Blazr.Articles.Data;

public class WeatherForecastServerDataBroker : IWeatherForecastDataBroker
{
    private WeatherForecastDataStore _dataStore;

    public WeatherForecastServerDataBroker(WeatherForecastDataStore weatherForecastDataStore)
        =&gt; _dataStore = weatherForecastDataStore;

    public ValueTask&lt;List&lt;WeatherForecast&gt;&gt; GetForecastsAsync(ListOptions options)
        =&gt; _dataStore.GetForecastsAsync(options);

    public ValueTask&lt;int&gt; GetForecastCountAsync()
        =&gt; _dataStore.GetForecastCountAsync();

    public ValueTask&lt;bool&gt; SaveForecastAsync(WeatherForecast record)
        =&gt; _dataStore.SaveForecastAsync(record);

    public ValueTask&lt;bool&gt; DeleteForecastAsync(Guid Id)
        =&gt; _dataStore.DeleteForecastAsync(Id);
}
</code></pre>
<h3 id="weatherforecastnotificationservice">WeatherForecastNotificationService</h3>
<p><code>WeatherForecastNotificationService</code> is a simple service used by the data services to manage notifications: list updates and page changes.  There are two events triggered by two public notify methods.</p>
<pre><code class="language-csharp">namespace Blazr.Articles.Core;

public class WeatherForecastNotificationService
{
    public event EventHandler? ListUpdated;
    public event EventHandler? ListPaged;

    public void NotifyListUpdated(object? sender)
        =&gt;  this.ListUpdated?.Invoke(this, EventArgs.Empty);

    public void NotifyListPaged(object? sender, int page)
        =&gt;  this.ListPaged?.Invoke(sender, new PagingEventArgs(page));
}
</code></pre>
<p><code>ListPagedEventArgs</code> is a derived <code>Eventargs</code> class:</p>
<pre><code class="language-csharp">namespace Blazr.Articles.Core;

public class ListPagedEventArgs : EventArgs
{
    public int Page { get; set; }

    public ListPagedEventArgs(int page)
        =&gt; this.Page = page;
}
</code></pre>
<h3 id="weatherforecastlistservice">WeatherForecastListService</h3>
<p>This provides list management for the UI. <code>Records</code> is the exposed paged record set.  There are two <code>GetRecordsAsync</code> public methods:</p>
<ol>
<li>The first is used by the paging control and updates <code>Records</code>.</li>
<li>The second is used by the <code>Virtualize</code> component and implements the <code>ItemsProviderDelegate</code> pattern.</li>
</ol>
<p>Both update the local <code>ListOptions</code> field, get the data set and raise the <code>ListPaged</code> event on the notification service.</p>
<pre><code class="language-csharp">using Microsoft.AspNetCore.Components.Web.Virtualization;
namespace Blazr.Articles.Core;

public class WeatherForecastListService
{
    private IWeatherForecastDataBroker _weatherForecastDataBroker;
    private WeatherForecastNotificationService _notificationService;
    public readonly ListOptions ListOptions = new ListOptions();
    public List&lt;WeatherForecast&gt;? Records { get; private set; }

    public WeatherForecastListService(IWeatherForecastDataBroker weatherForecastDataBroker, WeatherForecastNotificationService weatherForecastNotificationService)
    {
        _weatherForecastDataBroker = weatherForecastDataBroker;
        _notificationService = weatherForecastNotificationService;
    }

    public async ValueTask&lt;ListOptions&gt; GetRecordsAsync(ListOptions options)
    {
        this.ListOptions.Set(options);
        await this.GetRecordsAsync();
        return this.ListOptions.Copy;
    }

    public async ValueTask&lt;ItemsProviderResult&lt;WeatherForecast&gt;&gt; GetRecordsAsync(ItemsProviderRequest request)
    {
        this.ListOptions.Set(request);
        await this.GetRecordsAsync();
        return new ItemsProviderResult&lt;WeatherForecast&gt;(this.Records ?? new List&lt;WeatherForecast&gt;(), this.ListOptions.ListCount);
    }

    private async ValueTask GetRecordsAsync()
    {
        this.Records = await _weatherForecastDataBroker.GetForecastsAsync(this.ListOptions);
        this.ListOptions.ListCount = await _weatherForecastDataBroker.GetForecastCountAsync();
        _notificationService.NotifyListPaged(this, this.ListOptions.Page);
    }
}
</code></pre>
<h3 id="weatherforecastcrudservice">WeatherForecastCrudService</h3>
<p><code>WeatherForecastCrudService</code> contains the Crud services.</p>
<p>Methods raise the appropriate events on the notification service.  This service is very simple here, but where the record is more complex and/or record editing is implemented, this class would maintain the working copy of the record.</p>
<pre><code class="language-csharp">namespace Blazr.Articles.Core;

public class WeatherForecastCrudService
{
    private IWeatherForecastDataBroker _weatherForecastDataBroker;
    private WeatherForecastNotificationService _notificationService;

    public WeatherForecastCrudService(IWeatherForecastDataBroker weatherForecastDataBroker, WeatherForecastNotificationService weatherForecastNotificationService)
    {
        _weatherForecastDataBroker = weatherForecastDataBroker;
        _notificationService = weatherForecastNotificationService;
    }

    public async ValueTask DeleteRecordAsync(Guid Id)
    {
        _ = await _weatherForecastDataBroker.DeleteForecastAsync(Id);
        _notificationService.NotifyListUpdated(this);
    }

    public async ValueTask AddRecordAsync(WeatherForecast record)
    {
        _ = await _weatherForecastDataBroker.SaveForecastAsync(record);
        _notificationService.NotifyListUpdated(this);
    }
}
</code></pre>
<p>This completes the data pipeline.</p>
<h2 id="the-ui">The UI</h2>
<p>First make a copy of <code>FetchData</code>.  Call it <code>FetchPagedData</code>, change the <code>Page</code> directive to <code>FetchPagedData</code> and add a link to the new poage to <code>NavMenu</code>.</p>
<pre><code>&lt;div class=&quot;nav-item px-3&quot;&gt;
    &lt;NavLink class=&quot;nav-link&quot; href=&quot;fetchpageddata&quot;&gt;
        &lt;span class=&quot;oi oi-list-rich&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Paged data
    &lt;/NavLink&gt;
&lt;/div&gt;
</code></pre>
<h3 id="fetchdata">FetchData</h3>
<p>We'll look at this in stages.</p>
<p>The page:</p>
<ol>
<li>Implements <code>IDisposable</code>: events need disposing correctly.  The Renderer manages <code>IDisposable</code>.</li>
<li>Injects the View and Notification Services.</li>
</ol>
<pre><code>@page &quot;/fetchdata&quot;
@implements IDisposable
@using Blazr.Articles.Core
@inject WeatherForecastListService ListService
@inject WeatherForecastCrudService CrudService
@inject WeatherForecastNotificationService NotificationService
</code></pre>
<ol start="3">
<li>Provides a private field to reference the UI <code>Virtualize</code> component.</li>
<li><code>OnListUpdated</code> handles any list update events.  It calls <code>RefreshDataAsync</code> on the <code>Virtualize</code> component and <code>StateHasChanged</code> on the page component.</li>
<li>Implements <code>Dispose</code> to unregister event handlers.</li>
</ol>
<pre><code>@code {
    private Virtualize&lt;WeatherForecast&gt;? virtualizeComponent;

    protected override void OnInitialized()
        =&gt; this.NotificationService.ListUpdated += this.OnListUpdated;

    private void OnListUpdated(object? sender, EventArgs e)
    {
        this.virtualizeComponent?.RefreshDataAsync();
        this.InvokeAsync(StateHasChanged);
    }

    public void Dispose()
        =&gt; this.NotificationService.ListUpdated += this.OnListUpdated;
}
</code></pre>
<ol start="6">
<li>Add and Delete UI event handlers wired up to the <code>WeatherForecastCrudService</code>.</li>
</ol>
<pre><code class="language-csharp">    public async Task AddRecord()
    {
        var record = new WeatherForecast
            {
                WeatherForecastId = Guid.NewGuid(),
                Date = DateTime.Now,
                TemperatureC = 20,
                Summary = &quot;Testing&quot;
            };
        await CrudService.AddRecordAsync(record);
    }

    public async Task DeleteRecord(Guid Id)
        =&gt; await CrudService.DeleteRecordAsync(Id);
</code></pre>
<p>On to the UI.</p>
<p>We:</p>
<ol>
<li>Remove the list loading logic: this is handled by the <code>Virtualize</code> component.</li>
<li>Add a delete button to the row template and a add record button at the top of the page.</li>
<li>Add the <code>Virtualize</code> component as the row template, wired to the <code>WeatherForecastListService</code>method <code>GetRecordsAsync</code>.</li>
</ol>
<pre><code class="language-html">&lt;h1&gt;Weather forecast&lt;/h1&gt;

&lt;p&gt;This component demonstrates fetching data from a service.&lt;/p&gt;
&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;div class=&quot;col-12 text-end&quot;&gt;
        &lt;button class=&quot;btn btn-sm btn-dark&quot; @onclick=&quot;this.AddRecord&quot;&gt;Add Record&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;table class=&quot;table&quot;&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Date&lt;/th&gt;
            &lt;th&gt;Temp. (C)&lt;/th&gt;
            &lt;th&gt;Temp. (F)&lt;/th&gt;
            &lt;th&gt;Summary&lt;/th&gt;
            &lt;th&gt;Actions&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;Virtualize TItem=WeatherForecast Context=forecast ItemsProvider=this.ListService.GetRecordsAsync @ref=this.virtualizeComponent&gt;
            &lt;tr&gt;
                &lt;td&gt;@forecast.Date.ToShortDateString()&lt;/td&gt;
                &lt;td&gt;@forecast.TemperatureC&lt;/td&gt;
                &lt;td&gt;@forecast.TemperatureF&lt;/td&gt;
                &lt;td&gt;@forecast.Summary&lt;/td&gt;
                &lt;td&gt;
                    &lt;button class=&quot;btn btn-sm btn-danger&quot; @onclick=&quot;() =&gt; this.DeleteRecord(forecast.WeatherForecastId)&quot;&gt;Delete&lt;/button&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/Virtualize&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<h2 id="paging">Paging</h2>
<p>First, a paging component.</p>
<h3 id="pagingcontrol">PagingControl</h3>
<p>There's a lot of simple maths based fields to calculate and manage the page and block information the display components need.  We'll skip those.</p>
<p>The control follows the same pattern as <code>Virtualize</code>:</p>
<ol>
<li>The <code>ListOptions</code> class is used to pass and receive paging data.</li>
<li>Uses a <code>Func</code> delegate, defined as a required Parameter, to call the paging provider.</li>
<li>Provides a notification method for the parent to notify that the list has changed.</li>
</ol>
<p>The main methods are:</p>
<ol>
<li><code>GotToPageAsync(int page)</code> sets the new page and calls <code>SetPageAsync</code>.</li>
<li><code>GotToPageAsync()</code> calls <code>SetPageAsync</code> with the current <code>ListOptions</code> data.</li>
<li><code>SetPageAsync()</code> calls the <code>PagingProvider</code> and updates the list count on the result.</li>
</ol>
<pre><code class="language-csharp">private async Task GotToPageAsync(int page)
{
    if (this.PagingProvider is not null &amp;&amp; page != this.Page)
    {
        this.Page = page;
        await GotToPageAsync();
    }
}

private async Task GotToPageAsync()
{
    await SetPageAsync();
    this.StateHasChanged();
}

private async Task SetPageAsync()
{
    if (this.PagingProvider is not null)
    {
        var options = await PagingProvider(_listOptions);
        this.Page = options.Page;
        this.ListCount = options.ListCount;
    }
}
</code></pre>
<p><code>OnInitializedAsync</code> gets the current page.</p>
<pre><code class="language-csharp">protected async override Task OnInitializedAsync()
    =&gt;  await this.SetPageAsync();
</code></pre>
<p>The full partial class looks like this:</p>
<pre><code class="language-csharp">using Blazr.Articles.Core;
using Microsoft.AspNetCore.Components;

namespace Blazr.Articles.UI;

public partial class PagingControl
    : ComponentBase
{
    private ListOptions _listOptions =&gt; new ListOptions() { PageSize = this.PageSize, StartRecord = this.ReadStartRecord };
    private int Page = 0;
    private int ListCount = 0;

    [Parameter] public int PageSize { get; set; } = 5;

    [Parameter] public int BlockSize { get; set; } = 10;

    [Parameter][EditorRequired] public Func&lt;ListOptions, ValueTask&lt;ListOptions&gt;&gt;? PagingProvider { get; set; }

    [Parameter] public bool ShowPageOf { get; set; } = true;

    protected async override Task OnInitializedAsync()
        =&gt;  await this.SetPageAsync();

    private async Task SetPageAsync()
    {
        if (this.PagingProvider is not null)
        {
            var options = await PagingProvider(_listOptions);
            this.Page = options.Page;
            this.ListCount = options.ListCount;
        }
    }

    private void OnPagingReset(object? sender, PagingEventArgs e)
    {
        this.Page = e.Page;
        this.InvokeAsync(StateHasChanged);
    }

    private async Task GotToPageAsync(int page)
    {
        if (this.PagingProvider is not null &amp;&amp; page != this.Page)
        {
            this.Page = page;
            await GotToPageAsync();
        }
    }

    private async Task GotToPageAsync()
    {
        await SetPageAsync();
        this.StateHasChanged();
    }

    public async ValueTask NotifyListChangedAsync()
        =&gt; await GotToPageAsync();

    private int DisplayPage =&gt; this.Page + 1;

    private int LastPage =&gt; PageSize == 0 || ListCount == 0
        ? 0
        : ((int)Math.Ceiling(Decimal.Divide(this.ListCount, this.PageSize))) - 1;

    private int LastDisplayPage =&gt; this.LastPage + 1;

    private int ReadStartRecord =&gt; this.Page * this.PageSize;

    private int Block =&gt; (int)Math.Floor(Decimal.Divide(this.Page, this.BlockSize));

    private bool AreBlocks =&gt; this.ListCount &gt; this.BlockSize * this.PageSize;

    private int BlockStartPage =&gt; this.Block * this.BlockSize;

    private int BlockEndPage =&gt; this.LastPage &gt; (this.BlockStartPage + (BlockSize)) - 1
        ? (this.BlockStartPage + BlockSize) - 1
        : this.LastPage;

    private int LastBlock =&gt; (int)Math.Floor(Decimal.Divide(this.LastPage, this.BlockSize));

    private int LastBlockStartPage =&gt; LastBlock * this.BlockSize;

    private string GetCss(int page)
        =&gt; page == this.Page ? &quot;btn-primary&quot; : &quot;btn-secondary&quot;;

    private async Task MoveBlockAsync(int block)
    {
        var _page = block switch
        {
            int.MaxValue =&gt; this.LastBlockStartPage,
            1 =&gt; this.Block + 1 &gt; LastBlock ? LastBlock * this.BlockSize : this.BlockStartPage + BlockSize,
            -1 =&gt; this.Block - 1 &lt; 0 ? 0 : this.BlockStartPage - BlockSize,
            _ =&gt; 0
        };
        await this.GotToPageAsync(_page);
    }

    private async Task GoToBlockAsync(int block)
        =&gt; await this.GotToPageAsync(block * this.PageSize);
}
</code></pre>
<p>And the Razor markup</p>
<pre><code class="language-html">@namespace Blazr.Articles.UI
@implements IDisposable

&lt;div class=&quot;m-2 p-2&quot;&gt;
    @if (this.AreBlocks)
    {
        &lt;div class=&quot;btn-group me-1&quot; role=&quot;group&quot; aria-label=&quot;Move Back Buttons&quot;&gt;
            &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-dark&quot; @onclick=&quot;() =&gt; this.MoveBlockAsync(int.MinValue)&quot;&gt;|&amp;lt;&lt;/button&gt;
            &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-dark&quot; @onclick=&quot;() =&gt; this.MoveBlockAsync(-1)&quot;&gt;&amp;lt;&amp;lt;&lt;/button&gt;
        &lt;/div&gt;
    }
    &lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;Page Buttons&quot;&gt;
        @for (int page = this.BlockStartPage; page &lt;= this.BlockEndPage; page++)
        {
            var pageno = page;
            var viewpageno = page + 1;
            &lt;button type=&quot;button&quot; class=&quot;btn btn-sm @GetCss(pageno)&quot; @onclick=&quot;() =&gt; this.GotToPageAsync(pageno)&quot;&gt;@viewpageno&lt;/button&gt;
        }
    &lt;/div&gt;
    @if (this.AreBlocks)
    {
        &lt;div class=&quot;btn-group ms-1&quot; role=&quot;group&quot; aria-label=&quot;Move Forward Buttons&quot;&gt;
            &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-dark&quot; @onclick=&quot;() =&gt; this.MoveBlockAsync(1)&quot;&gt;&amp;gt;&amp;gt;&lt;/button&gt;
            &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-dark&quot; @onclick=&quot;() =&gt; this.MoveBlockAsync(int.MaxValue)&quot;&gt;&amp;gt;|&lt;/button&gt;
        &lt;/div&gt;
    }
    @if (this.ShowPageOf)
    {
        &lt;span class=&quot;mx-2&quot;&gt;Page @this.DisplayPage of @this.LastDisplayPage&lt;/span&gt;
    }
&lt;/div&gt;
</code></pre>
<h2 id="fetchpageddata">FetchPagedData</h2>
<p>We'll look at this in stages.</p>
<ol>
<li>Implements <code>IDisposable</code>: events need disposing correctly.  The Renderer manages <code>IDisposable</code>.</li>
<li>Injects the View and Notification Services.</li>
</ol>
<pre><code>@using Blazr.Articles.Core
@using Blazr.Articles.UI
@inject WeatherForecastListService ListService
@inject WeatherForecastCrudService CrudService
@inject WeatherForecastNotificationService NotificationService
</code></pre>
<ol start="3">
<li>Provides a private field to reference the UI <code>PageControl</code> component.</li>
<li><code>OnListUpdated</code> handles any list update events.  It calls <code>NotifyListChangedAsync</code> on the <code>PagingControl</code> component and <code>StateHasChanged</code> on the page component.</li>
<li><code>OnListPaged</code> handles any paging events.  It invokes <code>StateHasChanged</code> on the page component.</li>
<li>Implements <code>Dispose</code> to unregister event handlers.</li>
</ol>
<pre><code class="language-csharp">private PagingControl? pagingControl;

protected override void OnInitialized()
{
    this.NotificationService.ListUpdated += this.OnListChanged;
    this.NotificationService.ListPaged += this.OnListPaged;
}

private void OnListChanged(object? sender, EventArgs e)
{
    this.pagingControl?.NotifyListChangedAsync();
    this.InvokeAsync(StateHasChanged);
}

private void OnListPaged(object? sender, EventArgs e)
    =&gt; this.InvokeAsync(StateHasChanged);

public void Dispose()
{
    this.NotificationService.ListUpdated += this.OnListChanged;
    this.NotificationService.ListPaged += this.OnListPaged;
}
</code></pre>
<ol start="7">
<li>Add and Delete UI event handlers wired up to the <code>WeatherForecastCrudService</code>.</li>
</ol>
<pre><code class="language-csharp">public async Task AddRecord()
{
    var record = new WeatherForecast
        {
            WeatherForecastId = Guid.NewGuid(),
            Date = DateTime.Now,
            TemperatureC = 20,
            Summary = &quot;Testing&quot;
        };
    await CrudService.AddRecordAsync(record);
}

public async Task DeleteRecord(Guid Id)
    =&gt; await CrudService.DeleteRecordAsync(Id);
</code></pre>
<p>In the UI markup we:</p>
<ol>
<li>Add the paging control in a top bar along with the add button.</li>
<li>Point the list loop to the service <code>Records</code> collection.</li>
<li>Add the delete button to each row.</li>
</ol>
<pre><code class="language-html">
&lt;h1&gt;Weather forecast&lt;/h1&gt;

&lt;p&gt;This component demonstrates fetching data from a service.&lt;/p&gt;

&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-10&quot;&gt;
            &lt;PagingControl BlockSize=10 PageSize=10 PagingProvider=this.ListService.GetRecordsAsync @ref=this.pagingControl /&gt;
        &lt;/div&gt;
        &lt;div class=&quot;col-2 text-end&quot;&gt;
            &lt;button class=&quot;btn btn-sm btn-dark&quot; @onclick=&quot;this.AddRecord&quot;&gt;Add Record&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
@if (this.ListService.Records == null)
{
    &lt;p&gt;&lt;em&gt;Loading...&lt;/em&gt;&lt;/p&gt;
}
else
{
    &lt;table class=&quot;table&quot;&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;Date&lt;/th&gt;
                &lt;th&gt;Temp. (C)&lt;/th&gt;
                &lt;th&gt;Temp. (F)&lt;/th&gt;
                &lt;th&gt;Summary&lt;/th&gt;
                &lt;th&gt;Actions&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            @foreach (var forecast in this.ListService.Records)
            {
                &lt;tr&gt;
                    &lt;td&gt;@forecast.Date.ToShortDateString()&lt;/td&gt;
                    &lt;td&gt;@forecast.TemperatureC&lt;/td&gt;
                    &lt;td&gt;@forecast.TemperatureF&lt;/td&gt;
                    &lt;td&gt;@forecast.Summary&lt;/td&gt;
                    &lt;td&gt;
                        &lt;button class=&quot;btn btn-sm btn-danger&quot; @onclick=&quot;() =&gt; this.DeleteRecord(forecast.WeatherForecastId)&quot;&gt;Delete&lt;/button&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            }
        &lt;/tbody&gt;
    &lt;/table&gt;
}
</code></pre>
<h3 id="how-it-works">How it Works</h3>
<h4 id="paging-1">Paging</h4>
<ol>
<li>When the page loads, the initial state wil be &quot;loading&quot;:  <code>WeatherForecastListService.Records</code> will be null.</li>
<li>The <code>PagingControl</code> initializes, calling <code>SetPageAsync</code> and loading the first page.</li>
<li><code>WeatherForecastListService.GetRecordsAsync</code> loads the initial lage of data into <code>Records</code> and raises the <code>NotifyListPaged</code> event on the notifciation service.</li>
<li><code>OnListPaged</code> on <code>FetchPagedData</code> is called, which triggers a re-render.  <code>WeatherForecastListService.Records</code> now contains a dataset and is rendered.</li>
</ol>
<h4 id="adddelete-records">Add/Delete Records.</h4>
<ol>
<li>Add/Delete methods on the Crud Service raise the <code>ListUpdated</code> event on the notification service.</li>
<li><code>OnListChanged</code> is called on <code>FetchPagedData</code> which calls <code>NotifyListChangedAsync</code> on the <code>PagingControl</code>.</li>
<li>This triggers a reload of the current page and the <code>ListChanged</code> event which re-renders the main page.</li>
</ol>
<h2 id="wrap-up">Wrap up</h2>
<p>That's it for this article.  We've explored:</p>
<ol>
<li>How to build the data pipeline on a fundimentally sounder foundation.</li>
<li>How to separate the data from the UI.</li>
<li>How to use the <code>Virtualize</code> component, linked into the data pipeline to load paged data.</li>
<li>How to build a simple paging control that uses th same paging data pipeline infrastructure.</li>
<li>How to use the <em>Notification</em> pattern to drive the UI update process.</li>
</ol>
<p>In a future article I'll look at how to upgrade the data pipeline for sorting and filtering operations, and how to buid a set of generic UI components to handle such operations.</p>
</div></div></div></body></html>





