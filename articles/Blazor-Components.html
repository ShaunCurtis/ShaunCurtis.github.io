<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<base href="/">

	

	

	
	<link href="/resources/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
	<link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">

	
	<link href="/resources/css/sb-admin-2.css" rel="stylesheet" type="text/css">
	<link href="/resources/css/site.css" rel="stylesheet" type="text/css">

	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
	<link rel="stylesheet" href="/resources/css/article.css" type="text/css">

	
	<link rel="icon" href="/images/favicon.png">

	<title>A Deep Dive into Components</title>
        <meta property="author" content="Shaun Curtis" />
        <meta property="description" content="This article take a detailed look at the anatomy of a component and how it interacts with the rendering process." />
    <meta property="og:site_name" content="Cold Elm Coders" />
        <meta property="og:site" content="https://shauncurtis.github.io/" />
        <meta property="og:title" content="A Deep Dive into Components" />
        <meta property="og:description" content="This article take a detailed look at the anatomy of a component and how it interacts with the rendering process." /></head>
<body><header class="navbar bg-dark p-2 text-large text-light"><section class="navbar-section  text-light"><a href="/" class="navbar-brand mr-2 text-large text-light p-2">Cold Elm Coders</a>
			<a href="/Posts" class="btn btn-link text-light">Posts</a>
			<a href="/Rants" class="btn btn-link text-light">Rants</a>
			<a href="/Articles" class="btn btn-link text-light">Articles</a>
			<a href="/Stories" class="btn btn-link text-light">Stories</a>
			<a href="/about.html" class="btn btn-link text-light">About</a></section></header>

	<div class="container-fluid"><div class="row"><div class="col-12 col-sm-3 col-lg-2 bg-light pt-2"><div class="article-info p-2"><div class="mb-2">Published: 11-Nov-2020</div>
                <div class="mb-2">Updated: 16-Feb-2021</div>
                <div class="mb-2">Author: Shaun Curtis</div></div>
    <h4 class="p-2">Table of Contents</h4>
<ul class="TOC" >
<li class="TOC-item TOC-item-0" >
<a class="TOC-link" href="#">Top</a>
<ul class="TOC TOC-0" >
<li class="TOC-item TOC-item-1" >
<ul class="TOC TOC-1" >
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#what-is-a-component">What is a Component?</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-renderer-and-the-render-tree">The Renderer and the Render Tree</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-client-application">The Client Application</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#components">Components</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#componentbase">ComponentBase</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-render-process">The Render Process</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#component-events">Component Events</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#some-important-less-documented-information-and-lessons-learned">Some Important Less Documented Information and Lessons Learned</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#building-components">Building Components</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#some-observations">Some Observations</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
			
			<div class="col-12 col-sm-9 col-lg-10 p-2"><div class="pt-2 pb-2 border-bottom mb-4 text-primary"><h1>A Deep Dive into Components</h1>
            <div><small>This article take a detailed look at the anatomy of a component and how it interacts with the rendering process.</small></div></div>
    <h2 id="what-is-a-component">What is a Component?</h2>
<p>Microsoft defines:</p>
<p><em>A component is a self-contained portion of user interface (UI) with processing logic to enable dynamic behavior. Components can be nested, reused, shared among projects, and used in MVC and Razor Pages apps.</em></p>
<p><em>Components are implemented using a combination of C# and HTML markup in Razor component files with the .razor file extension.</em></p>
<p>What is does rather than what it is, and not all strictly true.</p>
<p>From a programming perspective, a component is a simply a class that implements the <code>IComponent</code> interface.  Nothing more.  It comes to life when it's attached to a <code>RenderTree</code>, the component tree used by a <code>Renderer</code> to build and update.  The <code>IComponent</code> interface proves the <code>Renderer</code>s  interface to communicate with and receive communication from a component.</p>
<p>Before we dive into components we need to look at the <code>Renderer</code> and <code>RenderTree</code>, and the application setting.</p>
<h2 id="the-renderer-and-the-render-tree">The Renderer and the Render Tree</h2>
<p>A detailed description of how the <code>Renderer</code> and <code>RenderTree</code> work is beyond the scope of this article, but you need a basic grasp of the concepts to understand the rendering process.</p>
<p>The <code>Renderer</code> and <code>RenderTree</code> reside in the Client Application in WASM and in the SignalR Hub Session in Server, i.e. one per connected Client Application.</p>
<p>The UI - defined by html code in the DOM [Document Object Model] - is represented in the application as a <code>RenderTree</code> and managed by a <code>Renderer</code>. Think of the <code>RenderTree</code> as a tree with one or more components attached to each branch. Each component is a C# class that implements the <code>IComponent</code> interface.  The <code>Renderer</code> has a <code>RenderQueue</code> which runs code to update the UI.  Components submit <code>RenderFragments</code> for the <code>Renderer</code> to run to update the <code>RenderTree</code> and the UI.  The <code>Renderer</code> uses a diffing process to detect changes in the DOM caused by <code>RenderTree</code> updates, and passes these to the client code to implement in the Browser DOM and update the displayed page.</p>
<p>The diagram below is a visual representation of the render tree for the out-of-the-box Blazor template.</p>
<p><img src="https://shauncurtis.github.io/articles/assets/Blazor-Components/Root-Render-Tree.png" alt="Root Render Tree" /></p>
<h2 id="the-client-application">The Client Application</h2>
<h3 id="blazor-server">Blazor Server</h3>
<p>Blazor Server defines the <code>&lt;app&gt;</code> component in the initial server/html page.  This looks like this:</p>
<pre><code class="language-html">&lt;app&gt;
    &lt;component type=&quot;typeof(App)&quot; render-mode=&quot;ServerPrerendered&quot; /&gt;
&lt;/app&gt;
</code></pre>
<p><code>type</code> defines the route component class - in this case <code>App</code> and <code>render-mode</code> defines how the initial server-side render process runs.  You can read about that elsewhere.  The only important bit to understand is that if it pre-renders, the page is rendered twice on the initial load - once by the server to build a static version of the page, and then a second time by the browser client code to build the live version of the page.</p>
<p>The browser client code gets loaded by:</p>
<pre><code class="language-html">&lt;script src=&quot;_framework/blazor.server.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>Once <em>blazor.server.js</em> loads, the client application runs in the browser page and a SignalR connection estabished with the server.  To complete the initial load, the Client Application calls the Blazor Hub Session and requests a complete server render of the <code>App</code> component.  It then applies the resultant DOM changes to the Client Application DOM - this will principly be the event wiring.</p>
<p>The diagram below shows how a render request is passed to the displayed page.</p>
<p><img src="https://shauncurtis.github.io/articles/assets/Blazor-Components/Server-Render.png" alt="Server Rendering" /></p>
<h3 id="blazor-web-assembly">Blazor Web Assembly</h3>
<p>In Blazor WebAssembly the browser receives an Html page with a defined <code>div</code> placeholder where the root component should be loaded:</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    ....
&lt;/div&gt;
</code></pre>
<p>The Client Application gets loaded by:</p>
<pre><code class="language-html">&lt;script src=&quot;_framework/blazor.webassembly.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>Once the WASM code is loaded, it runs <code>program</code>.</p>
<pre><code class="language-csharp">builder.RootComponents.Add&lt;App&gt;(&quot;#app&quot;);
</code></pre>
<p>The code tells the Renderer that the <code>App</code> class component is the root component for the <code>RenderTree</code> and to load it's DOM into the <code>app</code> element in the browser DOM.</p>
<p><img src="https://shauncurtis.github.io/articles/assets/Blazor-Components/Web-Assembly-Render.png" alt="Server Rendering" /></p>
<p>The key point to take from this is that although the process by which the root component is defined and loaded is different, there's no difference between in a WebAssembly and Server root component or any sub-component.  You can use the same component.</p>
<h4 id="app.razor">App.razor</h4>
<p><em>App.razor</em> is the &quot;standard&quot; root component.  It can be any <code>IComponent</code> defined class.</p>
<p><code>App</code> looks like this:</p>
<pre><code class="language-html">&lt;Router AppAssembly=&quot;@typeof(Program).Assembly&quot;&gt;
    &lt;Found Context=&quot;routeData&quot;&gt;
        &lt;RouteView RouteData=&quot;@routeData&quot; DefaultLayout=&quot;@typeof(MainLayout)&quot; /&gt;
    &lt;/Found&gt;
    &lt;NotFound&gt;
        &lt;LayoutView Layout=&quot;@typeof(MainLayout)&quot;&gt;
            &lt;p&gt;Sorry, there's nothing at this address.&lt;/p&gt;
        &lt;/LayoutView&gt;
    &lt;/NotFound&gt;
&lt;/Router&gt;
</code></pre>
<p>It's a Razor component defining one child component, <code>Router</code>.  <code>Router</code> has two <code>RenderFragments</code>, <code>Found</code> and <code>NotFound</code>.  If <code>Router</code> finds a route, and therefore an <code>IComponent</code> class, it renders the <code>RouteView</code> component and passes it the route class type along with the default <code>Layout</code> class.   If no route is found it renders a <code>LayoutView</code> and renders the defined content in it's <code>Body</code>.</p>
<p><code>RouteView</code> checks if the <code>RouteData</code> component has a specific layout class defined.  If so it uses it, otherwise it uses the default layout.  It renders the layout and passes it the type of the component to add to the <code>Body</code> RenderFragment.</p>
<h2 id="components">Components</h2>
<p>All components are normal DotNetCore classes that implement <code>IComponent</code>.</p>
<p>The <code>IComponent</code> interface definition is:</p>
<pre><code class="language-csharp">public interface IComponent
{
    void Attach(RenderHandle renderHandle);
    Task SetParametersAsync(ParameterView parameters);
}
</code></pre>
<p>My first reaction on seeing this was &quot;What? Something missing here. Where's all those events and initialization methods?&quot; Every article you read talks about components and  <code>OnInitialized</code>, ...  Don't let them confuse you.   These are part of <code>ComponentBase</code> the out-of-the-box Blazor implementation of <code>IComponent</code>.  <code>ComponentBase</code> does not define of a component.  You will see a much simpler implementation below.</p>
<p>Lets look at what is defined in more detail.  The Blazor Hub Session has a <code>Renderer</code> that runs the <code>RenderTree</code> for each root component.  Technically you can have more than one, but we'll ignore that for this discussion.  To quote the class documentation:</p>
<p><code>Renderer</code> provides mechanisms:</p>
<ol>
<li>For rendering hierarchies of <code>IComponent</code> instances;</li>
<li>Dispatching events to them;</li>
<li>Notifying when the user interface is being updated.</li>
</ol>
<p>A RenderHandle structure:</p>
<ol>
<li>Allows a component to interact with its renderer.</li>
</ol>
<p>Going back to the <code>IComponent</code> interface:</p>
<ol>
<li><code>Attach</code> is called when the <code>Renderer</code> attaches an <code>IComponent</code> object to the <code>RenderTree</code>.  It passes the component a <code>RenderHandle</code> struct.  The component uses this render handle to queue <code>RenderFragments</code> onto the <code>Renderer</code>'s <code>RenderQueue</code>.  We'll look at <code>RenderFragement</code> in more detail soon.</li>
<li><code>SetParametersAsync</code> is called by the <code>Renderer</code> on a component when it first attaches it to the <code>RenderTree</code> and whenever it deems one or more of the components <code>Parameters</code> has changed.</li>
</ol>
<p>Note that the <code>IComponent</code> has no concept of the <code>RenderTree</code>.  It gets triggered into action through a call to <code>SetParametersAsync</code> and it passes changes by calling a method on a <code>RenderHandle</code>.</p>
<h3 id="the-helloworld-component">The HelloWorld Component</h3>
<p>To demonstrate the <code>IComponent</code> interface We'll build a simple <code>HelloWorld</code> component.</p>
<p>Our simplest Hello World Razor component looks like this:</p>
<pre><code class="language-html">@page &quot;/helloworld&quot;
&lt;div&gt;
    Hello World
&lt;/div&gt;
</code></pre>
<p>It's a Razor defined component.</p>
<p>We can refactor it to look like this:</p>
<pre><code class="language-csharp">@page &quot;/helloworld&quot;

@HelloWorld

@code {
    protected RenderFragment HelloWorld =&gt; (RenderTreeBuilder builder) =&gt;
    {
        builder.OpenElement(0, &quot;div&quot;);
        builder.AddContent(1, &quot;Hello World 2&quot;);
        builder.CloseElement();
    };
}
</code></pre>
<p>This introduces the <code>RenderFragment</code>. To quote the official Microsoft documentation.</p>
<p><em>A RenderFragement represents a segment of UI content, implemented as a delegate that writes the content to a RenderTreeBuilder.</em></p>
<p>The <code>RenderTreeBuilder</code> is even more succinct:</p>
<p><em>Provides methods for building a collection of RenderTreeFrame entries.</em></p>
<p>So, a <code>RenderFragment</code> is a delegate - defined in <em>Microsoft.AspNetCore.Components</em> as follows:</p>
<pre><code class="language-csharp">public delegate void RenderFragment(RenderTreeBuilder builder);
</code></pre>
<p>If you're new to delegates think of them as a pattern definition.  Any function that conforms to the pattern defined by <code>RenderFragment</code> delegate can passed as a <code>RenderFragment</code>.</p>
<p>The pattern dictates your method must:</p>
<ol>
<li>Have one, and only one, parameter of type <code>RenderTreeBuilder</code>.</li>
<li>Return a <code>void</code>.</li>
</ol>
<p>Looking back to the code above, we're defining a <code>RenderFragment</code> property and assigning an anonymous method to it that conforms to the <code>RenderFragment</code> pattern.  It takes a  <code>RenderTreeBuilder</code> and has no return so returns a void.  It uses the provided <code>RenderTreeBuilder</code> object to build the content: a simple hello world html div.  Each call to the builder adds what is called a <code>RenderTreeFrame</code>.  Note each frame is sequentially numbered.</p>
<p>It's important to understand two points:</p>
<ol>
<li>The component itself never &quot;runs&quot; the <code>RenderFragement</code>.  It is passed to the Renderer which Invokes it.</li>
<li>Even though the <code>Renderer</code> invokes the code, the code is run in the context of the component, and the state of the component when executing happens.</li>
</ol>
<h3 id="a-simple-icomponent-implementation">A Simple IComponent Implementation</h3>
<p>The <code>HelloWorld</code> component above inherits from <code>ComponentBase</code>.  Razor components that don't explicitly define inheritance inherit by default from <code>ComponentBase</code>.</p>
<p>We can now build our component as a simple C# class.</p>
<pre><code class="language-csharp">using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
using Microsoft.AspNetCore.Components.Web;
using System.Threading.Tasks;

namespace Blazor.HelloWorld.Pages
{
    [RouteAttribute(&quot;/helloworld&quot;)]
    public class RendererComponent : IComponent
    {
        private RenderHandle _renderHandle;

        public void Attach(RenderHandle renderHandle)
        {
            _renderHandle = renderHandle;
        }

        public Task SetParametersAsync(ParameterView parameters)
        {
            parameters.SetParameterProperties(this);
            this.Render();
            return Task.CompletedTask;
        }

        public void Render()
            =&gt; _renderHandle.Render(RenderComponent);

        private void RenderComponent(RenderTreeBuilder builder)
        {
            builder.OpenElement(0, &quot;div&quot;);
            builder.AddContent(1, &quot;Hello World 2&quot;);
            builder.CloseElement();
        }
    }
}
</code></pre>
<p>Points to note in the above code:</p>
<ol>
<li>The class uses the custom attribute <code>RouteAttribute</code> to define the route.</li>
<li>The class inherits from <code>IComponent</code>.</li>
<li>The class implements <code>Attach</code>.  The passed object <code>RenderHandle</code> is assigned to a local class field.</li>
<li>The class implements <code>SetParametersAsync</code> which is called when the component is first rendered, and whenever any <code>Parameters</code> are changed.  In our case never - we have no <code>Parameters</code> defined.  It calls the class method  <code>Render</code>.</li>
<li>The rest of the code is copied from the Razor component.</li>
<li>There's no <code>OnInitialized</code>, <code>OnAfterRender</code>, <code>StateHasChanged</code>,...  These are all  part of <code>ComponentBase</code>.</li>
</ol>
<p>The <code>Render</code> method calls <code>RenderHandle.Render</code> on the <code>RenderHandle</code> the component received when it was attached to the render tree.  It passes the <code>RenderComponent</code> method as a delegate.  Calling <code>Render</code> queues the passed delegate onto the Renderer's render queue.  This is where the code is actually executed.  Being a delegate it executes in the owning object's context.</p>
<p>The component is very simplistic, but it demonstrates the basics.</p>
<h3 id="routed-components">Routed Components</h3>
<p>Everything's a component, but not all components are equal.  <strong>Routed Components</strong> are a little special.</p>
<p>They contain <em>@page</em> routing directives and optionally a <em>@Layout</em> directive.</p>
<pre><code class="language-html">@page &quot;/WeatherForecast&quot;
@page &quot;/WeatherForecasts&quot;
@layout MainLayout
</code></pre>
<p>You can define these directly on classes like this:</p>
<pre><code class="language-csharp">[LayoutAttribute(typeof(MainLayout))]
[RouteAttribute(&quot;/helloworld&quot;)]
public class RendererComponent : IComponent {}
</code></pre>
<p>The <code>RouteAttribute</code> is used by the router to find Routes in the application.</p>
<p>Don't think of routed components as pages. It may seem obvious to do so, but don't.  Lots of web page properties don't apply to routed components.  You will:</p>
<ul>
<li>get confused when routed components don't behave like a page.</li>
<li>try and code the component logic as if it is a web page.</li>
</ul>
<h2 id="componentbase">ComponentBase</h2>
<p><code>ComponentBase</code> is the &quot;standard&quot; out-of-the-box Blazor implementation of <code>IComponent</code>.  All <em>.razor</em> files by default inherit from it.  While you may never step outside <code>ComponentBase</code> it's important to understand that it's just one implementation of the <code>IComponent</code> interface.  It doesn't define a component.  <code>OnInitialized</code> is not a component lifecycle method, it's a <code>ComponentBase</code> lifecycle method.</p>
<h3 id="componentbase-lifecycle-and-events">ComponentBase Lifecycle and Events</h3>
<p>There are articles galore regurgitating the same old basic lifecycle information.  I'm not going to repeat it.  Instead I'm going to concentrate on certain often misunderstood aspects of the lifecycle: there's more to the lifecycle that just the initial component load covered in most of the articles.</p>
<p>We need to consider five types of event:</p>
<ol>
<li>Instantiation of the class</li>
<li>Initialization of the component</li>
<li>Component parameter changes</li>
<li>Component events</li>
<li>Component disposal</li>
</ol>
<p>There are seven exposed Events/Methods and their async equivalents:</p>
<ol>
<li><code>SetParametersAsync</code></li>
<li><code>OnInitialized</code> and <code>OnInitializedAsync</code></li>
<li><code>OnParametersSet</code> and <code>OnParametersSetAsync</code></li>
<li><code>OnAfterRender</code> and <code>OnAfterRenderAsync</code></li>
<li><code>Dispose</code> - if <code>IDisposable</code> is implemented</li>
<li><code>StateHasChanged</code></li>
<li><code>new</code> - often forgotten.</li>
</ol>
<p>The standard class instantiation method builds the <code>RenderFragment</code> that <code>StateHasChanged</code> passes to the  <code>Renderer</code> to render the component.  It sets two private class variables to false and runs <code>BuildRenderTree</code>.</p>
<pre><code class="language-csharp">public ComponentBase()
{
    _renderFragment = builder =&gt;
    {
        _hasPendingQueuedRender = false;
        _hasNeverRendered = false;
        BuildRenderTree(builder);
    };
}
</code></pre>
<p><code>SetParametersAsync</code> sets the properties for the submitted parameters. It only runs <code>RunInitAndSetParametersAsync</code> - and thus <code>OnInitialized</code> followed by <code>OnInitializedAsync</code> - on initialization. It always calls <code>CallOnParametersSetAsync</code>.  Note:</p>
<ol>
<li><code>CallOnParametersSetAsync</code> waits on <code>OnInitializedAsync</code> to complete before calling <code>CallOnParametersSetAsync</code>.</li>
<li><code>RunInitAndSetParametersAsync</code> calls <code>StateHasChanged</code> if <code>OnInitializedAsync</code> task yields before completion.</li>
</ol>
<pre><code class="language-csharp">public virtual Task SetParametersAsync(ParameterView parameters)
{
    parameters.SetParameterProperties(this);
    if (!_initialized)
    {
        _initialized = true;
        return RunInitAndSetParametersAsync();
    }
    else return CallOnParametersSetAsync();
}

private async Task RunInitAndSetParametersAsync()
{
    OnInitialized();
    var task = OnInitializedAsync();
    if (task.Status != TaskStatus.RanToCompletion &amp;&amp; task.Status != TaskStatus.Canceled)
    {
        StateHasChanged();
        try { await task;}
        catch { if (!task.IsCanceled) throw; }
    }
    await CallOnParametersSetAsync();

</code></pre>
<p><code>CallOnParametersSetAsync</code> calls <code>OnParametersSet</code> followed by <code>OnParametersSetAsync</code>, and finally <code>StateHasChanged</code>.  If the <code>OnParametersSetAsync()</code> task yields <code>CallStateHasChangedOnAsyncCompletion</code> awaits the task and re-runs <code>StateHasChanged</code>.</p>
<pre><code class="language-csharp">private Task CallOnParametersSetAsync()
{
    OnParametersSet();
    var task = OnParametersSetAsync();
    var shouldAwaitTask = task.Status != TaskStatus.RanToCompletion &amp;&amp;
        task.Status != TaskStatus.Canceled;

    StateHasChanged();

    return shouldAwaitTask ?
        CallStateHasChangedOnAsyncCompletion(task) :
        Task.CompletedTask;
}

private async Task CallStateHasChangedOnAsyncCompletion(Task task)
{
    try { await task; }
    catch 
    {
        if (task.IsCanceled) return;
        throw;
    }
    StateHasChanged();
}
</code></pre>
<p>Lastly, lets look at <code>StateHasChanged</code>.  If a render is pending i.e. the renderer hasn't got round to running the queued render request, it closes - whatever changes have been made will be captured in the queued render.  If not, it sets the  <code>_hasPendingQueuedRender</code> class flag and calls the Render method on the <code>RenderHandle</code>.  This queues <code>_renderFragement</code> onto the <code>Renderer</code> <code>RenderQueue</code>.  When the queue runs <code>_renderFragment</code> - see above - it sets the two class flags to false and runs <code>BuildRenderTree</code>.</p>
<pre><code class="language-csharp">protected void StateHasChanged()
{
    if (_hasPendingQueuedRender) return;
    if (_hasNeverRendered || ShouldRender())
    {
        _hasPendingQueuedRender = true;
        try { _renderHandle.Render(_renderFragment);}
        catch {
            _hasPendingQueuedRender = false;
            throw;
        }
    }
}
</code></pre>
<p>Some key points to note:</p>
<ol>
<li><p><code>OnInitialized</code> and <code>OnInitializedAsync</code> only get called during initialization.  <code>OnInitialized</code> is run first.  If, and only if, <code>OnInitializedAsync</code> yields back to the internal calling method <code>RunInitAndSetParametersAsync</code>, then <code>StateHasChanged</code> get called, providing the opportunity to provide &quot;Loading&quot; information to the user.  <code>OnInitializedAsync</code> completes before <code>OnParametersSet</code> and <code>OnParametersSetAsync</code> are called.</p>
</li>
<li><p><code>OnParametersSet</code> and <code>OnParametersSetAsync</code> get called whenever the parent component makes changes to the parameter set for the component or a captured cascaded parameter changes.  Any code that needs to respond to parameter changes need to live here. <code>OnParametersSet</code> is run first.  Note that if <code>OnParametersSetAsync</code> yields, <code>StateHasChanged</code> is run after the yield, providing the opportunity to provide &quot;Loading&quot; information to the user.</p>
</li>
<li><p><code>StateHasChanged</code> is called after the <code>OnParametersSet{async}</code> methods complete to render the component.</p>
</li>
<li><p><code>OnAfterRender</code> and <code>OnAfterRenderAsync</code> occur at the end of all four events.  <code>firstRender</code> is only true on component initialization.  Note that any changes made here to parameters won't get applied to display values until the component re-renders.</p>
</li>
<li><p><code>StateHasChanged</code> is called during the initialization process if the conditions stated above are met, after the <code>OnParametersSet</code> processes, and any event callback.  Don't call it explicitly during the render or parameter set process unless you need to.  If you do call it you are probably doing something wrong.</p>
</li>
</ol>
<h2 id="the-render-process">The Render Process</h2>
<p>Let's look in detail at how a simple page and component get rendered.</p>
<h4 id="simplecomponent.razor">SimpleComponent.razor</h4>
<pre><code class="language-html">&lt;div class=&quot;h4 bg-success text-white p-2&quot;&gt;Loaded&lt;/div&gt;
</code></pre>
<h4 id="simplepage.razor">SimplePage.razor</h4>
<pre><code class="language-csharp">@page &quot;/simple&quot;
&lt;h3&gt;SimplePage&lt;/h3&gt;
@if (loaded)
{
    &lt;SimpleComponent&gt;&lt;/SimpleComponent&gt;
}
else
{
    &lt;div class=&quot;h4 bg-danger text-white p-2&quot;&gt;Loading.....&lt;/div&gt;
}

@code {
    private bool loaded;

    protected async override Task OnInitializedAsync()
    {
        await Task.Delay(2000);
        loaded = true;
    }
}
</code></pre>
<p>The follow diagram shows a simplified <code>RenderTree</code> representing a simple &quot;/&quot; route.</p>
<p><img src="https://shauncurtis.github.io/articles/assets/Blazor-Components/Root-Render-Tree.png" alt="Root Render Tree" /></p>
<p>Note the three nodes in <code>NavMenu</code> for the three <code>NavLink</code> controls.</p>
<p>On our page, the render tree looks like the diagram below on first render - we have a yielding <code>OnInitializedAsync</code> method, so <code>StateHasChanged</code> gets run in the initialization process.</p>
<p><img src="https://shauncurtis.github.io/articles/assets/Blazor-Components/Simple-Page-Loading.png" alt="Simple Page Loading" /></p>
<p>Once initialization completes, <code>StateHasChanged</code> is run a second time.  <code>Loaded</code> is now <code>true</code> and <code>SimpleComponent</code> is added to the component <code>RenderFragment</code>.  When the <code>Renderer</code> runs the <code>RenderFragment</code>, <code>SimpleComponent</code> is added to the render tree, instantiated and initialized.</p>
<p><img src="https://shauncurtis.github.io/articles/assets/Blazor-Components/Simple-Page-Loaded.png" alt="Simple Page Loaded" /></p>
<h3 id="component-content">Component Content</h3>
<p>Change <code>SimpleComponent</code> and <code>SimplePage</code> to:</p>
<h4 id="simplecomponent.razor-1">SimpleComponent.razor</h4>
<pre><code class="language-csharp">&lt;div class=&quot;h4 bg-success text-white p-2&quot;&gt;@ChildContent&lt;/div&gt;

@code {
    [Parameter] public RenderFragment ChildContent { get; set; }
}
</code></pre>
<h4 id="simplepage.razor-1">SimplePage.razor</h4>
<pre><code class="language-csharp">@page &quot;/simple&quot;
&lt;h3&gt;SimplePage&lt;/h3&gt;
@if (loaded)
{
    &lt;SimpleComponent&gt;
        &lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;ButtonClick&quot;&gt;Click Me&lt;/button&gt;
    &lt;/SimpleComponent&gt;
}
else
{
    &lt;div class=&quot;h4 bg-danger text-white p-2&quot;&gt;Loading.....&lt;/div&gt;
}

@code {
    private bool loaded;

    protected async override Task OnInitializedAsync()
    {
        await Task.Delay(2000);
        loaded = true;
    }

    protected void ButtonClick(MouseEventArgs e)
    {
        var x = true;
    }
}
</code></pre>
<p>There is now content in <code>SimpleComponent</code>. When the application is run that content gets executed in the context of the parent component.  How?</p>
<p>The answer is in <code>SimpleComponent</code>.   Remove the <code>[Parameter]</code> attribute from <code>SimpleComponent</code> and run the page.  It errors:</p>
<pre><code class="language-Text">InvalidOperationException: Object of type 'xxx.SimpleComponent' has a property matching the name 'ChildContent', but it does not have [ParameterAttribute] or [CascadingParameterAttribute] applied.
</code></pre>
<p>If a component has &quot;content&quot; i.e. markup between the opening and closing tags, Blazor expects to find a <code>Parameter</code> named <code>ChildContent</code> in the component.  The content between the tags is pre-compiled into a <code>RenderFragment</code> and then added to the component.  The content of the <code>RenderFragment</code> is run in the context of the object that owns it - <code>SimplePage</code>.</p>
<p>The content can also be defined like this:</p>
<pre><code class="language-html">&lt;SimpleComponent&gt;
    &lt;ChildContent&gt;
        &lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;ButtonClick&quot;&gt;
            Click Me
        &lt;/button&gt;
    &lt;/ChildContent&gt;
&lt;/SimpleComponent&gt;
</code></pre>
<p>The page can also be re-written as below, where it now becomes more obvious who owns the <code>RenderFragment</code>.</p>
<pre><code class="language-csharp">@page &quot;/simple&quot;
&lt;h3&gt;SimplePage&lt;/h3&gt;
@if (loaded)
{
    &lt;SimpleComponent&gt;
        @_childContent
    &lt;/SimpleComponent&gt;
}
else
{
    &lt;div class=&quot;h4 bg-danger text-white p-2&quot;&gt;Loading.....&lt;/div&gt;
}

@code {

    private bool loaded;

    protected async override Task OnInitializedAsync()
    {
        await Task.Delay(2000);
        loaded = true;
    }

    protected void ButtonClick(MouseEventArgs e)
    {
        var x = true;
    }

    private RenderFragment _childContent =&gt; (builder) =&gt;
    {
        builder.OpenElement(0, &quot;button&quot;);
        builder.AddAttribute(1, &quot;class&quot;, &quot;btn btn-primary&quot;);
        builder.AddAttribute(2, &quot;onclick&quot;, EventCallback.Factory.Create&lt;MouseEventArgs&gt;(this, ButtonClick));
        builder.AddContent(3, &quot;Click Me&quot;);
        builder.CloseElement();
    };
}
</code></pre>
<p>A component is not limited to a single <code>RenderFragment</code>.  A table component could look like this:</p>
<pre><code class="language-html">&lt;TableComponent&gt;
    &lt;Header&gt;
        ...
    &lt;/Header&gt;
    &lt;Rows&gt;
        ...
    &lt;/Rows&gt;
    &lt;Footer&gt;
        ...
    &lt;/Footer&gt;
&lt;/TableComponent&gt;
</code></pre>
<h2 id="component-events">Component Events</h2>
<p>The most important point to understand about Component events is they are <strong>NOT</strong> fire and forget.  All events are by default asynchronous and look like this:</p>
<pre><code class="language-csharp">var task = InvokeAsync(HandlerMethod);
StateHasChanged();
if (!task.IsCompleted)
{
    await task;
    StateHasChanged();
}
</code></pre>
<p>So the following code won't execute as expected:</p>
<pre><code class="language-csharp">void async ButtonClick(MouseEventArgs e) 
{
  await Task.Delay(2000);
  UpdateADisplayProperty();
}
</code></pre>
<p>The DisplayProperty doesn't display the current value until another <code>StateHasChanged</code> events occurs.  Why? ButtonClick doesn't return a <code>Task</code>, so there's nothing for the event handler to wait on.  It runs <code>StateHasChanged</code> before <code>UpdateADisplayProperty</code> completes.</p>
<p>This is a bandaid fix - it's bad pactice.</p>
<pre><code class="language-csharp">void async ButtonClick(MouseEventArgs e) 
{
  await Task.Delay(2000);
  UpdateADisplayProperty();
  StateHasChanged();
}
</code></pre>
<p>The correct solution is:</p>
<pre><code class="language-csharp">Task async ButtonClick(MouseEventArgs e) 
{
  await Task.Delay(2000);
  UpdateADisplayProperty();
}
</code></pre>
<p>Now the event handle has a <code>Task</code> to await and doesn't execute <code>StateHasChanged</code> until <code>ButtonClick</code> completes.</p>
<h2 id="some-important-less-documented-information-and-lessons-learned">Some Important Less Documented Information and Lessons Learned</h2>
<h3 id="keep-parameter-properties-simple">Keep Parameter Properties Simple</h3>
<p>Your parameter declarations should look like this:</p>
<pre><code class="language-csharp">[Parameter] MyClass myClass {get; set;}
</code></pre>
<p><strong>DON'T</strong> add code to the getter or setter.  Why?  Any setter must be run as part of the render process and can have a significant impact on render speed and component state.</p>
<h3 id="overriding-setparametersasync">Overriding SetParametersAsync</h3>
<p>If you override <code>SetParametersAsync</code> your method should look like this:</p>
<pre><code class="language-csharp">    public override Task SetParametersAsync(ParameterView parameters)
    {
        // always call first
        parameters.SetParameterProperties(this);
        // Your Code
        .....
        // pass an empty ParameterView, not parameters
        return base.SetParametersAsync(ParameterView.Empty);
    }
</code></pre>
<p>Set the parameters in the first line and call the base method passing <code>ParameterView.Empty</code>.  Don't try to pass <code>parameters</code> - you will get an error.</p>
<h3 id="treat-parameters-as-immutable">Treat Parameters as Immutable</h3>
<p>Never set Parameters in your code.  If you want to make or track changes do this:</p>
<pre><code class="language-csharp">    [Parameter] public int MyParameter { get; set; }
    private int _MyParameter;
    public event EventHandler MyParameterChanged;

    public async override Task SetParametersAsync(ParameterView parameters)
    {
        parameters.SetParameterProperties(this);
        if (!_MyParameter.Equals(MyParameter))
        {
            _MyParameter = MyParameter;
            MyParameterChanged?.Invoke(_MyParameter, EventArgs.Empty);
        }
        await base.SetParametersAsync(ParameterView.Empty);
    }
</code></pre>
<h3 id="iterators">Iterators</h3>
<p>A common problem occurs when a <code>For</code> iterator is used to loop through a collection to build a <code>select</code> or a data table.  A typical example is shown below:</p>
<pre><code class="language-csharp">@for (var counter = 0; counter &lt; this.myList.Count; counter++)
{
    &lt;button class=&quot;btn btn-dark m-3&quot; @onclick=&quot;() =&gt; ButtonClick(this.myList[counter])&quot;&gt;@this.myList[counter]&lt;/button&gt;
}
@for (var counter = 0; counter &lt; this.myList.Count; counter++)
{
    &lt;button class=&quot;btn btn-dark m-3&quot; @onclick=&quot;() =&gt; ButtonClick(counter)&quot;&gt;@this.myList[counter]&lt;/button&gt;
}
&lt;div&gt;Value = @this.value &lt;/div&gt;

@code {
    private List&lt;int&gt; myList =&gt; new List&lt;int&gt; { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    private int value;

    private Task ButtonClick(int value)
    {
        this.value = value;
        return Task.CompletedTask;
    }
}
</code></pre>
<p>If you click on a button in the first row, you will get a <em>Index was out of range</em> error.  Click on a button in the second row and value is always 10.  The reason is that the interator has completed before you click a button, at which time <code>counter</code> is 10.</p>
<p>To fix the problem, set a local variable within the loop as shown below.</p>
<pre><code class="language-csharp">@for (var counter = 0; counter &lt; this.myList.Count; counter++)
{
    var item = this.myList[counter];
    &lt;button class=&quot;btn btn-dark m-3&quot; @onclick=&quot;() =&gt; ButtonClick(item)&quot;&gt;@item&lt;/button&gt;
}
@for (var counter = 0; counter &lt; this.myList.Count; counter++)
{
    var item = this.myList[counter];
    var thiscount = counter;
    &lt;button class=&quot;btn btn-info m-3&quot; @onclick=&quot;() =&gt; ButtonClick(thiscount)&quot;&gt;@item&lt;/button&gt;
}
</code></pre>
<p>The best solution is to use <code>ForEach</code>.</p>
<pre><code class="language-csharp">@foreach  (var item in this.myList)
{
    &lt;button class=&quot;btn btn-primary m-3&quot; @onclick=&quot;() =&gt; ButtonClick(item)&quot;&gt;@item&lt;/button&gt;
}
</code></pre>
<h3 id="component-numbering">Component Numbering</h3>
<p>It's seems logical to use iterators to automate the numbering of component elements.  DON'T.  The numbering system is used by the diffing engine to decide which bits of the DOM need updating and which bits don't.  Numbering must be consistent within a <code>RenderFragment</code>.  You can use <code>OpenRegion</code> and <code>CloseRegion</code> to define a region with it's own number space.  <a href="https://gist.github.com/SteveSandersonMS/ec232992c2446ab9a0059dd0fbc5d0c3">See this gist for a more detailed explanation</a>.</p>
<h2 id="building-components">Building Components</h2>
<p>Components can be defined in three ways:</p>
<ol>
<li>As a <em>.razor</em> file with an code inside an <em>@code</em> block.</li>
<li>As a <em>.razor</em> file and a code behind <em>.razor.cs</em> file.</li>
<li>As a pure <em>.cs</em> class file inheriting from <em>ComponentBase</em> or a <em>ComponentBase</em> inherited class, or implementing <em>IComponent</em>.</li>
</ol>
<h5 id="all-in-one-razor-file">All in One Razor File</h5>
<p>HelloWorld.razor</p>
<pre><code class="language-html">&lt;div&gt;
@HelloWorld
&lt;/div&gt;

@code {
[Parameter]
public string HelloWorld {get; set;} = &quot;Hello?&quot;;
}
</code></pre>
<h5 id="code-behind">Code Behind</h5>
<p>HelloWorld.razor</p>
<pre><code class="language-html">@inherits ComponentBase
@namespace CEC.Blazor.Server.Pages

&lt;div&gt;
@HelloWorld
&lt;/div&gt;
</code></pre>
<p>HelloWorld.razor.cs</p>
<pre><code class="language-csharp">namespace CEC.Blazor.Server.Pages
{
    public partial class HelloWorld : ComponentBase
    {
        [Parameter]
        public string HelloWorld {get; set;} = &quot;Hello?&quot;;
    }
}
</code></pre>
<h5 id="c-class">C# Class</h5>
<p>HelloWorld.cs</p>
<pre><code class="language-csharp">namespace CEC.Blazor.Server.Pages
{
    public class HelloWorld : ComponentBase
    {
        [Parameter]
        public string HelloWorld {get; set;} = &quot;Hello?&quot;;

        protected override void BuildRenderTree(RenderTreeBuilder builder)
        {
            builder.OpenElement(0, &quot;div&quot;);
            builder.AddContent(1, (MarkupString)this._Content);
            builder.CloseElement();
        }
    }
}
</code></pre>
<h2 id="some-observations">Some Observations</h2>
<ol>
<li><p>There's a tendency to pile too much code into <code>OnInitialized</code> and <code>OnInitializedAsync</code> and then use events to drive <code>StateHasChanged</code> updates in the component tree.  Get the relevant code into the right places in the lifecycle and you won't need the events.</p>
</li>
<li><p>There's a temptation to start with the non-async versions (because they're easier to implement) and only use the async versions when you have to, when the opposite should be true.  Most web based activities are inherently async in nature.  I never use the non-async versions - I work on the principle that at some point I'm going to need to add async behaviour.</p>
</li>
<li><p><code>StateHasChanged</code> is called far to often, normally because code is in the wrong place in the component lifecycle, or the events have been coded incorrectly.  Ask yourself a challenging &quot;Why?&quot; when you type <code>StateHasChanged</code>.</p>
</li>
<li><p>Components are underused in the UI.  The same code/markup blocks are used repeatedly.  The same rules apply to code/markup blocks as to C# code.</p>
</li>
<li><p>Once you really, REALLY understand components, writing Blazor code becomes a totally &quot;different&quot; experience.</p>
</li>
</ol>
</div></div></div></body></html>





