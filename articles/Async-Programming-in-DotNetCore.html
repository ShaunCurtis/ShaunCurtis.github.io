<!DOCTYPE html>
<html lang="en">
<head>
    
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<!-- SEO Meta Tags -->
<meta name="description" content="Your description">
<meta name="author" content="Your name">

<!-- OG Meta Tags to improve the way the post looks when you share the page on Facebook, Twitter, LinkedIn -->
<meta property="og:site_name" content="" /> <!-- website name -->
<meta property="og:site" content="" /> <!-- website link -->
<meta property="og:title" content="" /> <!-- title shown in the actual shared post -->
<meta property="og:description" content="" /> <!-- description shown in the actual shared post -->
<meta property="og:image" content="" /> <!-- image link, make sure it's jpg -->
<meta property="og:url" content="" /> <!-- where do you want your post to link to -->
<meta name="twitter:card" content="summary_large_image"> <!-- to have large image post format in Twitter -->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


<meta name="description" content="A Practical Examination of Async Programming in DotNetCore." >
<meta name="author" content="Shaun Curtis" >



<title>Async Programming in DotNetCore</title>


<!-- Custom fonts for this template-->
<link href="/assets/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i"
      rel="stylesheet">

<!-- Custom styles for this template-->
<link href="/assets/css/sb-admin-2.css" rel="stylesheet" type="text/css">
<link href="/assets/css/site.css" rel="stylesheet" type="text/css">

<!-- Favicon  -->
<link rel="icon" href="/assets/images/favicon.png">


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
    <link rel="stylesheet" href="/assets/css/article.css" type="text/css">
</head>
<body id="page-top">
    <!--topbar-->
    <div id="topbar">
        
<!-- Topbar -->
<nav class="navbar navbar-expand navbar-light topbar mb-4 static-top">
    
<ul class="navbar-nav" >
<li class="nav-item" >
<a class="nav-link " href="/index.html" role="button"  >
<span class="mr-2 d-none d-lg-inline text-gray-100">Index</span>
</a>
</li>
<li class="nav-item dropdown no-arrow mx-1" >
<a class="nav-link dropdown-toggle" href="#" id="8fbb7d6a-922f-41b0-8b70-809cdcfac9e1" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"  >
<span class="mr-2 d-none d-lg-inline text-gray-100">Articles</span>
</a>
<div class=" dropdown-list dropdown-menu shadow animated--grow-in" aria-labelledby="8fbb7d6a-922f-41b0-8b70-809cdcfac9e1" >
<a class="dropdown-item" href="/articles/A-Flexible-app.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
A Flexible App
</a>
<a class="dropdown-item" href="/articles/Async-Programming-in-DotNetCore.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Async Programming In Dotnetcore
</a>
<a class="dropdown-item" href="/articles/Blazor-AllinOne.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor All In One - Multi SPA Hosting
</a>
<a class="dropdown-item" href="/articles/Blazor-Async-Programming.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Async Programming
</a>
<a class="dropdown-item" href="/articles/Blazor-Components.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Components
</a>
<a class="dropdown-item" href="/articles/Blazor-CSS.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor CSS
</a>
<a class="dropdown-item" href="/articles/Blazor-DataList-Control.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Datalist Control
</a>
<a class="dropdown-item" href="/articles/Blazor-Form-Validation.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Form Validation
</a>
<a class="dropdown-item" href="/articles/BlazorAsyncProgramming.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazorasyncprogramming
</a>
<a class="dropdown-item" href="/articles/Building-Edit-Forms.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building Edit Forms
</a>
<a class="dropdown-item" href="/articles/EditFormState.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
The Blazor EditFormState Control
</a>
<a class="dropdown-item" href="/articles/Hydra.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Hydra
</a>
<a class="dropdown-item" href="/articles/Inline-Dialog.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
The Blazor Inline Dialog Control
</a>
<a class="dropdown-item" href="/articles/Modal-Dialog.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
A Blazor Modal Dialog
</a>
<a class="dropdown-item" href="/articles/ValidationFormState.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
A Blazor Validation Control
</a>
</div>
</li>
<li class="nav-item dropdown no-arrow mx-1" >
<a class="nav-link dropdown-toggle" href="#" id="11de06bc-80fd-4091-a9b6-5d21384b1c31" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"  >
<span class="mr-2 d-none d-lg-inline text-gray-100">Blazor Database Application</span>
</a>
<div class=" dropdown-list dropdown-menu shadow animated--grow-in" aria-labelledby="11de06bc-80fd-4091-a9b6-5d21384b1c31" >
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-1.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 1
</a>
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-2.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 2
</a>
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-3.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 3
</a>
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-4.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 4
</a>
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-5.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 5
</a>
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-6.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 6
</a>
<a class="dropdown-item" href="/Building-a-Database-Application-in-Blazor/index.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building a Database Application in Blazor
</a>
</div>
</li>
<li class="nav-item dropdown no-arrow mx-1" >
<a class="nav-link dropdown-toggle" href="#" id="c5f4e6ca-28df-48f6-825b-487b19c7b693" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"  >
<span class="mr-2 d-none d-lg-inline text-gray-100">Posts</span>
</a>
<div class=" dropdown-list dropdown-menu shadow animated--grow-in" aria-labelledby="c5f4e6ca-28df-48f6-825b-487b19c7b693" >
<a class="dropdown-item" href="/posts/Blazor-Async-UI-Events.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Async UI Events
</a>
<a class="dropdown-item" href="/posts/DBContexts-In-Transient-Services.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Dbcontexts In Transient Services
</a>
<a class="dropdown-item" href="/posts/DynamicCss.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Dynamic Stylesheets
</a>
<a class="dropdown-item" href="/posts/For-ForEach-in-Blazor.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
For Foreach In Blazor
</a>
<a class="dropdown-item" href="/posts/Notification-Service-Pattern.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Notification Service Pattern
</a>
<a class="dropdown-item" href="/posts/XML-XSD-Serialization.html" >
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
XML XSD Serialization
</a>
</div>
</li>
</ul>

    <div class="ms-5 me-5 ml-auto">
        <h1>Cold Elm Coders</h1>
    </div>
</nav>


    </div>
    <!--End topbar-->
    <!--Sidebar-->
    <div id="sidebar">
        
<div class="article-info p-2" Published: 06-02-2021 >
<div>Published: 06-02-2021</div>
<div>Last Updated: 06-02-2021</div>
<div>Author: Shaun Curtis</div>
</div>

        
<h4 class="p-2">Table of Contents</h4>
<ul class="TOC" >
<li class="TOC-item TOC-item-0" >
<a class="TOC-link" href="#">Top</a>
<ul class="TOC TOC-0" >
<li class="TOC-item TOC-item-1" >
<ul class="TOC TOC-1" >
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#code-repository">Code Repository</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#library-classes">Library Classes</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#getting-started">Getting Started</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#more-complexity">More Complexity</a>
<ul class="TOC TOC-2" >
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#jobrunner">JobRunner</a>
</li>
<li class="TOC-item TOC-item-3" >
<a class="TOC-link" href="#jobscheduler">JobScheduler</a>
</li>
</ul>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#conclusions-and-wrap-up">Conclusions and Wrap Up.</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
    <!--End Sidebar-->
    <!-- Page Wrapper -->
    <div id="wrapper">
        <!-- Content Wrapper -->
        <div id="content-wrapper" class="d-flex flex-column">
            <!-- Main Content -->
            <div id="content">
                <!-- Topbar -->
                <div id="article">
                    <!-- Article -->
                    
<!-- Header -->
<header class="ex-header-article">
    <div class="container">
        <div class="row pt-3 pb-3 border-bottom">
            <div class="col">
                
<h1>Async Programming in DotNetCore</h1>
<div>A Practical Examination of Async Programming in DotNetCore.</div>

            </div> <!-- end of col -->
        </div> <!-- end of row -->
    </div> <!-- end of container -->
</header> <!-- end of ex-header -->
<!-- end of header -->


                    
<!-- Article Container -->
<div class="ex-basic-1 pt-4">
    <div class="container">
        <div class="row">
            <div class="col-12">
                

        <p>My first article on this subject provided an overview of async programming in DotNetCore and explained some of the key concepts.  You'll find the article <a href="https://www.codeproject.com/Articles/5276310/Understanding-and-Using-Async-Programming-in-DotNe">here</a>.  This article takes a practical approach to demonstrating some of of those key concepts, and introducing more complex coding patterns.  The article is based around a DotNetCore console application.</p>
<p>You'll need a DotNetCore compatible development environment, normally either either Visual Studio or Visual Code, and a copy of the Repo associated with this project to run the code.</p>
<blockquote>
<p><strong>DISCLAIMER</strong> - The code is <strong>Experimental</strong>, not <strong>Production</strong>.  Designed to be concise with minimal error trapping and handling to keep it easy to read and understand. Classes are kept simple for the same reason.</p>
</blockquote>
<h2 id="code-repository">Code Repository</h2>
<p>The code in available in a GitHub Repo <a href="https://github.com/ShaunCurtis/Async-Demo">here</a>.  The code for this project is in <em>Async-Demo</em>.  Ignore any other projects - they are for a further Async Programming article.</p>
<h2 id="library-classes">Library Classes</h2>
<p>Before we start your need to be aware of two helper classses</p>
<ol>
<li><code>LongRunningTasks</code> - emulates work.
<ol>
<li><code>RunLongProcessorTaskAsync</code> and <code>RunLongProcessorTask</code> use prime number calculations to emulate a processor heavy task.</li>
<li><code>RunYieldingLongProcessorTaskAsync</code> is a version that yields every 100 calculations.</li>
<li><code>RunLongIOTaskAsync</code> uses <code>Task.Delay</code> to emulate a slow I/O operations.</li>
</ol>
</li>
<li><code>UILogger</code> provides an abstraction layer for logging information to the UI.  You pass a delegate <code>Action</code> to the methods.  <code>UILogger</code> builds the message, and then calls the <code>Action</code> to actually write it to wherever the <code>Action</code> is configured to write to. In our case <code>LogToConsole</code> in <code>Program</code>,  which runs <code>Console.WriteLine</code>.  It could just as easily write to a text file.</li>
</ol>
<h2 id="getting-started">Getting Started</h2>
<p>Our first challenge is the switch from sync to async.</p>
<p>Make sure you're running the correct framework and latest language version. (C# 7.1 onwards supports a Task based <code>Main</code>).</p>
<pre><code class="language-xml"><div>  <span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">OutputType</span>&gt;</span>Exe<span class="hljs-tag">&lt;/<span class="hljs-name">OutputType</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">TargetFramework</span>&gt;</span>net5<span class="hljs-tag">&lt;/<span class="hljs-name">TargetFramework</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">LangVersion</span>&gt;</span>latest<span class="hljs-tag">&lt;/<span class="hljs-name">LangVersion</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">RootNamespace</span>&gt;</span>Async_Demo<span class="hljs-tag">&lt;/<span class="hljs-name">RootNamespace</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</div></code></pre>
<p>Pre #7.1, <code>Main</code> could only run synchronously, and you needed a &quot;NONO&quot;, using <code>Wait</code>, to prevent <code>Main</code> dropping out the bottom and closing the program. Post #7.1, declare <code>Main</code> to return a <code>Task</code>.</p>
<p>The <code>async</code> <code>Main</code> pattern is shown below.  Declaring <code>async</code> depends on whether on not there's an <code>await</code> in the code</p>
<pre><code class="language-csharp"><div><span class="hljs-comment">// With await</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span>
{
    <span class="hljs-comment">// code</span>
    <span class="hljs-comment">// await somewhere in here</span>
}

<span class="hljs-comment">// No awaits</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span>
{
    <span class="hljs-comment">// code</span>
    <span class="hljs-comment">// no awaits</span>
    <span class="hljs-keyword">return</span> Task.CompletedTask;
}
</div></code></pre>
<p>Note:</p>
<ol>
<li>If you use the <code>async</code> keyword but don't have an <code>await</code>, the compiler warns, but then compiles anyway, treating the method as synchronous code.</li>
<li>You can't declare a method as <code>async</code> and return a <code>Task</code>.  You simply return the correct value and the compiler will do all the donkey work.</li>
</ol>
<p>So let's run some code. Our first run:</p>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">static</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span>
{
    <span class="hljs-keyword">var</span> watch = <span class="hljs-keyword">new</span> Stopwatch();
    watch.Start();
    UILogger.LogThreadType(LogToConsole, <span class="hljs-string">&quot;Main&quot;</span>);
    <span class="hljs-keyword">var</span> millisecs = LongRunningTasks.RunLongProcessorTask(<span class="hljs-number">5</span>);
    watch.Stop();
    UILogger.LogToUI(LogToConsole, <span class="hljs-string">$&quot;Main ==&gt; Completed in <span class="hljs-subst">{ watch.ElapsedMilliseconds}</span> milliseconds&quot;</span>, <span class="hljs-string">&quot;Main&quot;</span>);
    <span class="hljs-keyword">return</span> Task.CompletedTask;
}
</div></code></pre>
<p>The Task ran <em>synchronously</em> as expected. A bunch of synchronous code inside a <code>Task</code>. No yielding.</p>
<pre><code><code><div>[11:35:32][Main Thread][Main] &gt;  running on Application Thread
[11:35:32][Main Thread][LongRunningTasks] &gt; ProcessorTask started
[11:35:36][Main Thread][LongRunningTasks] &gt; ProcessorTask completed in 3399 millisecs
[11:35:36][Main Thread][Main] &gt; Main ==&gt; Completed in 3523 milliseconds
Press any key to close this window . . .
</div></code></code></pre>
<p>Our second run:</p>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span>
{
    <span class="hljs-keyword">var</span> watch = <span class="hljs-keyword">new</span> Stopwatch();
    watch.Start();
    UILogger.LogThreadType(LogToConsole, <span class="hljs-string">&quot;Main&quot;</span>);
    <span class="hljs-keyword">var</span> millisecs = <span class="hljs-keyword">await</span> LongRunningTasks.RunLongProcessorTaskAsync(<span class="hljs-number">5</span>, LogToConsole);
    UILogger.LogToUI(LogToConsole, <span class="hljs-string">$&quot;Yielded to Main&quot;</span>, <span class="hljs-string">&quot;Main&quot;</span>);
    watch.Stop();
    UILogger.LogToUI(LogToConsole, <span class="hljs-string">$&quot;Main ==&gt; Completed in <span class="hljs-subst">{ watch.ElapsedMilliseconds}</span> milliseconds&quot;</span>, <span class="hljs-string">&quot;Main&quot;</span>);
}
</div></code></pre>
<p>The Task ran <em>synchronously</em> - no yielding.  Logical because there was no reason to yield. <code>RunLongProcessorTaskAsync</code> is a synchronous bunch of code inside a Task - calculating prime numbers - so it ran to completion.  The <code>await</code> is redundant, it may be a <code>Task</code> but it doesn't yield, so never gives up the thread until complete.</p>
<pre><code><code><div>[11:42:43][Main Thread][Main] &gt;  running on Application Thread
[11:42:43][Main Thread][LongRunningTasks] &gt; ProcessorTask started
[11:42:46][Main Thread][LongRunningTasks] &gt; ProcessorTask completed in 3434 millisecs
[11:42:46][Main Thread][Main] &gt; Yielded
[11:42:46][Main Thread][Main] &gt; Main ==&gt; Completed in 3593 milliseconds
</div></code></code></pre>
<p>Our third run:</p>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span>
{
    <span class="hljs-keyword">var</span> watch = <span class="hljs-keyword">new</span> Stopwatch();
    watch.Start();
    UILogger.LogThreadType(LogToConsole, <span class="hljs-string">&quot;Main&quot;</span>);
    <span class="hljs-keyword">var</span> millisecs = LongRunningTasks.RunYieldingLongProcessorTaskAsync(<span class="hljs-number">5</span>, LogToConsole);
    UILogger.LogToUI(LogToConsole, <span class="hljs-string">$&quot;Yielded to Main&quot;</span>, <span class="hljs-string">&quot;Main&quot;</span>);
    watch.Stop();
    UILogger.LogToUI(LogToConsole, <span class="hljs-string">$&quot;Main ==&gt; Completed in <span class="hljs-subst">{ watch.ElapsedMilliseconds}</span> milliseconds&quot;</span>, <span class="hljs-string">&quot;Main&quot;</span>);
}
</div></code></pre>
<p>Before we look at the result, let's look at the difference between <code>RunLongProcessorTaskAsync</code> and <code>RunYieldingLongProcessorTaskAsync</code>.  We've added a <code>Task.Yield()</code> to yield control every 100 primes.</p>
<pre><code class="language-csharp"><div><span class="hljs-keyword">if</span> (isPrime)
{
    counter++;
    <span class="hljs-comment">// only present in Yielding version</span>
    <span class="hljs-keyword">if</span> (counter &gt; <span class="hljs-number">100</span>)
    {
        <span class="hljs-keyword">await</span> Task.Yield();
        counter = <span class="hljs-number">0</span>;
    }
}
</div></code></pre>
<p>The long running task didn't complete. <code>RunYieldingLongProcessorTaskAsync</code> yielded back to <code>Main</code> after the first 100 primes had been calculated - a little short of 173 millisecs - and <code>Main</code> ran to completion during the yield.</p>
<pre><code><code><div>[12:13:56][Main Thread][Main] &gt;  running on Application Thread
[12:13:56][Main Thread][LongRunningTasks] &gt; ProcessorTask started
[12:13:57][Main Thread][Main] &gt; Yielded to Main
[12:13:57][Main Thread][Main] &gt; Main ==&gt; Completed in 173 milliseconds
</div></code></code></pre>
<p>If we update <code>Main</code> to <code>await</code> the long processor task</p>
<pre><code class="language-csharp"><div>    <span class="hljs-keyword">var</span> millisecs = <span class="hljs-keyword">await</span> LongRunningTasks.RunYieldingLongProcessorTaskAsync(<span class="hljs-number">5</span>, LogToConsole);
</div></code></pre>
<p>It runs to completion.  Although it yields, we <code>await</code> on the <code>RunYieldingLongProcessorTaskAsync</code> <code>Task</code> to complete, before moving on in <code>Main</code>.  There's another important point to note here.  Look at which thread the long running task ran on, and compare it to previous runs.  It jumped to a new thread <code>[LongRunningTasks Thread]</code> after starting on [Main Thread].</p>
<pre><code><code><div>[12:45:10][Main Thread:1][Main] &gt;  running on Application Thread
[12:45:11][Main Thread:1][LongRunningTasks] &gt; ProcessorTask started
[12:45:14][LongRunningTasks Thread:7][LongRunningTasks] &gt; ProcessorTask completed in 3892 millisecs
[12:45:14][LongRunningTasks Thread:7][Main] &gt; Yielded to Main
[12:45:14][LongRunningTasks Thread:7][Main] &gt; Main ==&gt; Completed in 4037 milliseconds
</div></code></code></pre>
<p>Add a quick <code>Console.Write</code> in <code>RunYieldingLongProcessorTaskAsync</code> to see which thread each yielded iteration runs on - writing the <code>ManagedThreadId</code>.</p>
<pre><code class="language-csharp"><div>counter++;
<span class="hljs-keyword">if</span> (counter &gt; <span class="hljs-number">100</span>)
{
    Console.WriteLine(<span class="hljs-string">$&quot;Thread ID:<span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span>&quot;</span>);
    <span class="hljs-keyword">await</span> Task.Yield();
    counter = <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>The result is shown below.  Notice the regular thread jumping.  Yield creates a new continuation <code>Task</code>, and schedules it to run asynchronously.  On the first <code>Task.Yield</code> the application thread scheduler passes the new <code>Task</code> to the application pool, and for then on the application pool Scheduler makes decisions on where to run Tasks.</p>
<blockquote>
<p><code>Task.Yield()</code>, to quote Microsoft &quot;Creates an awaitable task that asynchronously yields back to the current context when awaited.&quot; I translate that to mean it's syntactic sugar for yielding control up the tree and creating a continuation <code>Task</code> that gets posted back to the Scheduler to run when it schedules it. To quote further &quot;A context that, when awaited, will asynchronously transition back into the current context at the time of the await.&quot;  In other words, it doesn't <code>await</code> unless you tell it to.  Hit the first yield in the continuation and processing trucks on through to the code below <code>Task.Yield()</code>.  I've tested it.</p>
</blockquote>
<pre><code><code><div>[12:38:16][Main Thread:1][Main] &gt;  running on Application Thread
[12:38:16][Main Thread:1][LongRunningTasks] &gt; ProcessorTask started
Thread ID:1
Thread ID:4
Thread ID:4
Thread ID:6
Thread ID:6
Thread ID:7
</div></code></code></pre>
<p>Finally, change over to the <code>RunLongIOTaskAsync</code> long running task.</p>
<pre><code class="language-csharp"><div>    <span class="hljs-keyword">var</span> millisecs = <span class="hljs-keyword">await</span> LongRunningTasks.RunLongIOTaskAsync(<span class="hljs-number">5</span>, LogToConsole);
</div></code></pre>
<p>If you don't <code>await</code>, the same as before:</p>
<pre><code><code><div>[14:26:46][Main Thread:1][Main] &gt;  running on Application Thread
[14:26:47][Main Thread:1][LongRunningTasks] &gt; IOTask started
[14:26:47][Main Thread:1][Main] &gt; Yielded to Main
[14:26:47][Main Thread:1][Main] &gt; Main ==&gt; Completed in 322 milliseconds
</div></code></code></pre>
<p>And if you <code>await</code> it runs to completion, again with the thread switch.</p>
<pre><code><code><div>[14:27:16][Main Thread:1][Main] &gt;  running on Application Thread
[14:27:16][Main Thread:1][LongRunningTasks] &gt; IOTask started
[14:27:21][LongRunningTasks Thread:4][LongRunningTasks] &gt; IOTask completed in 5092 millisecs
[14:27:21][LongRunningTasks Thread:4][Main] &gt; Yielded to Main
[14:27:21][LongRunningTasks Thread:4][Main] &gt; Main ==&gt; Completed in 5274 milliseconds

</div></code></code></pre>
<h2 id="more-complexity">More Complexity</h2>
<p>Ok, now to move closer to reality and code doing something.</p>
<h3 id="jobrunner">JobRunner</h3>
<p><code>JobRunner</code> is a simple class to run and control asynchronous jobs.  For our purposes, it runs one of the long running tasks to simulate work, but you can use the basic pattern for real world situations.</p>
<p>It's self-evident what most of the code does, but I'll introduce <code>TaskCompletionSource</code>.</p>
<blockquote>
<p>To quote MS &quot;Represents the producer side of a Task&lt;TResult&gt; unbound to a delegate, providing access to the consumer side through the Task property.&quot;  You get a <code>Task</code> exposed by <code>TaskCompletionSource.Task</code> that you control through the <code>TaskCompletionSource</code> instance - in other words, a manually controlled <code>Task</code> uncoupled from the method.</p>
</blockquote>
<p>The <code>Task</code> that represents the state of the <code>JobRunner</code> is exposed as the <code>JobTask</code> property.  If the underlying <code>TaskCompletionSource</code> isn't set it returns a simple <code>Task.CompletedTask</code> object, otherwise it returns the <code>Task</code> of <code>JobTaskController</code>.  The <code>Run</code> method uses the async event pattern - we need a block of code that runs asynchronously, yielding control with <code>await</code>.  <code>Run</code> controls the <code>Task</code> state, but the <code>Task</code> itself is independant of <code>Run</code>.  <code>IsRunning</code> ensures you can't start the job once it's running.</p>
<pre><code class="language-csharp"><div><span class="hljs-keyword">class</span> <span class="hljs-title">JobRunner</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> JobType { IO, Processor, YieldingProcessor } 

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JobRunner</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> name, <span class="hljs-keyword">int</span> secs, JobType type = JobType.IO</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Name = name;
        <span class="hljs-keyword">this</span>.Seconds = secs;
        <span class="hljs-keyword">this</span>.Type = type;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Seconds { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> JobType Type { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> IsRunning;

    <span class="hljs-keyword">public</span> Task JobTask =&gt; <span class="hljs-keyword">this</span>.JobTaskController == <span class="hljs-literal">null</span> ? Task.CompletedTask : <span class="hljs-keyword">this</span>.JobTaskController.Task;
    <span class="hljs-keyword">private</span> TaskCompletionSource JobTaskController { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-keyword">new</span> TaskCompletionSource();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.IsRunning) {
            <span class="hljs-keyword">this</span>.IsRunning = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">this</span>.JobTaskController = <span class="hljs-keyword">new</span> TaskCompletionSource();
            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.Type)
            {
                <span class="hljs-keyword">case</span> JobType.Processor:
                    <span class="hljs-keyword">await</span> LongRunningTasks.RunLongProcessorTaskAsync(Seconds, Program.LogToConsole, Name);
                    <span class="hljs-keyword">break</span>;
                    
                <span class="hljs-keyword">case</span> JobType.YieldingProcessor:
                    <span class="hljs-keyword">await</span> LongRunningTasks.RunYieldingLongProcessorTaskAsync(Seconds, Program.LogToConsole, Name);
                    <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">await</span> LongRunningTasks.RunLongIOTaskAsync(Seconds, Program.LogToConsole, Name);
                    <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-keyword">this</span>.JobTaskController.TrySetResult();
            <span class="hljs-keyword">this</span>.IsRunning = <span class="hljs-literal">false</span>;
        }
    }
}
</div></code></pre>
<h3 id="jobscheduler">JobScheduler</h3>
<p><code>JobScheduler</code> is the method used to actually schedule the jobs.  It's separated from <code>Main</code> to demonstrate some key behaviours of async programming.</p>
<ol>
<li><code>Stopwatch</code> provides timing.</li>
<li>Creates four different <em>IO</em> jobs.</li>
<li>Starts the four jobs.</li>
<li>Uses <code>Task.WhenAll</code> to wait on certain tasks before continuing.  Note the <code>Task</code>s are the <code>JobTask</code>s exposed by the <code>JobRunnner</code> instances.</li>
</ol>
<blockquote>
<p><code>WhenAll</code> is one of several static <code>Task</code> methods.  <code>WhenAll</code> creates a single <code>Task</code> which <code>awaits</code> all the Tasks in the submitted array.  It's status will change to <em>Complete</em> when all the Tasks complete.  <code>WhenAny</code> is similar, but will be set to <em>Complete</em> when any are complete.  They could be named <em>AwaitAll</em> and <em>AwaitAny</em>.  <code>WaitAll</code> and <code>WaitAny</code> are blocking versions and similar to <code>Wait</code>.  Not sure about the reasons for the slightly confusing naming conversion - I'm sure there was one.</p>
</blockquote>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">JobScheduler</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-keyword">var</span> watch = <span class="hljs-keyword">new</span> Stopwatch();
    watch.Start();
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Job Scheduler&quot;</span>;
    <span class="hljs-keyword">var</span> quickjob = <span class="hljs-keyword">new</span> JobRunner(<span class="hljs-string">&quot;Quick Job&quot;</span>, <span class="hljs-number">3</span>);
    <span class="hljs-keyword">var</span> veryslowjob = <span class="hljs-keyword">new</span> JobRunner(<span class="hljs-string">&quot;Very Slow Job&quot;</span>, <span class="hljs-number">7</span>);
    <span class="hljs-keyword">var</span> slowjob = <span class="hljs-keyword">new</span> JobRunner(<span class="hljs-string">&quot;Slow Job&quot;</span>, <span class="hljs-number">5</span>);
    <span class="hljs-keyword">var</span> veryquickjob = <span class="hljs-keyword">new</span> JobRunner(<span class="hljs-string">&quot;Very Quick Job&quot;</span>, <span class="hljs-number">2</span>);
    quickjob.Run();
    veryslowjob.Run();
    slowjob.Run();
    veryquickjob.Run();
    UILogger.LogToUI(LogToConsole, <span class="hljs-string">$&quot;All Jobs Scheduled&quot;</span>, name);
    <span class="hljs-keyword">await</span> Task.WhenAll(<span class="hljs-keyword">new</span> Task[] { quickjob.JobTask, veryquickjob.JobTask }); ;
    UILogger.LogToUI(LogToConsole, <span class="hljs-string">$&quot;Quick Jobs completed in <span class="hljs-subst">{watch.ElapsedMilliseconds}</span> milliseconds&quot;</span>, name);
    <span class="hljs-keyword">await</span> Task.WhenAll(<span class="hljs-keyword">new</span> Task[] { slowjob.JobTask, quickjob.JobTask, veryquickjob.JobTask, veryslowjob.JobTask }); ;
    UILogger.LogToUI(LogToConsole, <span class="hljs-string">$&quot;All Jobs completed in <span class="hljs-subst">{watch.ElapsedMilliseconds}</span> milliseconds&quot;</span>, name);
    watch.Stop();
}
</div></code></pre>
<p>We now need to make some changes to <code>Main</code>:</p>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span>
{
    <span class="hljs-keyword">var</span> watch = <span class="hljs-keyword">new</span> Stopwatch();
    watch.Start();
    UILogger.LogThreadType(LogToConsole, <span class="hljs-string">&quot;Main&quot;</span>);
    <span class="hljs-keyword">var</span> task = JobScheduler();
    UILogger.LogToUI(LogToConsole, <span class="hljs-string">$&quot;Job Scheduler yielded to Main&quot;</span>, <span class="hljs-string">&quot;Main&quot;</span>);
    <span class="hljs-keyword">await</span> task;
    UILogger.LogToUI(LogToConsole, <span class="hljs-string">$&quot;final yield to Main&quot;</span>, <span class="hljs-string">&quot;Main&quot;</span>);
    watch.Stop();
    UILogger.LogToUI(LogToConsole, <span class="hljs-string">$&quot;Main ==&gt; Completed in <span class="hljs-subst">{ watch.ElapsedMilliseconds}</span> milliseconds&quot;</span>, <span class="hljs-string">&quot;Main&quot;</span>);

    <span class="hljs-comment">//return Task.CompletedTask;</span>
}

</div></code></pre>
<p>When you run this you get the output below.  The interesting bits to note are:</p>
<ol>
<li>Each of the jobs start, and then yield at their first await, passing control back to the caller - in this case <code>JobSchedular</code>.</li>
<li><code>JobScheduler</code> runs to it's first <code>await</code> and yields back to <code>Main</code>.</li>
<li>When the first two jobs finish their <code>JobTask</code> is set to complete and <code>JobScheduler</code> continues to the next <code>await</code>.</li>
<li><code>JobScheduler</code> completes in a little over the time needed to run the longest Job.</li>
</ol>
<pre><code><code><div>[16:58:52][Main Thread:1][Main] &gt;  running on Application Thread
[16:58:52][Main Thread:1][LongRunningTasks] &gt; Quick Job started
[16:58:52][Main Thread:1][LongRunningTasks] &gt; Very Slow Job started
[16:58:52][Main Thread:1][LongRunningTasks] &gt; Slow Job started
[16:58:52][Main Thread:1][LongRunningTasks] &gt; Very Quick Job started
[16:58:52][Main Thread:1][Job Scheduler] &gt; All Jobs Scheduled
[16:58:52][Main Thread:1][Main] &gt; Job Scheduler yielded to Main
[16:58:54][LongRunningTasks Thread:4][LongRunningTasks] &gt; Very Quick Job completed in 2022 millisecs
[16:58:55][LongRunningTasks Thread:4][LongRunningTasks] &gt; Quick Job completed in 3073 millisecs
[16:58:55][LongRunningTasks Thread:4][Job Scheduler] &gt; Quick Jobs completed in 3090 milliseconds
[16:58:57][LongRunningTasks Thread:4][LongRunningTasks] &gt; Slow Job completed in 5003 millisecs
[16:58:59][LongRunningTasks Thread:6][LongRunningTasks] &gt; Very Slow Job completed in 7014 millisecs
[16:58:59][LongRunningTasks Thread:6][Job Scheduler] &gt; All Jobs completed in 7111 milliseconds
[16:58:59][LongRunningTasks Thread:6][Main] &gt; final yield to Main
[16:58:59][LongRunningTasks Thread:6][Main] &gt; Main ==&gt; Completed in 7262 milliseconds
</div></code></code></pre>
<p>Now change the job type over to <code>Processor</code> as below:</p>
<pre><code class="language-csharp"><div><span class="hljs-keyword">var</span> quickjob = <span class="hljs-keyword">new</span> JobRunner(<span class="hljs-string">&quot;Quick Job&quot;</span>, <span class="hljs-number">3</span>, JobRunner.JobType.Processor);
<span class="hljs-keyword">var</span> veryslowjob = <span class="hljs-keyword">new</span> JobRunner(<span class="hljs-string">&quot;Very Slow Job&quot;</span>, <span class="hljs-number">7</span>, JobRunner.JobType.Processor);
<span class="hljs-keyword">var</span> slowjob = <span class="hljs-keyword">new</span> JobRunner(<span class="hljs-string">&quot;Slow Job&quot;</span>, <span class="hljs-number">5</span>, JobRunner.JobType.Processor);
<span class="hljs-keyword">var</span> veryquickjob = <span class="hljs-keyword">new</span> JobRunner(<span class="hljs-string">&quot;Very Quick Job&quot;</span>, <span class="hljs-number">2</span>, JobRunner.JobType.Processor);
</div></code></pre>
<p>When you run this, you'll see everything is run sequentially on the <code>Main Thread</code>.  At first you think why?  We have more than one thread available and the Scheduler has demonstrated it's ability to switch tasks between threads. Why isn't it switching?</p>
<p>The answer is very simple.  Once we initialise the JobRunnner object we run them in to the Scheduler one at a time.  As the code we run is sequential - calculating primes without breaks - we don't execute the next line of code (feeding in the second job) until the first job completes.</p>
<pre><code><code><div>[17:59:48][Main Thread:1][Main] &gt;  running on Application Thread
[17:59:48][Main Thread:1][LongRunningTasks] &gt; Quick Job started
[17:59:53][Main Thread:1][LongRunningTasks] &gt; Quick Job completed in 4355 millisecs
[17:59:53][Main Thread:1][LongRunningTasks] &gt; Very Slow Job started
[17:59:59][Main Thread:1][LongRunningTasks] &gt; Very Slow Job completed in 6057 millisecs
[17:59:59][Main Thread:1][LongRunningTasks] &gt; Slow Job started
[18:00:03][Main Thread:1][LongRunningTasks] &gt; Slow Job completed in 4209 millisecs
[18:00:03][Main Thread:1][LongRunningTasks] &gt; Very Quick Job started
[18:00:05][Main Thread:1][LongRunningTasks] &gt; Very Quick Job completed in 1737 millisecs
[18:00:05][Main Thread:1][Job Scheduler] &gt; All Jobs Scheduled
[18:00:05][Main Thread:1][Job Scheduler] &gt; Quick Jobs completed in 16441 milliseconds
[18:00:05][Main Thread:1][Job Scheduler] &gt; All Jobs completed in 16441 milliseconds
[18:00:05][Main Thread:1][Main] &gt; Job Scheduler yielded to Main
[18:00:05][Main Thread:1][Main] &gt; final yield to Main
[18:00:05][Main Thread:1][Main] &gt; Main ==&gt; Completed in 16591 milliseconds
</div></code></code></pre>
<p>Now, change the jobs over to run <code>YieldingProcessor</code>.</p>
<pre><code class="language-csharp"><div><span class="hljs-keyword">var</span> quickjob = <span class="hljs-keyword">new</span> JobRunner(<span class="hljs-string">&quot;Quick Job&quot;</span>, <span class="hljs-number">3</span>, JobRunner.JobType.YieldingProcessor);
<span class="hljs-keyword">var</span> veryslowjob = <span class="hljs-keyword">new</span> JobRunner(<span class="hljs-string">&quot;Very Slow Job&quot;</span>, <span class="hljs-number">7</span>, JobRunner.JobType.YieldingProcessor);
<span class="hljs-keyword">var</span> slowjob = <span class="hljs-keyword">new</span> JobRunner(<span class="hljs-string">&quot;Slow Job&quot;</span>, <span class="hljs-number">5</span>, JobRunner.JobType.YieldingProcessor);
<span class="hljs-keyword">var</span> veryquickjob = <span class="hljs-keyword">new</span> JobRunner(<span class="hljs-string">&quot;Very Quick Job&quot;</span>, <span class="hljs-number">2</span>, JobRunner.JobType.YieldingProcessor);
</div></code></pre>
<p>The result is very different.  The time taken will depend on the number of processor cores and threads on your computer.  You can see all the jobs start quickly and completion in 11 seconds, with the slowest job taking 9 seconds.  The key difference here is that the processor long running job yields regularly.  This gives the Scheduler a chance to divy out out the work to other threads.</p>
<p>Yielding Processor code</p>
<pre><code><code><div>[17:50:12][Main Thread:1][Main] &gt;  running on Application Thread
[17:50:12][Main Thread:1][LongRunningTasks] &gt; Quick Job started
[17:50:12][Main Thread:1][LongRunningTasks] &gt; Very Slow Job started
[17:50:12][Main Thread:1][LongRunningTasks] &gt; Slow Job started
[17:50:12][Main Thread:1][LongRunningTasks] &gt; Very Quick Job started
[17:50:12][Main Thread:1][Job Scheduler] &gt; All Jobs Scheduled
[17:50:12][Main Thread:1][Main] &gt; Job Scheduler yielded to Main
[17:50:16][LongRunningTasks Thread:7][LongRunningTasks] &gt; Very Quick Job completed in 4131 millisecs
[17:50:18][LongRunningTasks Thread:7][LongRunningTasks] &gt; Quick Job completed in 6063 millisecs
[17:50:18][LongRunningTasks Thread:7][Job Scheduler] &gt; Quick Jobs completed in 6158 milliseconds
[17:50:21][LongRunningTasks Thread:6][LongRunningTasks] &gt; Slow Job completed in 9240 millisecs
[17:50:23][LongRunningTasks Thread:9][LongRunningTasks] &gt; Very Slow Job completed in 11313 millisecs
[17:50:23][LongRunningTasks Thread:9][Job Scheduler] &gt; All Jobs completed in 11411 milliseconds
[17:50:23][LongRunningTasks Thread:9][Main] &gt; final yield to Main
[17:50:23][LongRunningTasks Thread:9][Main] &gt; Main ==&gt; Completed in 11534 milliseconds
</div></code></code></pre>
<h2 id="conclusions-and-wrap-up">Conclusions and Wrap Up.</h2>
<p>Hopefully helpful/informative?  Some of the key points that I've learned in my voyage down the async road, and are demonstrated here are:</p>
<ol>
<li><strong>Async and Await All The Way</strong>. Don't mix synchronous and asynchronous methods.  Start at the bottom - the data or process interface - and code async all the way up though the data and business/logic layers to the UI.</li>
<li>You can't run asynchronously if you don't yield. You've got to give the task schedulers a chance!  Wrapping a few synchronous routines in <code>Task</code> is talking-the-talk not walking-the-walk.</li>
<li>Fire and forget <code>void</code> return methods need to yield to pass control back to the caller.  They are no different to Task returning methods in their behaviour. They just don't return a Task for you to await or monitor progress.</li>
<li>If you're writing processor intensive activities - modelling, big numbercrunching,..  make sure to make them async with plenty of yielding at appropriate places.</li>
<li>ONLY use <code>Task.Run</code> in the UI, right up at the top of the call stack.  NEVER EVER use it in libraries.  And don't use it at all unless you have a solid reason.</li>
<li>Use logging and breakpoints on <code>awaits</code> to see when you hit them.  How quickly your code falls back to the outside <code>await</code> is a  very good indicator of responsiveness.  Take out your outside <code>await</code> and see how quickly you drop out the bottom!</li>
<li>You may have noticed no <code>ContinueWith</code>.  I don't often use it.  Normally a simple <code>await</code> followed by continuation code achieves the same result.  I've read commentary that it's heavier on processing, because it creates a new task whereas await/continuation reuses the same <code>Task</code>.  I haven't delved deeply enough into the code yet to check.</li>
<li>Always use <em>Async</em> and <em>Await</em>, don't get fancy.</li>
<li>If your library provides both async and sync calls, code them separately.  &quot;Code it once&quot; best practice doesn't apply here.  NEVER call one from the other if you don't want to shoot yourself in the foot at some point!</li>
</ol>

    

            </div>
        </div>
    </div>
</div>
<!-- end of Article Container -->


                </div>
                <!-- End of Main Content -->
            </div>
            <!-- Footer -->
            
<!-- Copyright -->
<footer class="sticky-footer bg-white">
    <div class="container my-auto">
        <div class="copyright text-center my-auto">
            
<span>Copyright &copy; Cold Elm Coders - 2021</span>

        </div>
    </div>
</footer>
<!-- end of copyright -->


            <!-- End of Footer -->
        </div>
        <!-- End of Content Wrapper -->
        
<a class="scroll-to-top rounded" href="#page-top">
    <i class="fas fa-angle-up"></i>
</a>


    </div>
    <!-- End of Page Wrapper -->
    <!-- Scripts -->
    
<!-- Scripts -->
<!-- Bootstrap core JavaScript-->
<script src="/assets/vendor/jquery/jquery.min.js"></script>
<script src="/assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

<!-- Core plugin JavaScript-->
<script src="/assets/vendor/jquery-easing/jquery.easing.min.js"></script>

<!-- Custom scripts for all pages-->
<script src="/assets/js/sb-admin-2.min.js"></script>


</body>
</html>
