<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<base href="/">

	

	

	
	<link href="/resources/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
	<link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">

	
	<link href="/resources/css/sb-admin-2.css" rel="stylesheet" type="text/css">
	<link href="/resources/css/site.css" rel="stylesheet" type="text/css">

	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
	<link rel="stylesheet" href="/resources/css/article.css" type="text/css">

	
	<link rel="icon" href="/images/favicon.png">

	<title>A Blazor DataList Control</title>
        <meta property="author" content="Shaun Curtis" />
        <meta property="description" content="This article describes how to build an input control based on a DataList in Blazor, and make it behave like a Select.  Along the way it looks at how `InputBase` controls are built and work." />
    <meta property="og:site_name" content="Cold Elm Coders" />
        <meta property="og:site" content="https://shauncurtis.github.io/" />
        <meta property="og:title" content="A Blazor DataList Control" />
        <meta property="og:description" content="This article describes how to build an input control based on a DataList in Blazor, and make it behave like a Select.  Along the way it looks at how `InputBase` controls are built and work." /></head>
<body><header class="navbar bg-dark p-2 text-large text-light"><section class="navbar-section  text-light"><a href="/" class="navbar-brand mr-2 text-large text-light p-2">Cold Elm Coders</a>
			<a href="/Posts" class="btn btn-link text-light">Posts</a>
			<a href="/Rants" class="btn btn-link text-light">Rants</a>
			<a href="/Articles" class="btn btn-link text-light">Articles</a>
			<a href="/Stories" class="btn btn-link text-light">Stories</a>
			<a href="/about.html" class="btn btn-link text-light">About</a></section></header>

	<div class="container-fluid"><div class="row"><div class="col-12 col-sm-3 col-lg-2 bg-light pt-2"><div class="article-info p-2"><div class="mb-2">Published: 01-Oct-2020</div>
                <div class="mb-2">Updated: 01-Oct-2020</div>
                <div class="mb-2">Author: Shaun Curtis</div></div>
    <h4 class="p-2">Table of Contents</h4>
<ul class="TOC" >
<li class="TOC-item TOC-item-0" >
<a class="TOC-link" href="#">Top</a>
<ul class="TOC TOC-0" >
<li class="TOC-item TOC-item-1" >
<ul class="TOC TOC-1" >
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-html-datalist">The Html DataList</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#example-site-and-code-repository">Example Site and Code Repository</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#exploring-binding-in-a-test-control">Exploring binding in a Test Control</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#inputbase">InputBase</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#building-our-datalist-control">Building our DataList Control</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#input-search-select-control">Input Search Select Control</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#wrap-up">Wrap Up</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
			
			<div class="col-12 col-sm-9 col-lg-10 p-2"><div class="pt-2 pb-2 border-bottom mb-4 text-primary"><h1>A Blazor DataList Control</h1>
            <div><small>This article describes how to build an input control based on a DataList in Blazor, and make it behave like a Select.  Along the way it looks at how `InputBase` controls are built and work.</small></div></div>
    <p>This article describes how to build an input control based on a DataList in Blazor, and make it behave like a Select.  <em>DataList</em> apppeared in HTML5.  Some browsers, particularly Safari were slow on the uptake, so usage was a bit problematic in the early days of HTML5.  Today, all the major browsers on various platforms support it: you can see the support list <a href="https://caniuse.com/?search=datalist">here</a>.</p>
<p>We'll build two versions of the control using Blazor's <code>InputBase</code> as the base class to fit into the existing edit form framework.  Along the way we delve into the inner workings of <code>InputBase</code> and explore control binding.</p>
<h2 id="the-html-datalist">The Html DataList</h2>
<p>When <code>Input</code> is linked to a <code>datalist</code>, it makes filtered suggestions as the user types based on the <code>datalist</code>.  Out-of-the-box, the user can select a suggestion or enter any text value.  The basic markup for the control is shown below.</p>
<pre><code class="language-html">&lt;input type=&quot;text&quot; list=&quot;countrylist&quot; /&gt;

&lt;datalist id=&quot;countrylist&quot; /&gt;
    &lt;option value=&quot;Algeria&quot; /&gt;
    &lt;option value=&quot;Australia&quot; /&gt;
    &lt;option value=&quot;Austria&quot; /&gt;
&lt;datalist&gt;
</code></pre>
<h2 id="example-site-and-code-repository">Example Site and Code Repository</h2>
<p>The code is in a my <a href="https://github.com/ShaunCurtis/Blazor.Database/">Blazor.Database</a> repository <a href="https://github.com/ShaunCurtis/Blazor.Database/tree/master/Blazor.SPA/Components/FormControls">here in Blazor.SPA/Components/FormControls</a></p>
<p>The controls can be seen in action <a href="https://cec-blazor-database.azurewebsites.net/editorcontrols">here on my Blazor.Database Demo Site</a>.</p>
<h2 id="exploring-binding-in-a-test-control">Exploring binding in a Test Control</h2>
<p>Before we build our controls, let's explore what's going on in bindings.  You can skip this section if you know your bind triumvirate.</p>
<p>Start with a standard Razor component and code behind file - <em>MyInput.razor</em> and <em>MyInput.Razor.cs</em>.</p>
<p>Add the following code to <em>MyInput.razor.cs</em>.</p>
<ol>
<li>We have what is known as the &quot;Triumverate&quot; of bind properties.
<ol>
<li><code>Value</code> is the actual value to display.</li>
<li><code>ValueChanged</code> is a Callback that gets wired up to set the value in the parent.</li>
<li><code>ValueExpression</code> is a lambda expression that points back to the source property in the parent.  It's used to generate a <code>FieldIdentifier</code> used in validation and state management to uniquely identify the field.</li>
</ol>
</li>
<li><code>CurrentValue</code> is the control internal <em>Value</em>.  It updates <code>Value</code> and invokes <code>ValueChanged</code> when changed.</li>
<li><code>AdditionalAttributes</code> is used to capture the class and other attributes added to the control.</li>
</ol>
<pre><code class="language-csharp">namespace MyNameSpace.Components
{
    public partial class MyInput
    {
        [Parameter] public string Value { get; set; }
        [Parameter] public EventCallback&lt;string&gt; ValueChanged { get; set; }
        [Parameter] public Expression&lt;Func&lt;string&gt;&gt; ValueExpression { get; set; }
        [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary&lt;string, object&gt; AdditionalAttributes { get; set; }

        protected virtual string CurrentValue
        {
            get =&gt; Value;
            set
            {
                if (!value.Equals(this.Value))
                {
                    Value = value;
                    if (ValueChanged.HasDelegate)
                        _ = ValueChanged.InvokeAsync(value);
                }
            }
        }
    }
}
</code></pre>
<p>Add a Text <code>input</code> html control to the razor file.</p>
<ol>
<li>Namespace is added so <em>Components</em> can be divided into subfolders as the number of source files grow.</li>
<li><code>@bind-value</code> points to the controls <code>CurrentValue</code> property.</li>
<li><code>@attributes</code> adds the control attributes to <code>input</code>.</li>
</ol>
<pre><code class="language-html">@namespace MyNameSpace.Components

&lt;input type=&quot;text&quot; @bind-value=&quot;this.CurrentValue&quot; @attributes=&quot;this.AdditionalAttributes&quot; /&gt;
</code></pre>
<h4 id="test-page">Test Page</h4>
<p>Add a Test page to <em>Pages</em> - or overwrite index if you're using a test site.  We'll use this for testing all the controls.</p>
<p>This doesn't need much explanation.  Bootstrap for formatting, classic <code>EditForm</code>.  <code>CheckButton</code> gives us a easy breakpoint we can hit to check values and objects.</p>
<p>You can see our <code>MyInput</code> in the form.</p>
<pre><code class="language-html">@page &quot;/&quot;

@using MyNameSpace.Components

&lt;EditForm Model=&quot;this.model&quot; OnValidSubmit=&quot;this.ValidSubmit&quot;&gt;
    &lt;div class=&quot;container m-5 p-4 border border-secondary&quot;&gt;
        &lt;div class=&quot;row mb-2&quot;&gt;
            &lt;div class=&quot;col-12&quot;&gt;
                &lt;h2&gt;Test Editor&lt;/h2&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;row mb-2&quot;&gt;
            &lt;div class=&quot;col-4 form-label&quot; for=&quot;txtcountry&quot;&gt;
                Country
            &lt;/div&gt;
            &lt;div class=&quot;col-4&quot;&gt;
                &lt;MyInput id=&quot;txtcountry&quot; @bind-Value=&quot;model.Value&quot; class=&quot;form-control&quot;&gt;&lt;/MyInput&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;row mb-2&quot;&gt;
            &lt;div class=&quot;col-6&quot;&gt;
            &lt;/div&gt;
            &lt;div class=&quot;col-6 text-right&quot;&gt;
                &lt;button class=&quot;btn btn-secondary&quot; @onclick=&quot;(e) =&gt; this.CheckButton()&quot;&gt;Check&lt;/button&gt;
                &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/EditForm&gt;

&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row mb-2&quot;&gt;
        &lt;div class=&quot;col-4 form-label&quot;&gt;
            Test Value
        &lt;/div&gt;
        &lt;div class=&quot;col-4 form-control&quot;&gt;
            @this.model.Value
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;row mb-2&quot;&gt;
        &lt;div class=&quot;col-4 form-label&quot;&gt;
            Test Index
        &lt;/div&gt;
        &lt;div class=&quot;col-4 form-control&quot;&gt;
            @this.model.index
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-csharp">@code {

    Model model = new Model() { Value = &quot;Australia&quot;, index = 2 };

    private void CheckButton()
    {
        var x = true;
    }

    private void ValidSubmit()
    {
        var x = true;
    }

    class Model
    {
        public string Value { get; set; } = string.Empty;
        public int index { get; set; } = 0;
    }
}
</code></pre>
<p>Note the value display update as you change the text in <code>MyInput</code>.</p>
<p>Under the hood the Razor compiler builds the section containing <code>MyInput</code> into component code like this:</p>
<pre><code class="language-csharp">__builder2.OpenComponent&lt;TestBlazorServer.Components.MyInput&gt;(12);
__builder2.AddAttribute(13, &quot;id&quot;, &quot;txtcountry&quot;);
__builder2.AddAttribute(14, &quot;class&quot;, &quot;form-control&quot;);
__builder2.AddAttribute(15, &quot;Value&quot;, Microsoft.AspNetCore.Components.CompilerServices.RuntimeHelpers.TypeCheck&lt;System.String&gt;(model.Value));
__builder2.AddAttribute(16, &quot;ValueChanged&quot;, Microsoft.AspNetCore.Components.CompilerServices.RuntimeHelpers.TypeCheck&lt;Microsoft.AspNetCore.Components.EventCallback&lt;System.String&gt;&gt;(Microsoft.AspNetCore.Components.EventCallback.Factory.Create&lt;System.String&gt;(this, Microsoft.AspNetCore.Components.CompilerServices.RuntimeHelpers.CreateInferredEventCallback(this, __value =&gt; model.Value = __value, model.Value))));
__builder2.AddAttribute(17, &quot;ValueExpression&quot;, Microsoft.AspNetCore.Components.CompilerServices.RuntimeHelpers.TypeCheck&lt;System.Linq.Expressions.Expression&lt;System.Func&lt;System.String&gt;&gt;&gt;(() =&gt; model.Value));
__builder2.CloseComponent();
</code></pre>
<p>You can see the compiled c# file in the <em>obj</em> folder.  On my project this is <em>\obj\Debug\net5.0\RazorDeclaration\Components\FormControls</em>.</p>
<p><code>@bind-value</code> has translated into a full mapping to the <code>Value</code>, <code>ValueChanged</code> and <code>ValueExpression</code> triumvirate. The setting of <code>Value</code> and <code>ValueExpression</code> are self explanatory.  <code>ValueChanged</code> uses a code factory to generate a runtime method that maps to <code>ValueChanged</code> and sets model.Value to the value returned by <code>ValueChanged</code>.</p>
<p>This explains a common misconception - you can attach an event handler to <code>@onchange</code> like this:</p>
<pre><code class="language-html">&lt;input type=&quot;text&quot; @bind-value =&quot;model.Value&quot; @onchange=&quot;(e) =&gt; myonchangehandler()&quot;/&gt;
</code></pre>
<p>There's no <code>@onchange</code> event on the control, and the one on the inner control is already bound so can't be bound a second time.  You get no error message, just no trigger.</p>
<h2 id="inputbase">InputBase</h2>
<p>Let's move on to <code>InputBase</code>.</p>
<p>First we'll look at <code>InputText</code> to see an implementation.</p>
<ol>
<li>The Html <em>input</em> <code>value</code> is bound to <code>CurrentValue</code> and <code>onchange</code> event to <code>CurrentValueAsString</code>.  Any change in the value calls the setter for <code>CurrentValueASsString</code>.</li>
<li><code>TryParseValueFromString</code> just passes on <code>value</code> (the entered value) as <code>result</code>.  There's no string to other type conversion to do.</li>
</ol>
<pre><code class="language-csharp">public class InputText : InputBase&lt;string?&gt;
{
    [DisallowNull] public ElementReference? Element { get; protected set; }

    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        builder.OpenElement(0, &quot;input&quot;);
        builder.AddMultipleAttributes(1, AdditionalAttributes);
        builder.AddAttribute(2, &quot;class&quot;, CssClass);
        builder.AddAttribute(3, &quot;value&quot;, BindConverter.FormatValue(CurrentValue));
        builder.AddAttribute(4, &quot;onchange&quot;, EventCallback.Factory.CreateBinder&lt;string?&gt;(this, __value =&gt; CurrentValueAsString = __value, CurrentValueAsString));
        builder.AddElementReferenceCapture(5, __inputReference =&gt; Element = __inputReference);
        builder.CloseElement();
    }

    protected override bool TryParseValueFromString(string? value, out string? result, [NotNullWhen(false)] out string? validationErrorMessage)
    {
        result = value;
        validationErrorMessage = null;
        return true;
    }
}
</code></pre>
<p>Let's delve into <code>InputBase</code>.</p>
<p>The <code>onchange</code> event sets <code>CurrentValueAsString</code>. Note it's not virtual, so can't be overidden.</p>
<pre><code class="language-csharp">protected string? CurrentValueAsString
{
    get =&gt; FormatValueAsString(CurrentValue);
    set
    {
        // clear the ValidationMessageStore
        _parsingValidationMessages?.Clear();

        bool parsingFailed;

        // Error if can't be null and value is null. 
        if (_nullableUnderlyingType != null &amp;&amp; string.IsNullOrEmpty(value))
        {
            parsingFailed = false;
            CurrentValue = default!;
        }
        // Call TryParseValueFromString.  
        else if (TryParseValueFromString(value, out var parsedValue, out var validationErrorMessage))
        {
            // If we pass complete and set CurrentValue
            parsingFailed = false;
            CurrentValue = parsedValue!;
        }
        else
        {   
            // We reach here if we fail parsing
            // set flags and make sure we have a ValidationMessageStore
            parsingFailed = true;
            
            if (_parsingValidationMessages == null)
            {
                _parsingValidationMessages = new ValidationMessageStore(EditContext);
            }
            // Add a parsing error message to the store
            _parsingValidationMessages.Add(FieldIdentifier, validationErrorMessage);

            // Since we're not writing to CurrentValue, we'll need to notify about modification from here
            EditContext.NotifyFieldChanged(FieldIdentifier);
        }

        // skip the validation notification if we were previously valid and still are
        // if we failed this time notify 
        // if we failed last time but are ok now we need notify to get the validation controls cleared
        if (parsingFailed || _previousParsingAttemptFailed)
        {
            EditContext.NotifyValidationStateChanged();
            _previousParsingAttemptFailed = parsingFailed;
        }
    }
}
</code></pre>
<p>The input <code>value</code> binds to the <code>CurrentValue</code> getter, and <code>CurrentValueAsString</code> sets it.  Note again it's not <code>virtual</code> so no overide.</p>
<pre><code class="language-csharp">    protected TValue? CurrentValue
    {
        // straight getter from Value
        get =&gt; Value;
        set
        {
            // Checks for equality between submitted value and class Value
            var hasChanged = !EqualityComparer&lt;TValue&gt;.Default.Equals(value, Value);
            // and if it's changed
            if (hasChanged)
            {
                // sets the class Value
                Value = value;
                // calls the ValueChanged EventHandler to update the parent value
                _ = ValueChanged.InvokeAsync(Value);
                // Notifies the EditContext that the field has changed and passes the FieldIdentifier
                EditContext.NotifyFieldChanged(FieldIdentifier);
            }
        }
    }
</code></pre>
<p>Finally, <code>TryParseValueFromString</code> is abstract so must be implemented in inherited classes.  It's purpose is to validate and convert the submitted string to the correct <code>TValue</code>.</p>
<pre><code class="language-csharp">protected abstract bool TryParseValueFromString(string? value, [MaybeNullWhen(false)] out TValue result, [NotNullWhen(false)] out string? validationErrorMessage);
</code></pre>
<h2 id="building-our-datalist-control">Building our DataList Control</h2>
<p>First we need a helper class to get the country list.  Get the full class from the Repo.</p>
<pre><code class="language-csharp">using System.Collections.Generic;

namespace MyNameSpace.Data
{
    public static class Countries
    {
        public static List&lt;KeyValuePair&lt;int, string&gt;&gt; CountryList
        {
            get
            {
                List&lt;KeyValuePair&lt;int, string&gt;&gt; list = new List&lt;KeyValuePair&lt;int, string&gt;&gt;();
                var x = 1;
                foreach (var v in CountryArray)
                {
                    list.Add(new KeyValuePair&lt;int, string&gt;(x, v));
                    x++;
                }
                return list;
            }
        }

        public static SortedDictionary&lt;int, string&gt; CountryDictionary
        {
            get
            {
                SortedDictionary&lt;int, string&gt; list = new SortedDictionary&lt;int, string&gt;();
                var x = 1;
                foreach (var v in CountryArray)
                {
                    list.Add(x, v);
                    x++;
                }
                return list;
            }
        }

        public static string[] CountryArray = new string[]
        {
            &quot;Afghanistan&quot;,
            &quot;Albania&quot;,
            &quot;Algeria&quot;,
.....
            &quot;Zimbabwe&quot;,
        };
    }
}
</code></pre>
<h3 id="build-the-control">Build the control</h3>
<p>This is the partial class, setting <code>TValue</code> as a <code>string</code>.  There are inline explanation notes.</p>
<pre><code class="language-csharp">public partial class InputDataList : InputBase&lt;string&gt;
{
    // List of values for datalist
    [Parameter] public IEnumerable&lt;string&gt; DataList { get; set; }
        
    // parameter to restrict valid values to the list
    [Parameter] public bool RestrictToList { get; set; }

    // unique id for the datalist based on a guid - we may have more than one in a form
    private string dataListId { get; set; } = Guid.NewGuid().ToString();

    // instruction to CurrentStringValue that we are in RestrictToList mode and the user has tabbed
    private bool _valueSetByTab = false;
    // current typed value in the input box - kept up to date by UpdateEnteredText
    private string _typedText = string.Empty;

    // New method to parallel CurrentValueAsString
    protected string CurrentStringValue
    {
        get
        {
            // check if we have a match to the datalist and get the value from the list
            if (DataList != null &amp;&amp; DataList.Any(item =&gt; item == this.Value))
                return DataList.First(item =&gt; item == this.Value);
            // if not return an empty string
            else if (RestrictToList)
                return string.Empty;
            else
                return _typedText;
        }
        set
        {
            // Check if we have a ValidationMessageStore
            // Either get one or clear the existing one
            if (_parsingValidationMessages == null)
                _parsingValidationMessages = new ValidationMessageStore(EditContext);
            else
                _parsingValidationMessages?.Clear(FieldIdentifier);

            // Set defaults
            string val = string.Empty;
            var _havevalue = false;
            // check if we have a previous valid value - we'll stick with this is the current attempt to set the value is invalid
            var _havepreviousvalue = DataList != null &amp;&amp; DataList.Contains(value);

            // Set the value by tabbing in Strict mode.  We need to select the first entry in the DataList
            if (_setValueByTab)
            {
                if (!string.IsNullOrWhiteSpace(this._typedText))
                {
                    // Check if we have at least one match in the filtered list
                    _havevalue = DataList != null &amp;&amp; DataList.Any(item =&gt; item.Contains(_typedText, StringComparison.CurrentCultureIgnoreCase));
                    if (_havevalue)
                    {
                        // the the first value
                        var filteredList = DataList.Where(item =&gt; item.Contains(_typedText, StringComparison.CurrentCultureIgnoreCase)).ToList();
                        val = filteredList[0];
                    }
                }
            }
            // Normal set
            else if (this.RestrictToList)
            {
                // Check if we have a match and set it if we do
                _havevalue = DataList != null &amp;&amp; DataList.Contains(value);
                if (_havevalue)
                    val = DataList.First(item =&gt; item.Equals(value));
            }
            else
            {
                _havevalue = true;
                val = value;
            }

            // check if we have a valid value
            if (_havevalue)
            {
                // assign it to current value - this will kick off a ValueChanged notification on the EditContext
                this.CurrentValue = val;
                // Check if the last entry failed validation.  If so notify the EditContext that validation has changed i.e. it's now clear
                if (_previousParsingAttemptFailed)
                {
                    EditContext.NotifyValidationStateChanged();
                    _previousParsingAttemptFailed = false;
                }
            }
            // We don't have a valid value
            else
            {
                // check if we're reverting to the last entry.  If we don't have one the generate error message
                if (!_havepreviousvalue)
                {
                    // No match so add a message to the message store
                    _parsingValidationMessages?.Add(FieldIdentifier, &quot;You must choose a valid selection&quot;);
                    // keep track of validation state for the next iteration
                    _previousParsingAttemptFailed = true;
                    // notify the EditContext whick will precipitate a Validation Message general update
                    EditContext.NotifyValidationStateChanged();
                }
            }
            // Clear the Tab notification flag
            _setValueByTab = false;
        }
    }

    // Keep _typedText up to date with typed entry
    private void UpdateEnteredText(ChangeEventArgs e)
        =&gt; _typedText = e.Value.ToString();

    // Detector for Tabbing away from the input
    private void OnKeyDown(KeyboardEventArgs e)
    {
        // Check if we have a Tab with some text already typed and are in RestrictToList Mode
        _setValueByTab = RestrictToList &amp;&amp; (!string.IsNullOrWhiteSpace(e.Key)) &amp;&amp; e.Key.Equals(&quot;Tab&quot;) &amp;&amp; !string.IsNullOrWhiteSpace(this._typedText);
    }

    protected override bool TryParseValueFromString(string value, [MaybeNullWhen(false)] out string result, [NotNullWhen(false)] out string validationErrorMessage)
        =&gt; throw new NotSupportedException($&quot;This component does not parse string inputs. Bind to the '{nameof(CurrentValue)}' property, not '{nameof(CurrentValueAsString)}'.&quot;);
}
</code></pre>
<p>And the Razor:</p>
<ol>
<li>Input uses the CSS generated by the control.</li>
<li>Binds to <code>CurrentValue</code>.</li>
<li>Adds the additional Attributes, including the <code>Aria</code> generated by the control.</li>
<li>Binds <code>list</code> to the <code>datalist</code>.</li>
<li>Hooks up event handlers to <code>oninput</code> and <code>onkeydown</code>.</li>
<li>Builds the <code>datalist</code> from the control <code>DataList</code> property.</li>
</ol>
<pre><code class="language-html">@namespace MyNameSpace.Components
@inherits InputBase&lt;string&gt;

&lt;input class=&quot;@CssClass&quot; type=&quot;text&quot; @bind-value=&quot;this.CurrentStringValue&quot; @attributes=&quot;this.AdditionalAttributes&quot; list=&quot;@dataListId&quot; @oninput=&quot;UpdateEnteredText&quot; @onkeydown=&quot;OnKeyDown&quot; /&gt;

&lt;datalist id=&quot;@dataListId&quot;&gt;
    @foreach (var option in this.DataList)
    {
        &lt;option value=&quot;@option&quot; /&gt;
    }
&lt;/datalist&gt;
</code></pre>
<p>Test the control in the test page.</p>
<pre><code class="language-html">&lt;div class=&quot;row mb-2&quot;&gt;
    &lt;div class=&quot;col-4 form-label&quot; for=&quot;txtcountry&quot;&gt;
        Country (Any Value)
    &lt;/div&gt;
    &lt;div class=&quot;col-4&quot;&gt;
        &lt;InputDataList @bind-Value=&quot;model.Value&quot; DataList=&quot;Countries.CountryArray&quot; class=&quot;form-control&quot; placeholder=&quot;Select a country&quot;&gt;&lt;/InputDataList&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row mb-2&quot;&gt;
    &lt;div class=&quot;col-4 form-label&quot; for=&quot;txtcountry&quot;&gt;
        Country (Strict)
    &lt;/div&gt;
    &lt;div class=&quot;col-4&quot;&gt;
        &lt;InputDataList @bind-Value=&quot;model.StrictValue&quot; DataList=&quot;Countries.CountryArray&quot; RestrictToList=&quot;true&quot; class=&quot;form-control&quot; placeholder=&quot;Select a country&quot;&gt;&lt;/InputDataList&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-4&quot;&gt;
        &lt;ValidationMessage For=&quot;(() =&gt; model.StrictValue)&quot;&gt;&lt;/ValidationMessage&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-html">&lt;div class=&quot;row mb-2&quot;&gt;
    &lt;div class=&quot;col-4 form-label&quot;&gt;
        Country Value
    &lt;/div&gt;
    &lt;div class=&quot;col-4 form-control&quot;&gt;
        @this.model.Value
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row mb-2&quot;&gt;
    &lt;div class=&quot;col-4 form-label&quot;&gt;
        Country Strict Value
    &lt;/div&gt;
    &lt;div class=&quot;col-4 form-control&quot;&gt;
        @this.model.StrictValue
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-html">class Model
{
    public string Value { get; set; } = string.Empty;
    public string StrictValue { get; set; } = string.Empty;
    public int Index { get; set; } = 0;
    public int TIndex { get; set; } = 0;
    public int Opinion { get; set; } = 0;
}
</code></pre>
<p>The control doesn't use <code>CurrentValueAsString</code> and <code>TryParseValueFromString</code>.  Instead We build a parallel <code>CurrentStringValue</code>,containing all the logic in both <code>CurrentValueAsString</code> and <code>TryParseValueFromString</code>, and wire the html input to it.  We don't use <code>TryParseValueFromString</code>, but as it's abstract we need to implement a blind version of it.</p>
<h2 id="input-search-select-control">Input Search Select Control</h2>
<p>The Select replacement version of the control builds on <code>InputDataList</code>.  We:</p>
<ol>
<li>Convert over to a key/value pair list with a generic key.</li>
<li>Add the extra logic for convertion from TValue to string and back in the Html <em>input</em>.</li>
<li>Add the generics handling within the class.</li>
</ol>
<p>Copy <code>InputDataList</code> and rename it to <code>InputDataListSelect</code>.</p>
<p>Add the generic declaration.  The control will work with most obvious types as the Key - e.g. int, long, string.</p>
<pre><code class="language-csharp">public partial class InputDataListSelect&lt;TValue&gt; : InputBase&lt;TValue&gt;
</code></pre>
<p>Change DataList to a <code>SortedDictionary</code>.</p>
<pre><code class="language-csharp">[Parameter] public SortedDictionary&lt;TValue, string&gt; DataList { get; set; }
</code></pre>
<p>The extra private properties are as follows.</p>
<pre><code class="language-csharp">// the EditContext ValidationMessageStore
private ValidationMessageStore? _parsingValidationMessages;
// field to manage parsing failure
private bool _previousParsingAttemptFailed = false;

</code></pre>
<p><code>CurrentValue</code> has changed a little to handle K/V pairs and do K/V pair lookups.  Again the inline comments provide detail.</p>
<pre><code class="language-csharp">protected string CurrentStringValue
{
    get
    {
        // check if we have a match to the datalist and get the value from the K/V pair
        if (DataList != null &amp;&amp; DataList.Any(item =&gt; item.Key.Equals(this.Value)))
            return DataList.First(item =&gt; item.Key.Equals(this.Value)).Value;
        // if not return an empty string
        return string.Empty;
    }
    set
    {
        // Check if we have a ValidationMessageStore
        // Either get one or clear the existing one
        if (_parsingValidationMessages == null)
            _parsingValidationMessages = new ValidationMessageStore(EditContext);
        else
            _parsingValidationMessages?.Clear(FieldIdentifier);

        // Set defaults
        TValue val = default;
        var _havevalue = false;
        // check if we have a previous valid value - we'll stick with this is the current attempt to set the value is invalid
        var _havepreviousvalue = DataList != null &amp;&amp; DataList.ContainsKey(this.Value);

        // Set the value by tabbing.  We need to select the first entry in the DataList
        if (_setValueByTab)
        {
            if (!string.IsNullOrWhiteSpace(this._typedText))
            {
                // Check if we have at least one K/V match in the filtered list
                _havevalue = DataList != null &amp;&amp; DataList.Any(item =&gt; item.Value.Contains(_typedText, StringComparison.CurrentCultureIgnoreCase));
                if (_havevalue)
                {
                    // the the first K/V pair
                    var filteredList = DataList.Where(item =&gt; item.Value.Contains(_typedText, StringComparison.CurrentCultureIgnoreCase)).ToList();
                    val = filteredList[0].Key;
                }
            }
        }
        // Normal set
        else
        {
            // Check if we have a match and set it if we do
            _havevalue = DataList != null &amp;&amp; DataList.ContainsValue(value);
            if (_havevalue)
                val = DataList.First(item =&gt; item.Value.Equals(value)).Key;
        }

        // check if we have a valid value
        if (_havevalue)
        {
            // assign it to current value - this will kick off a ValueChanged notification on the EditContext
            this.CurrentValue = val;
            // Check if the last entry failed validation.  If so notify the EditContext that validation has changed i.e. it's now clear
            if (_previousParsingAttemptFailed)
            {
                EditContext.NotifyValidationStateChanged();
                _previousParsingAttemptFailed = false;
            }
        }
        // We don't have a valid value
        else
        {
            // check if we're reverting to the last entry.  If we don't have one the generate error message
            if (!_havepreviousvalue)
            {
                // No K/V match so add a message to the message store
                _parsingValidationMessages?.Add(FieldIdentifier, &quot;You must choose a valid selection&quot;);
                // keep track of validation state for the next iteration
                _previousParsingAttemptFailed = true;
                // notify the EditContext whick will precipitate a Validation Message general update
                EditContext.NotifyValidationStateChanged();
            }
        }
        // Clear the Tab notification flag
        _setValueByTab = false;
    }
}
</code></pre>
<p><code>OnKeyDown</code> sets the <code>_setValueByTab</code> flag.</p>
<pre><code class="language-csharp">private void UpdateEnteredText(ChangeEventArgs e)
    =&gt; _typedText = e.Value?.ToString();

private void OnKeyDown(KeyboardEventArgs e)
{
    // Check if we have a Tab with some text already typed
    _setValueByTab = ((!string.IsNullOrWhiteSpace(e.Key)) &amp;&amp; e.Key.Equals(&quot;Tab&quot;) &amp;&amp; !string.IsNullOrWhiteSpace(this._typedText));
}

// set as blind
protected override bool TryParseValueFromString(string? value, [MaybeNullWhen(false)] out TValue result, [NotNullWhen(false)] out string validationErrorMessage)
    =&gt; throw new NotSupportedException($&quot;This component does not parse normal string inputs. Bind to the '{nameof(CurrentValue)}' property, not '{nameof(CurrentValueAsString)}'.&quot;);
</code></pre>
<p>The Razor is almost the same:</p>
<ol>
<li><code>datalist</code> changes to accommodate a K/V pair list.</li>
<li>Add the <code>@typeparam</code>.</li>
</ol>
<pre><code class="language-html">@namespace Blazor.Database.Components
@inherits InputBase&lt;TValue&gt;
@typeparam TValue

&lt;input class=&quot;@CssClass&quot; type=&quot;text&quot; @bind-value=&quot;this.CurrentStringValue&quot; @attributes=&quot;this.AdditionalAttributes&quot; list=&quot;@dataListId&quot; @oninput=&quot;UpdateEnteredText&quot; @onkeydown=&quot;OnKeyDown&quot; /&gt;

&lt;datalist id=&quot;@dataListId&quot;&gt;
    @foreach (var kv in this.DataList)
    {
        &lt;option value=&quot;@kv.Value&quot; /&gt;
    }
&lt;/datalist&gt;
</code></pre>
<p>Test it by adding a row to the edit table in the test page.  Try entering an invalid string - something like &quot;xxxx&quot;.</p>
<pre><code class="language-html">&lt;div class=&quot;row mb-2&quot;&gt;
    &lt;div class=&quot;col-4 form-label&quot; for=&quot;txtcountry&quot;&gt;
        Country T Index
    &lt;/div&gt;
    &lt;div class=&quot;col-4&quot;&gt;
        &lt;InputDataListSelect TValue=&quot;int&quot; @bind-Value=&quot;model.TIndex&quot; DataList=&quot;Countries.CountryDictionary&quot; class=&quot;form-control&quot; placeholder=&quot;Select a country&quot;&gt;&lt;/InputDataListSelect&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-4&quot;&gt;
        &lt;ValidationMessage For=&quot;(() =&gt; model.TIndex)&quot;&gt;&lt;/ValidationMessage&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-html">&lt;div class=&quot;row mb-2&quot;&gt;
    &lt;div class=&quot;col-4 form-label&quot;&gt;
        Country T Index
    &lt;/div&gt;
    &lt;div class=&quot;col-4 form-control&quot;&gt;
        @this.model.TIndex
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-csharp">class Model
{
    public string Value { get; set; } = string.Empty;
    public string StrictValue { get; set; } = string.Empty;
    public int Index { get; set; } = 0;
    public int TIndex { get; set; } = 0;
    public int Opinion { get; set; } = 0;
}
</code></pre>
<h2 id="wrap-up">Wrap Up</h2>
<p>Building edit components is not trivial, but also should not be feared.</p>
<p>The examples I've built are based on <code>InputBase</code>.  If you start building your own controls, I thoroughly recommend taking a little time and getting familiar with <code>InputBase</code> and it's siblings.  The code is <a href="https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web/src/Forms/InputBase.cs">here</a>.</p>
</div></div></div></body></html>





